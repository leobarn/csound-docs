<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>CSCORE EXAMPLE: CS11CUE.C</title>	</head>	<body bgcolor="white">		<a href="3Csccdrom.htm#CONTENTS">Return</a> to main text about the applications		<pre>/* CS11CUE.C - create n event blocks at specified time cues, with cresc/dim *//* CS11CUE V0.8TT A Endrich,  17 August 1995 *//* Developed from Cscore example in Csound manual *//* 24 Dec 1997 - Atari drand48() replaced by rand() for use on PC's *//* * Derived from example of applying diminuendo in CDP Csound Manual, p.91 * Illustrates the way the 'i' events of a score can be separated out, *	copied, re-shaped, re-copied etc.; in this case the emphasis is on *	start times (p2) and amplitude (p4). * Extended (AE) to allow inputting time cues from a file, to control the *	number of blocks from the command line, and to cresc/dim to/from the *	center of each event block;  also several start time processing *	options, each in a separate function;  cries out for a transposition *	option. * Note that the nature of the inscore.sc greatly affects the results, and *	that the blocks of events can be separated in time or overlap, *	depending on whether the cues are &gt; or &lt; the time interval between *	events in inscore.sc. * I've left the diagnostic messages in for now because it's useful to know *	what the program thinks these values are. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;math.h&gt;#include &quot;cscore.h&quot;/* DECLARE #DEFINES */#define	ADD		0#define	MULTIPLY	1#define	RAND		2#define	SAME		0#define	DIFFERENT	1/* DECLARE USER-DEFINED FUNCTIONS */void phelp(void);/* name(pval, cueval, process_type, score_type, counter) */double stt_up(double, double, int, int, int);	/* fn to shape s_times incr'g */double stt_dwn(double, double, int, int, int);	/* fn to shape s_times decr'g *//* name(pval, ampfactor, process_type, score_type, counter) */int vol_up(int, int, int, int, int);		/* fn to shape amps incr'g */int vol_dwn(int, int, int, int, int);		/* fn to shape amps decr'g *//* GLOBAL VARIABLES */double	*cues;		/* array to hold user's time cues */double	mult;		/* amplitude change factor multiplier */int	holdamp;	/* to hold high amp for case SAME down */int	range;		/* sets range for random function *//* USAGE / HELP */voidphelp(void) {	printf(&quot;\nCS11CUE: create n event-blocks at specified time cues, \with cresc/dim\n&quot;);	printf(&quot;\nUsage:\n&quot;);printf(&quot;cs11cue  -nnumcues -aampfactor [-mmultiplier] -tprocesstype \n&quot;);	printf(&quot;\t\t[-rrange] -iscoretype cuefile inscore.sc outscore.sc\n&quot;);	printf(&quot;\t-nnumcues\t(int) number of cues (temp measure!)\n&quot;);	printf(&quot;\t-aampfactor\t(int) amp change factor (+: 0-&gt;x000)\n&quot;);	printf(&quot;\t-mmultiplier\t(double) amp scaling ratio (*: &gt;0\n&quot;);	printf(&quot;\t-tprocesstype\t(int) type is way to process times\n&quot;);	printf(&quot;\t\t0: ADD fixed value\n&quot;);	printf(&quot;\t\t1: MULTIPLY by cueval &amp; multiplier\n&quot;);	printf(&quot;\t\t2: RANDOM (randval(0-1)*timecue*range)\n&quot;);	printf(&quot;\t-rrange\t\t(int) numerical range for rand fn\n&quot;);	printf(&quot;\t\tWARNING: Start times can be excessively high\n&quot;);	printf(&quot;\t\tif both start time &amp; cueval are rather large.\n&quot;);	printf(&quot;\t-iscoretype\ttype of input scorefile:\n&quot;);	printf(&quot;\t\t0: SAME\tvals in event pfields are the same\n&quot;);	printf(&quot;\t\t1: DIFFERENT\tvals in ev pfields are different\n&quot;);	printf(&quot;\tcuefile\t\tinfile of cue times (sec) (double)\n&quot;);	printf(&quot;\tinscore.sc	input Csound score file\n&quot;);	printf(&quot;\toutscore.sc	Csound score file output by program\n&quot;);	exit(1);}voidmain(int argc, char *argv[])int	argc;char	*argv[];{	EVENT	 *e, **f;	/* **f points to event struc in evlist struc */	EVLIST	 *a, *b;	/* pointers to the event list structures */	FILE	 *fp1;		/* input file of cue times */	int	 i, j, k, n, holdn, numcues;	int	 eof_flag = 0, ptype, stype, ampf, holdamp = 0;	char     message[81];	/* storage for diagnostic messages */		/* READ USER-DEFINED FLAGS/PARAMETER INPUT FROM COMMAND LINE */		while(argc &gt; 1 &amp;&amp; argv[1][0] == '-' &amp;&amp; argv[1][1] != 0) {		switch(argv[1][1]) {		case ('n'):			numcues = atoi(&amp;argv[1][2]);			printf(&quot;\n file has % time cues\n&quot;, numcues);			/* this is a fudge:  should be able to read this from */			/*   the file itself, but can't program this yet */			argc--, argv++;			break;		case ('a'):			ampf = atoi(&amp;argv[1][2]);			printf(&quot;\n amp factor is: %f \n&quot;, ampf);			argc--, argv++;			break;		case ('m'):			mult = atof(&amp;argv[1][2]);			printf(&quot;\n amp multiplier is: %f \n&quot;, mult);			argc--, argv++;			break;		case ('r'):			range = atoi(&amp;argv[1][2]);			printf(&quot;\n rand range is: %f \n&quot;, range);			argc--, argv++;			break;		case ('t'):			ptype = atoi(&amp;argv[1][2]);			printf(&quot;processing type is: %d\n&quot;, ptype);			argc--, argv++;			break;		case ('i'):			stype = atoi(&amp;argv[1][2]);			printf(&quot;input score type is: %d\n&quot;, stype);			argc--, argv++;			break;		default:			fprintf(stderr, &quot;CS11CUE: '%s' is not one of the \options\n&quot;, argv[1]);			phelp();			exit(1);		}	}	/* READ USER'S INPUT FILE OF CUE TIMES;  OPEN INSCORE &amp; OUTSCORE */	if((fp1 = fopen(argv[1], &quot;r&quot;))==NULL) {		fprintf(stderr, &quot;\nUnable to open your cuefile %s \n&quot;, argv[1]);		phelp();		exit(1);	}	argc--, argv++;	/* inscore.sc &amp; outscore.sc now remaining on cmdline */		if((cues = (double *)malloc(numcues * sizeof(double)))==NULL) {		fprintf(stderr,&quot;\n\tcannot allocate memory for cues array\n&quot;);	}		for(i = 0; i &lt; numcues &amp;&amp; eof_flag != EOF; ++i) {		eof_flag = fscanf(fp1, &quot;%lf&quot;, &cues[i]);		if(eof_flag != EOF) {			fprintf(stderr,&quot;cue %d read as %lf\n&quot;, i, cues[i]);		}		}	initial(argc, argv);	/* re-check args &amp; open inscore &amp; outscore */	if(argc &lt; 2) {		/* Usage if not enough filenames */		phelp();		exit(1);	}	/* PROCEED TO CREATE THE OUTPUT SCORE FILE */	a = lget();		/* read in the inscore */	b = lsepf(a);		/* separate out the f statements */	lput(b);		/* write f statements to outscore */	lrelev(b);		/* release space used */	e = defev(&quot;t 0 76&quot;);	/* define tempo event */	putev(e);		/* write this tempo event to outscore *//*	lput(a);		 put orig events in score for comparison *//*	putstr(&quot;s\n&quot;);		end-of-section;  new times begin at 0 *//*	putev(e);		write new tempo event for next section */	n = a-&gt;nevents;		/* set n to number of events in list 'a' */	printf(&quot;diagnostic:  n = a-&gt;nevents = %d\n&quot;, n);	holdn = n;		/* second variable which won't change */	i = 0;			/* counter through cue array set to 0 */	j = 0;			/* inner loop counter */	k = 0;			/* counter for decrementing values */	/* THE NUMBER OF TIME CUES SPECIFIES THE NUMBER OF BLOCKS: */	for(i = 0; i &lt; numcues; i++) { /* numcues OUTER loops = event blocks */		printf(&quot;\ndiagnostic:  Event block %d, time cue=%lf\n&quot;,\i, cues[i]);		f = &amp;a-&gt;e[1];	/* reset pointer to first event of list a */				/* i.e. make a new block */		n = holdn;	/* reset n to original event count */		/* THIS HANDLES THE EVENTS OF EACH BLOCK, CALLING FUNCTIONS: */		for(j = 0; j &lt; n; j++) {  /* INNER loop: adjust event pfields */		   if(i &lt; abs(n/2)) {			(*f)-&gt;p[2] = stt_up((*f)-&gt;p[2],cues[i],ptype,stype,j);			(*f)-&gt;p[4] = vol_up((*f)-&gt;p[4],ampf,ptype,stype,j);			holdamp = (*f)-&gt;p[4];	/* hold amplitude peak */			f++;			/* move on to next event */		   }			/* NEXT CODE HANDLES CRESC/DIM, WITH OVERFLOW CONTROL */			/* NOTE THAT INCREASE ADDED TO VALS OF PREVIOUS BLOCK */		   else {			(*f)-&gt;p[2] = stt_up((*f)-&gt;p[2],cues[i],ptype,stype, k);			(*f)-&gt;p[4] = vol_dwn((*f)-&gt;p[4], ampf, ptype, stype, k);			f++;			/* move on to next event */			k++;		   }		}		sprintf(message, &quot;\n;diagnostic: cue = %f&quot;, cues[i]);		putstr(message); /*note method of writing diagnostic to .sc */		lput(a);	/* write this event-list-block to outscore */	}			/* back to OUTER FOR loop &amp; do next block */	putstr(&quot;e&quot;);		/* write end of score marker */}/* SUBROUTINES TO ADD TIME CUES TO ALL START TIMES &amp; ALTER AMPLITUDES *//* NB - The next time cue is added to the start time of the previous block. */doublestt_up(double p2, double cueval, int tflag, int sflag, int counter)/* double p2;		current p2 value (start time ) *//* double cueval; 	current time cue value to use in calculations *//* int	tflag;  	processing type flag *//* int	sflag;		inscore type flag *//* int	counter;	loop counter */{	if(tflag == ADD &amp;&amp; sflag == SAME) {		/* type 0 0 */		p2 = p2 + (counter * cueval);	}	if(tflag == ADD &amp;&amp; sflag == DIFFERENT) {	/* type 0 1 */		p2 = p2 + cueval;	}	if(tflag == MULTIPLY &amp;&amp; sflag == SAME) {	/* type 1 0 */		p2 = p2 + (counter * cueval * mult);	}	if(tflag == MULTIPLY &amp;&amp; sflag == DIFFERENT) {	/* type 1 1 */		p2 = p2 + (cueval * mult);	}	if(tflag == RAND &amp;&amp; sflag == SAME) {		/* type 2 0 */		p2 = p2 + (int)(rand()*counter*cueval);	}	if(tflag == RAND &amp;&amp; sflag == DIFFERENT) {	/* type 2 1 */		p2 = p2 + (rand()*cueval);	}	return(p2);}/* SUBROUTINES TO INCREMENT AMOUNT BY WHICH THE AMPLITUDE IS CHANGED *//* NB - change is added to/subtracted  from the values of the previous block */intvol_up(int p4, int af, int tflag, int sflag, int counter)/* int	p4;		current p4 value (amplitude) *//* int	af;		amplitude change factor *//* int	tflag;		processing type flag *//* int	sflag;		inscore type flag, 0: same vals, 1: diff. vals *//* int	counter;	event loop count */{	if(tflag == ADD &amp;&amp; sflag == SAME) {		/* type 0 0 */		p4 = p4 + (counter * af);	/* amplitude change */	}	if(tflag == ADD &amp;&amp; sflag == DIFFERENT) {	/* type 0 1 */		if(counter == 0) af = 0;		/* 1st event zero */		p4 = p4 + af;	}	if(tflag == MULTIPLY &amp;&amp; sflag == SAME) {	/* type 1 0 */		p4 = p4 + (counter * af * mult);	/* amplitude change */	}	if(tflag == MULTIPLY &amp;&amp; sflag == DIFFERENT) {	/* type 1 1 */		if(counter == 0) af = 0;		/* 1st event zero */		p4 = p4 + (af * mult);	}	if(tflag == RAND &amp;&amp; sflag == SAME) {		/* type 2 0 */		p4 = p4 + (int)(rand()*counter*af); /* ampl change */	}	if(tflag == RAND &amp;&amp; sflag == DIFFERENT) {	/* type 2 1 */		if(counter == 0) af = 0;		/* 1st event zero */		p4 = p4 + (rand()*af);		/* amplitude change */	}	return(p4);}int vol_dwn(int p4, int af, int tflag, int sflag, int counter)/* int	p4;		current p4 value (amplitude) *//* int	af;		amplitude change factor *//* int	tflag;		processing type flag *//* int	sflag;		inscore type flag, 0: same vals, 1: diff. vals *//* int	counter;	event loop count */{	if(tflag == ADD &amp;&amp; sflag == SAME) {		/* type 0 0 */		p4 = holdamp - (counter * af);		/* amplitude change */	}	if(tflag == ADD &amp;&amp; sflag == DIFFERENT) {	/* type 0 1 */		if(counter == 0) af = 0;		/* 1st ev no change */		p4 = p4 - af;	}	if(tflag == MULTIPLY &amp;&amp; sflag == SAME) {	/* type 1 0 */		p4 = holdamp - (counter * af * mult);	}	if(tflag == MULTIPLY &amp;&amp; sflag == DIFFERENT) {	/* type 1 1 */		if(counter == 0) af = 0;		/* 1st ev no change */		p4 = p4 - (af * mult);			/* subtract */	}	if(tflag == RAND &amp;&amp; sflag == SAME) {		/* type 2 0 */		p4 = p4 - (int)(rand()*counter*af);	}	if(tflag == RAND &amp;&amp; sflag == DIFFERENT) {	/* type 2 1 */		if(counter == 0) af = 0;		/* 1st ev no change */		p4 = p4 - (rand()*af);	}	return(p4);}	</pre>		<p><a href="3Csccdrom.htm#CONTENTS">Return</a> to main text about the applications</p>		<p></body>	</body></html>