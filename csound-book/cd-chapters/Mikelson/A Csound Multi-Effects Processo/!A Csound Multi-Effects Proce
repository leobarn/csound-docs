<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><HTML><HEAD>    <!-- SGI_COMMENT COSMOCREATE -->    <!-- SGI_COMMENT VERSION NUMBER="1.0.1" -->    <TITLE>A Csound Multi-Effects Processor</TITLE>    <META NAME="GENERATOR" CONTENT="Internet Assistant for Word 1.0Z">    <META NAME="AUTHOR" CONTENT="End User">    <META NAME="OPERATOR" CONTENT="End User"></HEAD><BODY BGCOLOR="white"><H2><B>A Csound Multi-Effects Processor</B> </H2><P><A HREF="mailto:hljmm@werewolf.net">Hans Mikelson</A> </P><H3><B>Introduction</B> </H3><P>This chapter describes a Csound implementation of a multi-effects processor. Several categories of effects are presented including dynamics processing, filtering and pitch effects. Robin Whittle's <B>zak</B> opcodes provide a flexible method of routing between the effects routines. The <B>pluck</B> opcode is used to demonstrate these effects since many of them are often used with guitar. </P><P><B>The Zak System</B> </P><P>Communication between effects is handled by the <B>zak</B> opcodes. One advantage of the <B>zak</B> system over global variables is that communications between instruments may be reconfigured in the score without making changes to the orchestra. To utilize the <B>zak</B> opcodes they must first be initialized which is done with the following statement: <B>zakinit</B><I> num-a-rate, num-k-rate</I> where <I>num-a-rate</I> and <I>num-k-rate</I> are the number of audio rate and control rate channels allocated. </P><P>Communications between effects are accomplished using <B>zaw</B> and <B>zar</B>. To write to an audio channel<I> </I><B>zaw </B><I>asig, ichannel</I> is used. To read from an audio channel <I>asig </I><B>zar </B><I>ichannel </I>is used. Here <I>asig</I> is the audio signal and <I>ichannel</I> is the number of the channel. </P><P>The <B>zawm</B> opcode mixes the current contents of the audio channel with the new audio data. During a chord several instances of the pluck instrument are active at the same time so the pluck instrument uses <B>zawm</B> to accumulate sound. The audio channels must be cleared every sample period or the data will continue to accumulate. The mixer is the last instrument in the orchestra and is used to clear audio channels 0-30 with the statement <B>zacl</B><I> 0, 30</I>. </P><P><B>Mixer</B> </P><P>The mixer reads from four audio channels and provides independent gain and pan control for each channel. </P><PRE>asig1  zar      p4                                           &#13;&#13;igl1   init     p5*p6                                        &#13;&#13;igr1   init     p5*(1-p6)                                    &#13;&#13;asig2  zar      p7                                           &#13;&#13;igl2   init     p8*p9                                        &#13;&#13;igr2   init     p8*(1-p9)                                    &#13;&#13;asig3  zar      p10                                          &#13;&#13;igl3   init     p11*p12                                      &#13;&#13;igr3   init     p11*(1-p12)                                  &#13;&#13;asig4  zar      p13                                          &#13;&#13;igl4   init     p14*p15                                      &#13;&#13;igr4   init     p14*(1-p15)                                  &#13;&#13;asigl  =        asig1*igl1+asig2*igl2+asig3*igl3+asig4*igl4  &#13;&#13;asigr  =        asig1*igr1+asig2*igr2+asig3*igr3+asig4*igr4  &#13;&#13;&#13;</PRE><P><B>Dynamics Processing</B> </P><P>This section describes a compressor, a limiter, a noise gate, a de-esser and a distortion effect.1 These are all related effects which change the dynamics of the sound. </P><P><B>Compressor</B> </P><P>A compressor is used to reduce the dynamic range of a signal. It does this by monitoring the level of an input signal and varying the gain applied to the output signal. Sounds greater than a specified level are reduced in volume. The <B>rms</B> opcode can be used to give a time average of the level of the input signal. The output from <B>rms</B> is used to reference a table which determines the amount of gain applied to the output signal. A post gain is usually included to restore the level of the output signal after it has been compressed. The <B>rms </B>opcode does not respond immediately to changes in level so that sudden attacks are sometimes allowed to pass. To avoid this the original signal is monitored and compression is applied to a time delayed copy of the signal. In this example a delay time equal to one half of the <B>rms</B> averaging time is used. </P><PRE>asig   zar      iinch                  ;Read input         &#13;&#13;kamp   rms      asig, ifqc             ;Find rms level     &#13;&#13;kampn  =        kamp/30000             ;Normalize rms      &#13;&#13;kcomp  tablei   kampn,itab,1,0         ;Look up compress.  &#13;&#13;adel1  delayr   ideltm                 ;Delay for ideltm   &#13;&#13;       delayw   asig                   ;Write to delay     &#13;&#13;acomp  =        kcomp*adel1*ipostgain  ;Apply compression  &#13;&#13;       zaw      acomp*kenv, ioutch     ;declick &amp; output   &#13;&#13;&#13;</PRE><P>The amount of compression is given by the compression curve <I>f6</I>. Compression levels of 2:1 and 4:1 are common. </P><P><TT>f6 13 1025 7 1 256 1 256 .5 513 .5</TT> </P><P>The compressor block diagram is presented in figure 1. </P><P><IMG SRC="DOCS/mltfx1.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx1.gif"></P><P><B>Figure 1</B> </P><P>Compressor/Limiter block diagram. </P><P><B>Limiter</B> </P><P>The limiter is merely a compressor with a very severe compression curve. Limiters prevent a signal level from going above a specified limit. Limiters commonly use compression levels of 10:1 or 100:1. This can be implemented by simply using a different compression table: </P><P><TT>f6 13 1025 7 1 256 1 512 .01 129 .01</TT> </P><P><B>Noise Gate</B> </P><P>Noise gates are used to remove unwanted background noise and hiss from a signal. A noise gate can be implemented by changing the <I>f6</I> table again. </P><P><TT>f6 13 1025 7 0 64 0 0 1 448 1 513 1</TT> </P><P>In this case signals below a certain level are completely silent. Once they exceed that level they are allowed to pass. Noise gates are sometimes criticized for removing playing dynamics. To solve this problem a delayed signal is used to determine the level and the original signal is modified and output. This results in the gate opening just before playing begins. This technique can also be used on a compressor to prevent compression of initial playing dynamics. </P><P><IMG SRC="DOCS/mltfx2.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx2.gif"></P><P><B>Figure 2</B> </P><P>Noise Gate block diagram. </P><PRE>asig   zar      iinch                  ;Read from input       &#13;&#13;adel1  delayr   ideltm                 ;Delay the signal      &#13;&#13;       delayw   asig                                          &#13;&#13;kamp   rms      adel1, ifqc            ;Calculate RMS         &#13;&#13;kampn  =        kamp/30000             ;Normalize to 0-1      &#13;&#13;kcomp  tablei   kampn,itab,1,0         ;Reference the table   &#13;&#13;acomp  =        kcomp*asig*ipostgain   ; Apply noise gate     &#13;&#13;       zaw      acomp*kenv, ioutch     ;Declick and write     &#13;&#13;&#13;</PRE><P><B>De-Esser</B> </P><P>The next effect considered in this section is the de-esser. Certain consonant sounds such as 's' and 'p' produce loud artifacts when a microphone is used. The de-esser is a relative of the compressor which can be used to reduce these artifacts. The de-esser monitors the level of the high frequency component of the signal and applies compression to the signal based on this level. This can be implemented by applying a high pass filter to the input signal and monitoring the level of the filtered signal. </P><P><IMG SRC="DOCS/mltfx3.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx3.gif"></P><P><B>Figure 3</B> </P><P>De-Esser block diagram. </P><PRE>asig   zar        iinch                  ;Read input         &#13;&#13;afilt  butterhp   asig, ifco             ;High pass filter   &#13;&#13;kamp   rms        afilt, ifqc            ;Calculate rms      &#13;&#13;kampn  =          kamp/30000             ;Normalize rms 0-1  &#13;&#13;kcomp  tablei     kampn,itab,1,0         ;Look up in table   &#13;&#13;adel1  delayr     ideltm                 ;Delay signal       &#13;&#13;       delayw     asig                                       &#13;&#13;acomp  =          kcomp*adel1*ipostgain  ;Apply de-ess       &#13;&#13;       zaw        acomp*kenv, ioutch     ;Declick &amp; output   &#13;&#13;&#13;</PRE><P><B>Distortion</B> </P><P>This section describes a distortion effect. An amplifier can be considered as having two operating ranges: a linear range, and a non-linear range. In the linear range of operation the output signal is an amplified copy of the input signal. In the non-linear range of operation the output signal is a distorted version of the input signal. Early electronic amplifiers were based on vacuum tubes. Vacuum tube distortion is usually described as warmer and more musical than other types of distortion.2 </P><P>If a sine wave signal is passed through an overdriven tube amplifier the resulting waveform differs from the original in several ways. The top of the waveform becomes flattened or clipped. The bottom of the waveform is also flattened although not as much as the top. The duty cycle of the waveform is also shifted so that the upper part of the curve is not the same width as the lower part of the curve. The resulting shape is approximated in figure 1. </P><P><IMG SRC="DOCS/mltfx4.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx4.gif"></P><P><B>Figure 4</B> </P><P>Waveform of a sine wave processed through a tube amplifier. </P><P>Waveshaping may be used to reshape the input waveform to resemble figure 4. For slight distortion use the following table: </P><P><TT>f5 0 8192 8 -.8 336 -.78 800 -.7 5920 .7 800 .78 336 .8</TT> </P><P>For heavy distortion use the following table: </P><P><TT>f5 0 8192 7 -.8 934 -.79 934 -.77 934 -.64 1034 -.48 520 .47 2300 .48 1536 .48</TT> </P><P>A shifted duty cycle can be accomplished by implementing an amplitude dependent delay line. </P><P><IMG SRC="DOCS/mltfx5.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx5.gif"></P><P><B>Figure 5</B> </P><P>Distortion block diagram. </P><PRE>asigin  zar      izin                                        &#13;&#13;aold    =        asig                                        &#13;&#13;asig    =        igaini*asigin/60000                         &#13;&#13;aclip   tablei   asig,5,1,.5                                 &#13;&#13;aclip   =        igainf*aclip*15000                          &#13;&#13;atemp   delayr   .1                                          &#13;&#13;adel1   deltapi  (2-iduty*asig)/1500+islope*(asig-aold)/300  &#13;&#13;        delayw   aclip                                       &#13;&#13;        zaw      adel1, izout                                &#13;&#13;&#13;</PRE><P><B>Filtering Effects</B> </P><P>This section describes an equalizer, a wah-wah and a resonant low pass filter. </P><P><B>Equalizer</B> </P><P>An equalizer can be used to increase or decrease the level of different frequencies in a signal. In this example a three band equalizer is implemented. The <B>butterlp </B>and<B> butterhp</B> opcodes are used to isolate the low and high frequency components of the signal. The midrange component is isolated by high pass filtering above the low pass cut off frequency and low pass filtering below the high pass cut off frequency. Individual gains are applied to each of the three signal components before they are added together and output. </P><P><IMG SRC="DOCS/mltfx6.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx6.gif"></P><P><B>Figure 6</B> </P><P>3 Band Equalizer block diagram. </P><PRE>alosig   butterlp   asig, ilofco             ;Low pass       &#13;&#13;atmpsig  butterhp   asig, ilofco-ilofco/4    ;Midrange 1     &#13;&#13;amidsig  butterlp   atmpsig,                 ;Midrange 2     &#13;                    ihifco+ihifco/4                          &#13;&#13;ahisig   butterhp   asig, ihifco             ;Hi pass        &#13;&#13;aout     =    ilogain*alosig+imidgain*amidsig+ihigain*ahisi &#13;              g                                             &#13;&#13;&#13;</PRE><P><B>Wah-Wah</B> </P><P>A wah-wah pedal is a type of low-pass filter which incorporates several resonances to give it a unique character. In this example several resonances derived from vowel sounds &quot;ahh&quot; and &quot;ooh&quot; are used to add character to the standard low pass filter sound. The vowel &quot;ahh&quot; has resonances and amplitudes of 730 Hz -1 db, 1090 Hz -5 db, 2440 Hz -28 db. The vowel &quot;ooh&quot; has resonances of 300 Hz -3 db, 870 Hz -19 db, 2240 Hz -43 db. As the frequency is swept from high to low the resonances are swept from &quot;ahh&quot; to &quot;ooh.&quot; </P><P><IMG SRC="DOCS/mltfx7.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx7.gif"></P><P><B>Figure 7</B> </P><P>Wah-Wah </P><PRE>kosc1     oscil     .5,irate,itab1,.25    ;Oscilator          &#13;&#13;kosc2     =         kosc1 + .5            ;Rescale for 0-1    &#13;&#13;kosc3     =         kosc2                 ;Formant Depth 0-1  &#13;&#13;klopass   =         idepth*kosc2+ilow     ;Filter range       &#13;&#13;kform1    =         430*kosc2 + 300       ;Formant 1 range    &#13;&#13;kamp1     =         ampdb(-2*kosc3 + 59)*ifmix  ;F1 level     &#13;&#13;kform2    =         220*kosc2 + 870             ;F2 range     &#13;&#13;kamp2     =         ampdb(-14*kosc3 +           ;F2 level     &#13;                    55)*ifmix                                 &#13;&#13;kform3    =         200*kosc2 + 2240            ;F3 range     &#13;&#13;kamp3     =         ampdb(-15*kosc3 +           ;F3 level     &#13;                    32)*ifmix                                 &#13;&#13;                                                              &#13;&#13;afilt     butterlp  asig, klopass               ;Low pass     &#13;&#13;ares1     reson     afilt, kform1, kform1/8     ;Apply        &#13;&#13;ares2     reson     afilt, kform2, kform1/8     ;formant      &#13;&#13;ares3     reson     afilt, kform3, kform1/8     ;filters 1-3  &#13;&#13;aresbal1  balance   ares1, afilt                ;Restore      &#13;&#13;aresbal2  balance   ares2, afilt                ;balance      &#13;&#13;aresbal3  balance   ares3, afilt                              &#13;&#13;                                                              &#13;&#13;aout      =         afilt+kamp1*aresbal1        ;Add signals  &#13;&#13;aout      =         aout+kamp2*aresbal2+kamp3*aresbal3        &#13;&#13;&#13;</PRE><P><B>Resonant Low Pass Filter</B> </P><P>Some theory of resonant filters can be found in the chapter &quot;Classic Keyboard Instruments&quot; and will not be discussed here in detail. This implementation uses the <B>nlfilt</B> opcode which avoids the need of setting kr=sr and also provides for simpler code. This filter is designed to resonate for approximately the same amount of time no matter what the cut-off frequency is. </P><P><IMG SRC="DOCS/mltfx8.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx8.gif"></P><P><B>Figure 8</B> </P><P>Low pass resonant filter block diagram. </P><PRE>kfco    oscil    1,1/idur,itab1 ;Cut-off frequency sweep     &#13;&#13;kfcort  =        sqrt(kfco)  ;by table 1                     &#13;&#13;krezo   oscil    1,1/idur,itab2 ;Resonance sweep             &#13;&#13;krez     =       krezo*kfco/500 ;by table 2                  &#13;&#13;kamp    linseg   0, .002, 1, p3-.004, 1, .002, 0  ;Declick   &#13;&#13;axn     zar      izin                                        &#13;&#13;                                                             &#13;&#13;ka1     =        1000/krez/kfco-1 ;Resonant lp filter        &#13;&#13;ka2     =        100000/kfco/kfco                            &#13;&#13;kb      =        1+ka1+ka2                                   &#13;&#13;ay1     nlfilt   axn/kb, (ka1+2*ka2)/kb, -ka2/kb, 0, 0, 1    &#13;&#13;ay      nlfilt   ay1/kb, (ka1+2*ka2)/kb, -ka2/kb, 0, 0, 1    &#13;&#13;                                                             &#13;&#13;ka1lp   =        1000/kfco-1  ;Low pass filter               &#13;&#13;ka2lp   =        100000/kfco/kfco                            &#13;&#13;kblp    =        1+ka1lp+ka2lp                               &#13;&#13;ay1lp   nlfilt   axn/kblp,(ka1lp+2*ka2lp)/kblp,ka2lp/kblp,0, &#13;                 0,1                                         &#13;&#13;aylp    nlfilt   ay1lp/kblp,(ka1lp+2*ka2lp)/kblp,ka2lp/kblp, &#13;                 0,0,1                                       &#13;&#13;                                                             &#13;&#13;ayrez   =        ay - aylp  ;Extract the resonance           &#13;&#13;ayrz    =        ayrez/kfco  ;Adjust res. gain               &#13;&#13;ay2     =        aylp*6*ilpmix + ayrz*300*irzmix ;Mix Q &amp;    &#13;                 LP                                          &#13;&#13;&#13;</PRE><P><B>Pitch Effects</B> </P><P>This section describes vibrato, pitch shifting, chorus and flanging effects. All of these effects make use of delay lines whose delay times are modulated with an oscillator. An interpolating delay tap, <B>deltapi</B>, is used to allow continuous variation of the delay time. </P><P><B>Vibrato</B> </P><P>Vibrato can be accomplished by modulating a variable delay tap with a sine wave. When the delay tap sweeps forward in the same direction as the signal the pitch is lowered. As the delay tap sweeps backwards in the opposite direction of the signal the pitch is raised. </P><P><IMG SRC="DOCS/mltfx9.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx9.gif"></P><P><B>Figure 9</B> </P><P>Vibrato block diagram. </P><PRE>asig   zar       izin               &#13;&#13;kosc   oscil     iamp, ifqc, itab1  &#13;&#13;atemp  delayr    imax               &#13;&#13;aout   deltapi   kosc+imax/2        &#13;&#13;       delayw    asig               &#13;&#13;       zaw       aout, izout        &#13;&#13;&#13;</PRE><P><B>Pitch Shifting</B> </P><P>A simple type of pitch shifting can be implemented with a variable length interpolating delay tap. The delay time is modulated with a sawtooth wave whose amplitude is equal to the wavelength of the sound. This results in a resampling of the wave form with linear interpolation between successive samples. Lowering the pitch results in cycles being discarded periodically. Raising the pitch results in some cycles being repeated. In order to produce a good quality sample the wavelength of the sound must be known. In this example it is simply supplied when the instrument is called. </P><P><IMG SRC="DOCS/mltfx10.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx10.gif"></P><P><B>Figure 10</B> </P><P>Pitch Shifter block diagram. </P><PRE>klfo   oscil     1/kfqc, ipsh*kfqc, itab1                    &#13;&#13;atemp  delayr    1/ifqc                                      &#13;&#13;atap1  deltapi   klfo                                        &#13;&#13;       delayw    aosc                                        &#13;&#13;&#13;</PRE><P><B>Chorus</B> </P><P>Chorus is an effect which attempts to make one instrument sound like more than one instrument. The resulting sound is thicker than the original sound. Chorus can be implemented by adding the original signal to a frequency modulated delayed signal3. The signal is typically delayed between 20 and 30 msec. Gain is applied to control the amount of mix between the original signal and the delayed signal. Common waveforms used to modulate the signal are sine, triangle and logarithmic waves. </P><P><IMG SRC="DOCS/mltfx11.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx11.gif"></P><P><B>Figure 11</B> </P><P>Chorus block diagram. </P><PRE>kamp    linseg   0, .002, 1, p3-.004, 1, .002, 0             &#13;&#13;asig   zar       izin                                        &#13;&#13;aosc1  oscil     idepth, irate, iwave, iphase                &#13;&#13;aosc2  =         aosc1+ideloff                               &#13;&#13;atemp  delayr    idepth+ideloff                              &#13;&#13;adel1  deltapi   aosc2                                       &#13;&#13;       delayw    asig                                        &#13;&#13;aout   =         (adel1*imix+asig)/2*kamp                    &#13;&#13;       zaw       aout, izout                                 &#13;&#13;&#13;</PRE><P>A stereo chorus effect can be created by having two choruses one quarter cycle out of phase of each other and sending the output of each to a separate channel. Many choruses can be combined with different phases, waveforms and delay times to produce a very rich sound. </P><P>; Sta Dur Rate Depth Wave Mix Delay Phase InCh OutCh </P><P>i35 2 1.6 .5 2 1 1 25 0 2 3 </P><P>i35 2 1.6 .5 2 1 1 20 .25 2 4 </P><P><B>Flanger</B> </P><P>Flanging was originally produced by taking two tapes with the same music on them and playing at them at the same time. By pushing on the flanges of one of the tape reels the playback speed of one of the copies of the sound was modulated. This detuning of the signal results in areas of constructive and destructive interference as the different frequencies move in and out of phase with each other. This produces notches in the audio spectrum. As the frequency of the modulated signal is swept back and forth these notches move closer together and farther apart. This produces the characteristic &quot;jet airplane&quot; effect. In this implementation the original signal is added to a delayed signal. The delay time is modulated by a sine wave so that the pitch of the delayed signal is modulated. The combined signal is then fed back into the beginning of the delay path which makes a more pronounced flanging effect. Typical delay times are 10 msec. </P><P><IMG SRC="DOCS/mltfx12.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx12.gif"></P><P><B>Figure 12</B> </P><P>Flanger block diagram. </P><PRE>asig1  =         asig+ifdbk*adel1                            &#13;&#13;aosc1  oscil     idepth, irate, iwave, iphase                &#13;&#13;aosc2  =         aosc1+ideloff                               &#13;&#13;atemp  delayr    idepth+ideloff                              &#13;&#13;adel1  deltapi   aosc2                                       &#13;&#13;       delayw    asig1                                       &#13;&#13;aout   =         (imix*adel1+asig)/2                         &#13;&#13;&#13;</PRE><P>A stereo flanger can be implemented by running two flangers at one quarter cycle out of phase from each other and sending each to a separate channel as follows: </P><P><TT>; Sta Dur Rate Depth Wave Feedbk Mix Delay Phase InCh OutCh</TT> </P><P><TT>i30 4 1.6 .5 1 1 .8 1 1 0 2 3</TT> </P><P><TT>i30 4 1.6 .5 1 1 .8 1 1 .25 2 4</TT> </P><P><B>Miscellaneous Effects</B> </P><P>This section describes a digital delay, a panner, a tremolo effect and simple reverb effect. </P><P><B>Stereo Delay</B> </P><P>This section describes a stereo delay with cross feedback. The <B>delayr</B> and <B>delayw</B> opcodes provide a straight forward implementation of this. The right and left channels are delayed independently. The delayed signal from each channel may be mixed with the original signal either channel. </P><P><IMG SRC="DOCS/mltfx13.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx13.gif"></P><P><B>Figure 13</B> </P><P>Stereo Delay block diagram. </P><PRE>aoutl   init     0                                           &#13;&#13;aoutr   init     0                                           &#13;&#13;asigl   zar      izinl                                       &#13;&#13;asigr   zar      izinr                                       &#13;&#13;aoutl   delayr   itim1                                       &#13;&#13;        delayw   asigl+ifdbk1*aoutl+ixfdbk1*aoutr            &#13;&#13;aoutr   delayr   itim2                                       &#13;&#13;        delayw   asigr+ifdbk2*aoutr+ixfdbk2*aoutl            &#13;&#13;        zaw      aoutl, izoutl                               &#13;&#13;        zaw      aoutr, izoutr                               &#13;&#13;&#13;</PRE><P><B>Tremolo</B> </P><P>Tremolo is usually considered to be a periodic variation in the volume of a sound. This can be implemented by generating a low frequency oscillating sine wave between 0 and 1 in amplitude and simply multiplying the input signal by this. </P><P><IMG SRC="DOCS/mltfx14.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx14.gif"></P><P><B>Figure 14</B> </P><P>Tremolo block diagram. </P><PRE>kosc   oscil  iamp, ifqc, itab1                              &#13;&#13;aout   =      asig*(kosc+1)                                  &#13;&#13;&#13;</PRE><P>A square wave can be used to generate an amplitude gated sound. </P><P><B>Panner</B> </P><P>A panner can be implemented by multiplying one channel by a low frequency sine wave and multiplying the other channel by one minus the low frequency sine wave so that the channels are 180 degrees out of phase with each other. This way the signal is swept from one channel to the other by the oscillator. </P><P><IMG SRC="DOCS/mltfx15.gif" SGI_SRC="/tmp_mnt/home/bull6/hpm/reality/multifx/mltfx15.gif"></P><P><B>Figure 15</B> </P><P>Panner block diagram. </P><PRE>asig   zar     izin                                          &#13;&#13;kosc   oscil   iamp, ifqc, itab1                             &#13;&#13;kpanl  =       (kosc+1)/2                                    &#13;&#13;kpanr  =       1-kpanl                                       &#13;&#13;aoutl  =       asig*kpanl                                    &#13;&#13;aoutr  =       asig*kpanr                                    &#13;&#13;       zaw     aoutl, izoutl                                 &#13;&#13;       zaw     aoutr, izoutr                                 &#13;&#13;&#13;</PRE><P><B>Reverb</B> </P><P>All sound produces some type of reverberation as the sound waves are reflected and absorbed on surfaces in the listening environment. The type of reverb depends on the size, shape and material of the area in which the sound is produced. A concert hall can produce a very rich spacious reverb. Artificial reverb is often added to signals to make them sound as if they were generated in a specific type of area such as a concert hall. Reverberation can be simulated by using a combination of all pass filters, comb filters and delays. Csound provides a <B>reverb2</B> opcode for generating simple reverbs. This is used in the following instrument to create a very simple reverb. There are many excellent examples of reverb available in the Csound archives which can be modified to work with the system presented in this chapter. </P><PRE>asig  zar     izin                                           &#13;&#13;aout  reverb2 asig, irvtime, irvfqc                          &#13;&#13;      zaw     aout/5, izout                                  &#13;&#13;&#13;</PRE><P><B>Conclusion</B> </P><P>Hopefully this section has provided insight into the theory and implementation of many of the most popular sound effects and has provided inspiration for further audio experiments. Some further ideas to try would be to use different waveforms with the pitch based effects, try calling the chorus routine many times with different parameters and waveforms to produce a dense chorusing effect. Try setting up different types of distortion and then devise an instrument to oscillate between them. Add attack and decay envelopes to the dynamics effects. If you have a fast computer one of the first things you may wish to do is to implement real-time input and output for the effects. </P><P><B>References</B> </P><P>1. Lehman, S. <I>Effects Explained. </I>http://www.harmony-central.com/Effects/. </P><P>2. Hamm, R., O.<I> </I>&quot;Tubes Versus Transistors - Is There an Audible Difference?&quot;, <I>Journal of the Audio Engineering Society</I>, May 1973. </P><P>3. Cronin, Dennis &quot;Examining Audio DSP Programs,&quot; <I>Dr. Dobb's Journal</I>, July 1994. </P></BODY></HTML>