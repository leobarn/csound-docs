<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>Csound Terrain Mapping</title>		<meta name="Template" content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">	</head>	<body link="blue" vlink="purple" bgcolor="white">		<h1>26. Terrain Mapping Synthesis</h1>		<h2>&nbsp;Hans Mikelson</h2>		<p><b>Introduction</b></p>		<p>This chapter describes the synthesis method known as terrain mapping.<sup>1</sup> In terrain mapping synthesis a sound is generated by tracing a path or orbit along a surface. The height of the surface at the position of the orbit is used to determine the amplitude of the sound. The example orchestra and score, <a href="DOCS/terrain.orc">terrain.orc</a> and <a href="DOCS/terrain.sco">terrain.sco</a>, which accompany this chapter use only terrain mapping as sound sources. The most important step in terrain mapping synthesis is selecting a surface. The surface should be somewhat complex to produce an interesting sound. Singular points that shoot off to infinity should generally be avoided. Sharp edges will produce clicks which may not be desirable. Terrain mapping lends itself to a large number of modulation possibilities. One possibility is to modulate the parameters of the orbit or surface. Another possible modulation is to rotate the orbit or surface. The following sections describe the orbits, the surfaces and the modulations used in each instrument in the example orchestra and score.</p>		<p><b>Terrain Bass Instrument</b></p>		<p>The first instrument described is a terrain mapped bass. This instrument uses a circular path for its orbit. To make a more interesting sound the radius of the circle is modulated and offset from the origin. Separate pulsing circles are used to generate the left and right audio signals. The frequency at which the orbit is traced controls the fundamental frequency of the tone. A pitch envelope is applied to the frequency to add more character to the sound.</p>		<p><img src="DOCS/Image44.gif" width="156" height="154"></p>		<pre><b>Figure 1</b>The circle is modulated between two different radii.</pre>		<p>This is implemented by the following Csound code.</p>		<pre>asin1	oscil	krad1, kfqc, 1	; Y component of circle radius 1 acos1	oscil	krad1, kfqc, 1, .25	; X component of circle radius 1asin2	oscil	krad2, kfqc, 1, .5	; Y component of circle radius 2acos2	oscil	krad2, kfqc, 1, .75	; X component of circle radius 2			ax1	=	asin1+.35	; Offset the circle centers a bitay1	=	acos1-.80 	; so the waves are assymmetrical.ax2	=	asin2+.5	ay2	=	acos2-.20	</pre>		<p>The surface traced by this orbit uses the equation</p>		<p><img src="DOCS/Image45.gif" width="221" height="25">  (1)</p>		<p>A graph of this surface is presented in figure 2.</p>		<pre><img src="DOCS/Image36.gif" width="570" height="427"><b>Figure 2</b>The terrain bass surface plotted with spheres.</pre>		<p>The following Csound code is used to generate this surface. The audio variables <i>ax</i> and <i>ay</i> are used for the X and Y values of the surface. The values of X<sup>2</sup> and Y<sup>2</sup> are calculated in advance to make the algorithm more efficient. Separate values are generated for the left and right audio channels.</p>		<pre>axsq1	=	ax1*ax1	; Compute X^2 andaysq1	=	ay1*ay1	Y^2 in advanceaxsq2	=	ax2*ax2	; to save time.aysq2	=	ay2*ay2				; Compute the surface	az1	=	sqrt(axsq1*axsq1+aysq1*aysq1-axsq1-aysq1-axsq1*aysq1+1)	az2	=	sqrt(axsq2*axsq2+aysq2*aysq2-axsq2-aysq2-axsq2*aysq2+1)	</pre>		<p>Mathematical surfaces are not always well behaved when the values generated by the surface are translated into sound. Polynomials tend to shoot off to very large values and many surfaces are not centered around the zero axis. This can result in widely varying amplitudes and large DC offsets. The <b>balance</b> opcode can be used to reduce the amplitude variation. A high pass filter, <b>butterhp</b>, with a low cut-off frequency can be used to remove the DC component of the signal. This is implemented as</p>		<pre>abal1	balance	az1, aamp1	; Balance the signalabal2	balance	az2, aamp1	; Balance the signal			aout1	butterhp	abal1, 10	; DC blocking filteraout2	butterhp	abal2, 10	; DC blocking filter	outs	aout1*kamp, aout2*kamp	; Stereo output</pre>		<p>The completed terrain bass instrument has a mysterious fluttering character.</p>		<p><b>Terrain Lead Instrument 1</b></p>		<p>In this instrument a rose curve is used to generate the orbit.<sup>2</sup> Rose curves are generated by equation 2.</p>		<p><img src="DOCS/Image65.gif" width="97" height="22"><font face="Arial">  (2)</font></p>		<p>where <i>a</i> is the amplitude of the orbit and <i>n</i> determines the number of petals on the curve. If <i>n</i> is odd there will be <i>n</i> petals on the curve. If <i>n</i> is even there will be 2<i>n</i> petals on the curve. Figure 3 shows rose curves for several values of n.</p>		<p><img src="DOCS/Image37.gif" width="183" height="165"><img src="DOCS/Image38.gif" width="207" height="202"><img src="DOCS/Image39.gif" width="191" height="191"></p>		<pre><b>Figure 3</b>The rose patterns for n=3, n=3.5 and n=4.</pre>		<p>The equation for the rose curve is expressed in polar coordinates. To convert to rectangular coordinates use equation 3.</p>		<p><img src="DOCS/Image66.gif" width="176" height="21">  (3)</p>		<p>This is implemented in Csound as</p>		<pre>arose	oscil	kmod1, ipetal*kfqc, 1	; Rose Curveax	oscil	arose, kfqc, 1	; Convert from polar toay	oscil	arose, kfqc, 1, .25	; rectangular coordinates</pre>		<p>In the Csound code the variable <i>ipetal</i> is used instead of <i>n</i>. The size of the rose is modulated with <i>kmodl</i>.</p>		<p>The surface used for this instrument is the polynomial<sup>3</sup></p>		<p><img src="DOCS/Image67.gif" width="141" height="44">  (4)</p>		<p>which is expressed in Csound as</p>		<pre>az	=	ax-ax*ax*ax/12-ay*ay/4+.5	; Compute the surface</pre>		<p>A graph of this surface is presented in figure 4.</p>		<pre><img src="DOCS/Image40.gif" width="570" height="427"><b>Figure 4</b>Terrain surface for the first terrain lead instrument.</pre>		<p>Delayed vibrato is applied to the tone to make the sound more interesting. The tone produced by this instrument is rather mellow which pulses as the amplitude of the rose curve is modulated. This produces a &quot;wah&quot; sound similar to a that of a filter opening and closing.</p>		<p><b>Terrain Hollow Lead Instrument</b></p>		<p>This instrument uses a rose curve to generate the orbit as described in the previous section. The equation of the surface is</p>		<p><img src="DOCS/Image49.gif" width="78" height="41">  (5)</p>		<p>and an of this surface image is presented as figure 5</p>		<pre><img src="DOCS/Image41.gif" width="570" height="427"><b>Figure 5</b>Terrain surface for the terrain hollow lead instrument.</pre>		<p>The Csound code to implement this follows:</p>		<pre>arose	oscil	kmod1+1, ipetal*ifqc, 1	; Rose Curveax	oscil	arose, ifqc, 1	; Convert from polar toay	oscil	arose, ifqc, 1, .25	; rectangular coordinatesaz	=	-5*ax/(ax*ax+ay*ay+1)	; Compute the surface for oscillator 1</pre>		<p>Three oscillators are generated which are detuned and added together to produce a rich, chorused hollow tone.</p>		<p><b>Deep Space Growl Instrument</b></p>		<p>This instrument is based on a four dimensional surface. The orbit follows a three dimensional spiral along the surface of a torus. The orbit is shown in figure 6.</p>		<pre><img src="DOCS/Image42.gif" width="471" height="350"><b>Figure 6</b>The dark line shows the orbit spiralling along the &quot;torus&quot; surface.  Notice that since the minor radius was chosen larger than the major radius the torus tunrs in on itself.  The orbit produced is fairly complex.</pre>		<p>The Csound code for the torus is</p>		<pre>krminor	oscil	5, .2, 1	; Modulate the minor radiuskrminor	=	krminor+6	; Make it positivekrmajor	=	krminor+1	; Major radius is 1 bigger than minor			asin1	oscil	krminor, ifqc, 1	; Minor circle Y coordinateacos1	oscil	krminor, ifqc, 1, .25	; Minor circle X coordinateasin2	oscil	krmajor, ifqc/4, 1	; Major circle Y coordinateacos2	oscil	krmajor, ifqc/4, 1, .25	; Major circle X coordinate			ax	=	asin1+acos2	; This orbit is a spiral onay	=	acos1	; the surface of a torus whoseaz	=	asin2	; radius is being modulated.</pre>		<p>Displaying the four dimensional surface presents some difficulties therefore the three dimensional analog of the surface is displayed. The surface produces a deep, growling, harmonically rich tone. The equation for this surface is</p>		<p><img src="DOCS/Image50.gif" width="164" height="24">  (6)</p>		<p>A graph of the surface is presented in figure 7.</p>		<p><img src="DOCS/Image43.gif" width="570" height="427"></p>		<pre><b>Figure 7</b>The three dimensional analogue of the four dimensional terrain surface. </pre>		<p>The Csound code for the four dimensional surface is</p>		<pre>aw1	=	sin(sqrt(ax*ax+ay*ay+az*az))	; Compute the surface a bumpy 4D surfaceaw	=	aw1*aw1-.5	; Remove some DC offset</pre>		<p>This instrument makes use of planar rotations to modulate the sound. Rotations can be applied to any multi-dimensional oscillator such as a terrain oscillator. The equations for rotating a point in space are well known in computer graphics. They are best expressed as a matrix which is used to multiply each point. To simplify things the two dimensional case will be described first. For the two dimensional case</p>		<p><img src="DOCS/Image51.gif" width="185" height="49"><font size="1">  </font>(7)</p>		<p>or</p>		<p><img src="DOCS/Image52.gif" width="185" height="48">  (8)</p>		<p>There are three planar rotations for the three dimensional case given by the following matrices:</p>		<p><img src="DOCS/Image53.gif" width="212" height="73">  (9.a)</p>		<p><img src="DOCS/Image54.gif" width="212" height="73">  (9.b)</p>		<p><img src="DOCS/Image55.gif" width="212" height="73">  (9.c)</p>		<p>Since a four dimensional surface is used in this case a four dimensional rotation is applied. There are six planar rotations available in four space:</p>		<p><img src="DOCS/Image56.gif" width="233" height="96">&nbsp;<img src="DOCS/Image57.gif" width="234" height="96">??(10.a &amp; 10.b)</p>		<p><img src="DOCS/Image58.gif" width="234" height="96">&nbsp;<img src="DOCS/Image59.gif" width="237" height="96">??(10.c &amp; 10.d)</p>		<p><img src="DOCS/Image60.gif" width="237" height="96">&nbsp;<img src="DOCS/Image61.gif" width="236" height="96">??(10.e &amp; 10.f)</p>		<p>The Csound code to implement rotations of four dimensional equations follows:</p>		<pre>kcost  oscil 1, ifqc,   1, .25+iphase        ; Cosineksint  oscil 1, ifqc,   1, iphase            ; Sineax      zar  inx                             ; Read in audio channels X, Y, Z and Way      zar  inyaz      zar  inzaw      zar  inw; Rotation in X-Y plane  if (iplane!=1) goto next1    axr = ax*kcost + ay*ksint    ayr =-ax*ksint + ay*kcost    azr = az    awr = aw    goto nextend; Rotation in X-Z planenext1:  if (iplane!=2) goto next2    axr = ax*kcost + az*ksint    ayr = ay    azr =-ax*ksint + az*kcost    awr = aw    goto nextend; Rotation in Y-Z planenext2:  if (iplane!=3) goto next3    axr = ax    ayr = ay*kcost + az*ksint    azr =-ay*ksint + az*kcost    awr = aw    goto nextend; Rotation in X-W planenext3:  if (iplane!=4) goto next4    axr = ax*kcost + aw*ksint    ayr = ay    azr = az    awr =-ax*ksint + aw*kcost    goto nextend; Rotation in Y-W planenext4:  if (iplane!=5) goto next5    axr = ax    ayr = ay*kcost + aw*ksint    azr = az    awr =-ay*ksint + aw*kcost    goto nextend; Rotation in Z-W planenext5:  if (iplane!=6) goto nextend    axr = ax    ayr = ay    azr = az*kcost + aw*ksint    awr =-az*ksint + aw*kcostnextend:        zaw axr, ioutx                          ; Output audio X, Y, Z and W        zaw ayr, iouty        zaw azr, ioutz        zaw awr, ioutwendin</pre>		<p>The result is an evolving harmonically rich tone with a complex stereo image.</p>		<p><b>Pulsar Instrument</b></p>		<p>This instrument uses a lima&ccedil;on curve to for the orbit as expressed by the polar equation</p>		<p><img src="DOCS/Image62.gif" width="105" height="21">  (11)</p>		<p>An image of this curve is presented in figure 8.</p>		<pre><img src="DOCS/Image34.gif" width="195" height="169"><b>Figure 8</b>The lima&ccedil;on orbit used in this instrument.</pre>		<p><font size="2">The Csound code used to implement this orbit follows</font></p>		<pre>ka	=	.01+kmod	; Cardioid Akb	=	.1+kmod*.2	; Cardioid B			acardi	oscil	kb, ifqc, 1	; Cardioid Curveax	oscil	ka+acardi, ifqc, 1	; Convert from polar toay	oscil	ka+acardi, ifqc, 1, .25	; rectangular coordinates</pre>		<p><font size="2">The surface used in this equation is presented in equation 12.</font></p>		<p><img src="DOCS/Image63.gif" width="289" height="53"><font size="2">(12)</font></p>		<p><img src="DOCS/Image35.gif" width="570" height="427"></p>		<pre><b>Figure 9</b>The pulsar terrain surface. As X goes to zero the frequency gets very large due to the 1/(X^2+.01) term.</pre>		<p>The Csound code to implement this surface follows:</p>		<pre>az	=	sqrt((1-ax*ax)*((1-ay)+ay*cos(1/(ax*ax+.01))))-1	; Compute the surface</pre>		<p>This surface is derived from a surface including a term of the form<img src="DOCS/Image64.gif" width="62" height="24">. This causes the frequency to approach infinity as x approaches zero. To avoid computation errors this was modified to eliminate the unbounded term. The sound produced by this surface is a pulsing, noise like sound.</p>		<p><b>Conclusion</b></p>		<p>Terrain mapping synthesis provides a very rich playground for synthesists. Sounds generated using this method range from traditional waveforms and instruments to the most bizarre noises. Terrain mapping allows for a wide variety of modulations which can be used to add character and complexity to the tone. The tones produced can be tuned or untuned. Some disadvantages of this method are wide variations in volume and inherent DC offsets.</p>		<p>Interesting mathematical surfaces can be found in mathematics and computer graphics books. The rendered three dimensional images presented in this chapter were created with the <a href="http://www.povray.org/"><font size="2">Persistance of Vision</font></a> ray tracer. A <a href="http://www.perl.org/"><font size="2">Perl</font></a> script was used to generate the POV code. This script is presented as <a href="DOCS/povplot.pl"><font size="2">povplot.pl</font></a>. Some of the diagrams of the orbits presented in this chapter were created with Logo. The code used to create them is included as <a href="DOCS/rose.lgo"><font size="2">rose.lgo</font></a>.</p>		<p><b>References</b></p>		<ol>			<li>Roads, C. <i>The Computer Music Tutorial.</i> Cambridge, Mass.: The MIT Press. 1996			<li>Anton, Howard. <i>Calculus</i>, John Wiley and Sons (1980). pp. 716-725.			<li><a href="http://sprott.physics.wisc.edu/pickover/home.htm"><font size="2">Pickover, Clfford</font></a>, <i>Computers and the Imagination</i>. St. Martin's Press, Inc. New York, NY, 1991. pp. 175-179.		</ol>	</body></html>