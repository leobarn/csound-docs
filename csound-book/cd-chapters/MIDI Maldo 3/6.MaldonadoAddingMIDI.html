<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>&quot;MIDI Instrument Design for Real-time Performance&quot;</title>	</head>	<body bgcolor="white">		<h1><b>6.</b>Using Real-time Csound MIDI with Windows</h1>		<h2>Gabriel Maldonado</h2>		<h3><b>Implementing MIDI opcodes</b></h3>		<p>Implementing MIDI opcodes is not very different from implementing the standard ones. The only thing to take into account is the hardware MIDI interface and the Operating System routines that access it in a particular platform. I had to do with MS Windows 95, an O.S. that does not allow to drive hardware directly, but by means of a lot of standard, device-independent API (Application Programming Interface) functions. The APIs provided with Win95 are low-level routines, so quite difficult to program. For this reason I implemented an higher level interface to access the Win95 APIs. I will not deal with these routines in this text.</p>		<p>Below I will describe some MIDI opcodes I added to Csound. In this description I will always refer to my higher level MIDI interface routines (not to their implementation details), because they can be easily re-programmed in other O.S.</p>		<p>IMPORTANT! For understanding the sources presented in this text, some concepts must be clear, i.e. the difference among:</p>		<ul>			<li>Csound instr code in the orchestra,			<li>current instrument instance and			<li>current opcode instance		</ul>		<p>A Csound instrument can have several copies of itself running in parallel and at the same time during the performance. Each copy is called <u>instrument instance</u>.<br>		Within an instrument there may be several calls to the same opcode with different argument values. Each copy is named <u>opcode instance</u> .<br>		So Csound can run at the same time N instance of the same instrument containing M istances of a certain opcode; the total number of opcode instances will be N * M.</p>		<p>&nbsp;</p>		<div align="left">			<h3><b>1. MIDI IN opcodes sources</b></h3>		</div>		<p>If anybody is interested to implement MIDI IN in its own O.S., he should know at least one of the following things:</p>		<ul>			<li>hardware-port-access implementation of the midi interface;			<li>software API implementation of MIDI IN in particular O.S.		</ul>		<p>The first things that should be implemented are hardware MIDI port initialization and closing routines. These can be implemented by calling a custom initialization function within <i><b>MidiOpen( )</b></i> function and a closing function within <i><b>MidiClose( )</b></i> function (both located in file <b>midirecv.c</b>).</p>		<p>In Csound most MIDI IN accessing is done by function <i><b>sensMidi( )</b></i> (located in the file <b>midirecv.c</b> too) .</p>		<p>When I analized MIDI IN engine sources in Csound, I referred to the function:</p>		<dir>			<dir>				<p>int readmidi(char *mbuf, int size);</p>			</dir>		</dir>		<p>(called within &quot;BLASTER&quot; conditional compilation block of caller function <i><b>sensMidi( ) </b></i>). Function<i><b> readmidi( )</b></i> simply fills the buffer <i><b>mbuf</b></i> with the bytes (two or three) of current midi message, if a new message is pending. If a message is pending, this function reads the message and returns the number of bytes actually read, else it returns 0. The second thing to do is to override this function in accordance with your MIDI interface and/or O.S. <i><b>,</b></i> and to enable that function in the conditional compilation.</p>		<p>Doing these things is not very difficult if hardware interface or MIDI API functionalities are known. Unfortunately Windows MIDI APIs are not very simple to program, so I created a C++ class for doing these tasks.</p>		<p>My MIDI IN opcodes do not access directly these routines, but take it for granted that Csound MIDI IN engine is already implemented in your platform (i.e. standard B.Vercoe MIDI IN opcodes are already functional) if you actually want to use them.</p>		<p>In this text source lines are numbered to make easier treatment reference. Obviously you must remove this numbering when you compile them, because C language does not allow line numbers.</p>		<h3><b>1. imidic7 and midic7 sources</b></h3>		<p><i><b>imidic7</b></i> and <i><b>midic7</b></i> sources are located in files <a href="Midiops2.c"><b>midiops2.c</b></a> and <a href="Midiops2.h"><b>midiops2.h</b></a>.</p>		<p>Below there is a description of both opcodes.</p>		<p>In header file <a href="Midiops2.h"><b>midiops2.h</b></a> there is <b>MIDICTL2</b> data type declaration:</p>		<p>1 typedef struct { 2 OPDS h;<br>		3 float *r, *ictlno, *imin, *imax, *ifn;<br>		4 BOOL flag;<br>		5 FUNC *ftp;<br>		6 long ctlno;<br>		7 } MIDICTL2;<br>		</p>		<p>source <b>1</b><br>		</p>		<p>while in file <a href="Midiops2.c"><b>midiops2.c</b></a> there is <i><b>imidic7</b></i> function:<br>		1 void imidic7(MIDICTL2 *p)<br>		2 {<br>		3 float value;<br>		4 register FUNC *ftp;<br>		5 register long ctlno;<br>		6 if ((ctlno = *p-&gt;ictlno) &lt; 0 || ctlno &gt; 127)<br>		7 initerror(&quot;illegal controller number&quot;);<br>		8 else {<br>		9 value = curip-&gt;m_chnbp-&gt;ctl_val[ctlno] / f7bit;<br>		10 if (*p-&gt;ifn &gt; 0) {<br>		11 if ((ftp = ftfind(p-&gt;ifn)) == NULL) return;<br>		12 /* if valid ftable,use value as index */<br>		13 value = *(ftp-&gt;ftable +<br>		14 (long)(value * ftp-&gt;flen));<br>		15 /* no interpolation */<br>		16 }<br>		17 *p-&gt;r = value * (*p-&gt;imax - *p-&gt;imin)<br>		18 + *p-&gt;imin; /* scales the output*/<br>		19 }<br>		20 }</p>		<p>source <b>2</b></p>		<p>In Csound you write a new opcode by writing one or more C-functions, each with only one argument (see line 1 of source 2). This argument is a pointer to a custom data type. This custom data type must be declared in a separate header file (source 1) and consists of a structure containing :</p>		<ul>			<li>an <b>OPDS</b> strucure (line 2)			<li>float pointer(s) to output(s) (if output is present in that opcode). In our case <b>r</b> pointer is used (line 3).			<li>float pointer(s) to each opcode argument. In our case <b>*ictlno, *imin, *imax, *ifn</b> are used (line 3).			<li>Internal storage variables which lifetime is the duration of opcode instance. In our case the variables of sevaral types declared in lines 4-5-6 of source 1.		</ul>		<p>Let&#146;s go to main source of <i><b>imidic7</b></i>.</p>		<p><i><b>imidic7</b></i> is an init-time opcode, so the main function is called only once in instrument instance life.</p>		<p>Csound syntax of this opcode is:</p>		<p><i><b>idest imidic7 ictlno, imin, imax, [ifn]</b></i></p>		<p>where <i><b>ictlno</b></i> is midi controller number; <i><b>imin</b></i> and <i><b>imax</b></i> are maximum and minimum floating-point value to be scaled from 0-127 MIDI values or from a table array of values if <i><b>ifn</b></i> argument (optional) is present; <i><b>ifn</b></i> is the number of the table.</p>		<p>See source 2. Note that:</p>		<ul>			<li>In lines 3 to 5 there are three local variables declarations used to speed up pointer operations: <b>value</b> is a variable used for temporary storage of result; <b>ftp</b> is used as pointer to current table address and <b>ctlno</b> is used as controller number.			<li>In lines 6 -7 there is a conditional exit point, activated when argument <i><b>ictlno</b></i> is not in the 0-127 range.			<li>Line 9 stores in <b>value</b> the current normalized (from 0.0 to 1.0) value of the MIDI controller <i><b>ictlno</b></i>.			<li><b>curip</b> is global pointer to a <b>INSDS</b> type, i.e. a structure containing a lot of members whose purpose is to register Csound instruments status and to make it avalaible to other parts of code at a certain moment. <b>curip</b> is declared and initialized externally and points to current intrument instance. In line 9 <b>curip</b> is used to access the current value of MIDI controller <i><b>ictlno.</b></i>			<li>If <i><b>ifn</b></i> argument is present (line 10) then current <i><b>imidic7 </b></i>uses <b>value</b> as index of table number <i><b>ifn</b></i>. If <i><b>ifn</b></i> is present, but is not a valid table number (line 11) current <i><b>imidic7 </b></i>instance is forced to terminate, else uses <b>value</b> as index of table <i><b>ifn</b></i> (lines 13-14) and the result is stored in <b>value</b> itself. In <i><b>imidic7</b></i> and <i><b>midic7</b></i> opcodes no interpolation is used, whereas in<i><b> (i)midic14</b></i> and in <i><b>(i) midic21</b></i> it is.			<li><b>ftfind( p-&gt;ifn)</b> function returns <i><b>ifn</b></i> table address (line 11).			<li><b>ftp</b> pointer is used as table address temporary storage.			<li>In lines 17-18 output is scaled according to <i><b>imin</b></i> and <i><b>imax</b></i> values and is stored in its final location.		</ul>		<p>To complete the implementation of any new opcode you must always add some custom code to the file <b>entry.c</b>. The following text is referred to <i><b>imidic7</b></i> opcode, but you can easily adapt it according to any opcode source.</p>		<p>At the beginning of file <a href="Entry.c"><b>entry.c</b></a><b> </b>you must add:</p>		<dir>			<dir>				<p>#include &quot;midiops2.h&quot;</p>			</dir>		</dir>		<p>this will include the header file containing the custom data types declarations.</p>		<p>At the function declaration point of <a href="Entry.c"><b>entry.c</b></a><b> </b>you must add:</p>		<dir>			<dir>				<p>void imidic7(void*);</p>			</dir>		</dir>		<p>this gives the correct functions prototypes of new opcodes.</p>		<p>Inside the OENTRY <b>opcodlst[ ]</b> structure array declaration in file <a href="Entry.c"><b>entry.c</b></a><b> </b>you must add:</p>		<dir>			<p>{ &quot;imidic7&quot;,S(MIDICTL2), 1, &quot;i&quot;, &quot;iiio&quot;,<br>			imidic7, NULL, NULL },</p>		</dir>		<p>This is a composite element initialization of <b>opcodlst[ ] </b>array. The sub-elements are (from left to right):</p>		<ul>			<li>a string constant containing the opcode name;			<li>the data structure size of that opcode ;			<li>a number which declares what kind of thread are used in current opcode (a bitwise OR of : 1=i-rate threads; 2=k-rate threads; 4=a-rate threads);			<li>a string constant declaring the rate of output(s) (i = i-rate; k = k-rate; a= a-rate; x = k or a-rate; o = optional i-rate argument);			<li>a string constant declaring the rate of input(s);			<li>address of i-rate function or NULL if it does not exist;			<li>address of k-rate function or NULL if it does not exist;			<li>address of a-rate function or NULL if it does not exist;		</ul>		<p>that&#146;s all for <i><b>imidic7</b></i>.</p>		<p>-------------------------------------------------------------------------------</p>		<p>Here are <i><b>midic7</b></i> sources:</p>		<p>1 void midic7set(MIDICTL2 *p) 2 {<br>		3 register long ctlno;<br>		4 if ((ctlno = *p-&gt;ictlno) &lt; 0 || ctlno &gt; 127)<br>		5 initerror(&quot;illegal controller number&quot;);<br>		6 else p-&gt;ctlno = ctlno;<br>		7 if (*p-&gt;ifn &gt; 0) {<br>		8 if (((p-&gt;ftp = ftfind(p-&gt;ifn)) == NULL))<br>		9 p-&gt;flag = FALSE; /* invalid ftable */<br>		10 else p-&gt;flag= TRUE;<br>		11 }<br>		12 else p-&gt;flag= FALSE;<br>		13 }<br>		</p>		<p>source <b>3</b><br>		</p>		<p>1 void midic7(MIDICTL2 *p)<br>		2 {<br>		3 float value;<br>		4 register INSDS *curip = p-&gt;h.insdshead;<br>		5<br>		6 value = curip-&gt;m_chnbp-&gt;ctl_val[p-&gt;ctlno] / f7bit;<br>		7 if (p-&gt;flag){ /* if valid ftable,use value 8as index*/<br>		9 value = *(p-&gt;ftp-&gt;ftable<br>		10 + (long)(value * p-&gt;ftp-&gt;flen));<br>		11 /* no interpolation */<br>		12 }<br>		13 *p-&gt;r = value * (*p-&gt;imax - *p-&gt;imin) + *p-&gt;imin;<br>		14 /* scales the output */<br>		15 }</p>		<p>source <b>4</b></p>		<p><i><b>imidic7 </b></i>and <i><b>midic7 </b></i>opcodes are almost identical in functionality: the only difference is that<i><b> imidic7</b></i> works at i-rate while <i><b>midic7 </b></i>works at k-rate. Both use <b>MIDICTL2</b> structure as argument data type.</p>		<p><i><b>midic7</b></i> is a k-rate opcode and consists of two C-language functions: <b>midic7set() </b>and <b>midic7( )</b>. <b>midic7set( )</b> function is called only once during the initialization pass, whereas <b>midic7( )</b> function is called at each k pass. Most k and a-rate opcodes need an initialization function to initialize some data, which are then used in k-passes.</p>		<p>So <b>midic7set( )</b> (see source 3) is used for:</p>		<ul>			<li>checking if <i><b>ictlno </b></i>is out of range (0-127) (see lines 4-5)			<li>initializing <b>ftp</b> member of structure MIDICTL2 with current table address and checking if it points to a valid table (see lines 7-8)		</ul>		<p>initializing <b>flag </b>member of structure MIDICTL2 (a flag which informs <b>midic7( )</b> function whether table indexing is used or not; see lines 9-12)</p>		<p>all these tasks need to be executed only once per opcode instance.</p>		<p><b>midic7( )</b> function (see source 4) does all remaining operations at k-rate i.e. :</p>		<ul>			<li>stores in <b>value</b> the current normalized (from 0.0 to 1.0) value of the MIDI controller (line 6). Note that <b>curip</b> is now local and is initialized with the pointer of the previously defined instance (the member <b>h.inshead</b> of <b>MIDICTL2</b> structure) of current instrument;			<li>stores in <b>value</b> current table value if current call uses table indexing<br>			(lines 7-9)			<li>scales output according to <i><b>imin</b></i> and <i><b>imax</b></i> and stores it in its final location (line 13) .		</ul>		<p>For completing <i><b>midic7</b></i> opcode implementation you must take into account file<b> entry.c.</b></p>		<p>At the beginning of file <b>entry.c </b>you must add the include header file directive as usual (if it has not been done before):</p>		<dir>			<dir>				<p>#include &quot;midiops2.h&quot;</p>			</dir>		</dir>		<p>this will include the header file containing the custom data types declarations.</p>		<p>At the function declaration point of <b>entry.c </b>you must add:</p>		<dir>			<dir>				<p>void midic7set(void*), midic7(void*);</p>			</dir>		</dir>		<p>this gives the correct functions prototypes of new opcodes.</p>		<p>Inside the OENTRY <b>opcodlst[ ]</b> structure array declaration in file <a href="Entry.c"><b>entry.c</b></a><b> </b>you must add:</p>		<dir>			<dir>				<p>{ &quot;midic7&quot;,S(MIDICTL2), 3, &quot;k&quot;, &quot;ikko&quot;,<br>				midic7set, midic7 ,NULL },</p>			</dir>		</dir>		<p>that&#146;s all.</p>		<h3><b>2. imidic14 and midic14 sources</b></h3>		<p><i><b>imidic14</b></i> and <i><b>midic14</b></i> sources are located in files <b>midiops2.c</b> and <b>midiops2.h</b>.</p>		<p>Below there is a description of <i><b>imidic14</b></i> opcode.</p>		<p>In the header file <a href="Midiops2.h"><b>midiops2.h</b></a> there is <b>MIDICTL3</b> data type declaration:</p>		<p>1 typedef struct { 2 OPDS h;<br>		3 float *r, *ictlno1, *ictlno2, *imin, *imax, *ifn;<br>		4 BOOL flag;<br>		5 FUNC *ftp;<br>		6 long ctlno1, ctlno2;<br>		7 } MIDICTL3;<br>		</p>		<p>source <b>5</b><br>		</p>		<p>while in file <a href="Midiops2.c"><b>midiops2.c</b></a> there is <i><b>imidic14</b></i> function:<br>		1 void imidic14(MIDICTL3 *p)<br>		2 {<br>		3 float value;<br>		4 register FUNC *ftp;<br>		5 register long ctlno1;<br>		6 register long ctlno2;<br>		7<br>		8 if ((ctlno1 = *p-&gt;ictlno1) &lt; 0 || ctlno1 &gt; 127 ||<br>		9 (ctlno2 = *p-&gt;ictlno2) &lt; 0 || ctlno2 &gt; 127 )<br>		10 initerror(&quot;illegal controller number&quot;);<br>		11 else {<br>		12 value = (curip-&gt;m_chnbp-&gt;ctl_val[ctlno1] * 128<br>		13 + curip-&gt;m_chnbp-&gt;ctl_val[ctlno2])<br>		14 / f14bit;<br>		15 if (*p-&gt;ifn &gt; 0) {<br>		16 /* linear interpolation routine */<br>		17 register float phase;<br>		18 register float *base_address;<br>		19 register float *base;<br>		20 register float *top;<br>		21 register float diff;<br>		22 register long length;<br>		23<br>		24 /* if valid ftable,use value as index */<br>		25 if ((ftp = ftfind(p-&gt;ifn)) == NULL) return;<br>		26 phase = value * (length = ftp-&gt;flen);<br>		27 diff = phase - (long) phase;<br>		28 base = (base_address = ftp-&gt;ftable)<br>		29 + (long)(phase);<br>		30 top = base + 1 ;<br>		31 top = top - base_address &gt; length ?<br>		32 base_address : top;<br>		33 value = *base + (*top - *base) * diff;<br>		34 }<br>		35 *p-&gt;r = value * (*p-&gt;imax - *p-&gt;imin) + *p-&gt;imin;<br>		36 }<br>		37 }</p>		<p>source <b>6</b></p>		<p>Csound syntax of <i><b>imidic14 </b></i>opcode is:</p>		<p><i><b>idest imidic14 ictlno1, ictlno2, imin, imax, [ifn]</b></i></p>		<p>where <i><b>ictlno1</b></i> is the number of MIDI controller which sends most significant byte of the value; <i><b>ictlno2</b></i> is the number of MIDI controller which sends less significant byte of the value; <i><b>imin</b></i> and <i><b>imax</b></i> are maximum and minimum floating-point numbers to be scaled from 0 to 16383 (128 * 128 - 1, integer numbers) or from a table array of values if <i><b>ifn</b></i> argument (optional) is present; <i><b>ifn</b></i> is the number of the table.</p>		<p>There are three main differences beetween <i><b>(i)midic7</b></i> and <i><b>(i)midic14</b></i> :</p>		<ul>			<li>more resolution (from 0 to 16383 raw values in input)			<li>one more argument (<i><b>ictlno2</b></i> containing LSB control number)			<li>linear interpolation when table indexing is used		</ul>		<p>So, analyzing source 6 we can note that:</p>		<ul>			<li>in lines 8 -10 <u>two</u> controller numbers are now tested;			<li>in lines 12-14 MSB and LSB values are joined, normalized (from 0.0 to 1.0) and stored in <b>value</b> variable;			<li>in lines 15-34 there is the linear interpolation routine. There are a lot of register variables declarations whose purpose is to accelerate pointer operations. Integer phase and its fractional part are calculated (lines 26-27), as well as the address of current table indexing (line 28). A wraparound feature is also implemented to prevent index to exceed table length (lines 31-32) . Then interpolation is calculated and stored in <b>value</b> variable (line 33).			<li>Finally output is scaled according to <i><b>imin</b></i> and <i><b>imax</b></i> values and stored in its final location (line 35).		</ul>		<p>For completing imidic14 opcode implementation you must take into account file<b> entry.c.</b></p>		<p>At the beginning of file <b>entry.c </b>you must add the include header file directive as usual (if it has not been done before):</p>		<dir>			<dir>				<p>#include &quot;midiops2.h&quot;</p>			</dir>		</dir>		<p>this will include the header file containing the custom data types declarations.</p>		<p>At the function declaration point of <b>entry.c </b>you must add:</p>		<dir>			<dir>				<p>void imidic14(void*);</p>			</dir>		</dir>		<p>this gives the correct functions prototypes of new opcodes.</p>		<p>Inside the OENTRY <b>opcodlst[ ]</b> structure array declaration in file <b>entry.c </b>you must add:</p>		<p>{ &quot;imidic14&quot;,S(MIDICTL3),1, &quot;i&quot;, &quot;iiiio&quot;,<br>		imidic14, NULL ,NULL },</p>		<p>-------------------------</p>		<p>Now let&#146;s go to <i><b>imidic14</b></i> opcode sources analisis.</p>		<p>Here follows the initialization function:</p>		<p>1 void midic14set(MIDICTL3 *p) 2 {<br>		3 register long ctlno1;<br>		4 register long ctlno2;<br>		5 if ((ctlno1 = *p-&gt;ictlno1) &lt; 0 || ctlno1 &gt; 127 ||<br>		6 (ctlno2 = *p-&gt;ictlno2) &lt; 0 || ctlno2 &gt; 127 )<br>		7 initerror(&quot;illegal controller number&quot;);<br>		8 else {<br>		9 p-&gt;ctlno1 = ctlno1;<br>		10 p-&gt;ctlno2 = ctlno2;<br>		11 }<br>		12 if (*p-&gt;ifn &gt; 0) {<br>		13 if (((p-&gt;ftp = ftfind(p-&gt;ifn)) == NULL))<br>		14 p-&gt;flag = FALSE; /* invalid ftable */<br>		15 else p-&gt;flag= TRUE;<br>		16 }<br>		17 else p-&gt;flag= FALSE;<br>		18 }<br>		</p>		<p>source <b>7</b><br>		&#133;and here is the k-rate function:<br>		</p>		<p>1 void midic14(MIDICTL3 *p)<br>		2 {<br>		3 float value;<br>		4 register INSDS *curip = p-&gt;h.insdshead;<br>		5<br>		6 value = (curip-&gt;m_chnbp-&gt;ctl_val[p-&gt;ctlno1] *128<br>		7 + curip-&gt;m_chnbp-&gt;ctl_val[p-&gt;ctlno2] )<br>		8 / f14bit;<br>		9 if (p-&gt;flag) { /*if valid ftable,use value as index*/<br>		10<br>		11 /* linear interpolation routine */<br>		12 register float phase;<br>		13 register float *base_address;<br>		14 register float *base;<br>		15 register float *top;<br>		16 register float diff;<br>		17 register long length;<br>		18<br>		19 phase = value * (length = p-&gt;ftp-&gt;flen);<br>		20 diff = phase - (long) phase;<br>		21 base = (base_address = p-&gt;ftp-&gt;ftable)<br>		22 + (long)(phase);<br>		23 top = base + 1 ;<br>		24 top = (top - base_address &gt; length) ?<br>		25 base_address : top;<br>		26 value = *base + (*top - *base) * diff;<br>		27 }<br>		28 *p-&gt;r = value * (*p-&gt;imax - *p-&gt;imin) + *p-&gt;imin;<br>		29 }</p>		<p>source <b>8</b></p>		<p><b>midic14set( )</b> function checks if <i><b>ictlno1</b></i> and <i><b>ictlno2</b></i> are within the correct range (lines 5-7 of source 7) and if a valid <i><b>ifn</b></i> value is present (lines 12-17).</p>		<p><b>midic14( )</b> function does the following things:</p>		<ul>			<li>joins MSB and LSB values, normalizes the result (from 0.0 to 1.0) and stores it in <b>value</b> variable (lines 6-8 of source 8);			<li>if <i><b>ifn</b></i> argument is present, it does lineary interpolated table indexing<br>			(lines 9-27) ;			<li>scales output according to <i><b>imin</b></i> and <i><b>imax</b></i> values and stores in it in the final location (line 28).		</ul>		<p>For completing midic14 opcode implementation you must take into account file<b> entry.c.</b></p>		<p>At the beginning of file <b>entry.c </b>you must add the include header file directive as usual (if it has not been done before):</p>		<dir>			<dir>				<p>#include &quot;midiops2.h&quot;</p>			</dir>		</dir>		<p>this will include the header file containing the custom data types declarations.</p>		<p>At the function declaration point of <b>entry.c </b>you must add:</p>		<p>void midic14(void*);</p>		<p>this gives the correct functions prototypes of new opcodes.</p>		<p>Inside the OENTRY <b>opcodlst[ ]</b> structure array declaration in file <b>entry.c </b>you must add:</p>		<p>{ &quot;midic14&quot;,S(MIDICTL3), 3, &quot;k&quot;, &quot;iikko&quot;,</p>		<p>midic14set, midic14 ,NULL },</p>		<p>-------------------</p>		<p><i><b>imidic21</b></i> and <i><b>midic21</b></i> opcodes are almost identical to imidic14 and midic14, the few differences are:</p>		<ul>			<li>a greater resolution (21 bit);			<li>an additional argument (<i><b>ictlno3</b></i>)		</ul>		<p>so their sources are not included in this text. Refer to files<b> midiops2.h </b>and <b>midiops2.c .</b></p>		<h3>		<h3><b>2. MIDI OUT opcodes sources</b></h3>		</h3>		<p>For implementing these opcodes in your platform, you must override the following functions, since the Csound MIDI OUT opcodes sources directly call them:</p>		<p>void note_on(int chan, int num, int vel);</p>		<p>void note_off(int chan, int num, int vel);</p>		<p>void control_change(int chan, int num, int value);</p>		<p>void after_touch(int chan, int value);</p>		<p>void program_change(int chan, int num);</p>		<p>void pitch_bend(int chan, int lsb, int msb);</p>		<p>void poly_after_touch(int chan, int note_num, int value);</p>		<p>These function should directly interact with your O.S. or hardware, if possible. The purpose of these function is quite obvious: they send to MIDI OUT port the corresponding messages. So these function are the <i>software interface</i> with MIDI OUT port.</p>		<p>All MIDI OUT opcodes have not a <b>k</b> or <b>a</b>-rate return value in Csound orc, because their output is implicitly sent to MIDI OUT port.</p>		<p>Below there is the treatment of the simplest opcodes (<i><b>ion, ioff</b></i>) and of the most complex one (<i><b>moscil</b></i>). See sources in files <b>midiout.h</b> and <b>midiout.c </b>to understand other MIDI OUT opcodes.</p>		<div align="left">			<h3><b><br>			1. ion and ioff sources</b></h3>		</div>		<p><i><b>ion</b></i> and <i><b>ioff</b></i> are the simplest MIDI OUT opcodes.</p>		<p>Here are the sources.</p>		<p>In the file <a href="Midiout.h"><b>midiout.h</b></a>:</p>		<p>typedef struct {<br>		OPDS h;<br>		float *ichn,*inum,*ivel;<br>		} OUT_ON;</p>		<p>source <b>9</b></p>		<p>In the file <a href="Midiout.c"><b>midiout.c</b></a>:</p>		<p>void iout_on(OUT_ON *p)<br>		{<br>		note_on((int)*p-&gt;ichn,(int)*p-&gt;inum,(int)*p-&gt;ivel);<br>		}<br>		void iout_off(OUT_ON *p)<br>		{<br>		note_off((int)*p-&gt;ichn,(int)*p-&gt;inum,(int)*p-&gt;ivel);<br>		}</p>		<p>source <b>10</b></p>		<p>Csound syntax of these opcodes is:</p>		<p><i><b>ion ichn, inum, ivel</b></i></p>		<p><i><b>ioff ichn, inum, ivel</b></i></p>		<p>Note that, as they are MIDI OUT opcodes, they do not return any audio or kontrol value, as their output is implicitly sent to MIDI OUT port.</p>		<p>The code is very very easy to understand:</p>		<ul>			<li>struct OUT_ON only contains OPDS type (necessary for all opcodes) and Csound-syntax arguments;			<li>iout_on( ) and iout_off( ) functions symply call the respective MIDI OUT interface functions.		</ul>		<p>&nbsp;</p>		<h3><b>2. moscil sources</b></h3>		<p><i><b>moscil</b></i> is a sort of oscillator of midi data. Its syntax is:</p>		<dir>			<dir>				<p><i><b>moscil kchn, knum, kvel, kdur, kpause</b></i></p>			</dir>		</dir>		<p>Note that, as it is a MIDI OUT opcode, it does not return any audio or kontrol value, as its output is implicitly sent to the MIDI OUT port. All the arguments can be varied at k-rate</p>		<p>The arguments meaning is the following:</p>		<ul>			<li><b>kchn</b> is midi channel of current note (range: 0-15);			<li><b>knum</b> is current note-number (range: 0-127);			<li><b>kvel</b> is current velocity (reange: 0-127);			<li><b>kdur</b> is the duration of current note in seconds;			<li><b>kpause</b> is the duration of a pause appended to the end of current note		</ul>		<p>Here are the sources.</p>		<p>Here is the data structure type declaration (in the file <b>midiout.h</b>):</p>		<p>1 typedef struct {<br>		2 OPDS h;<br>		3 float *kchn,*knum,*kvel,*kdur,*kpause;<br>		4 float istart_time;<br>		5 int last_chn, last_num, last_vel;<br>		6 float last_dur, last_pause;<br>		7 BOOL fl_note_expired, fl_first_note, fl_end_note;<br>		8 } MOSCIL;</p>		<p>source <b>11</b></p>		<p>temporary storage members of <b><br>		OSCIL</b> structure are:</p>		<ul>			<li><b>istart_time</b>, (line 4 of source 11) which holds absolute time at the moment current MIDI note is turned on, in seconds.			<li><b>last_chn</b>, <b>last_num</b>, <b>last_vel</b>, <b>last_dur </b>and <b>last_pause </b>which hold respectively channel, note-number, velocity, note-duration and pause values of last elapsed k-cicle.			<li><b>fl_note_expired</b> is a flag reporting whether current note time is expired or not.			<li><b>fl_first_note</b> is a flag reporting whether current note is the first note of current instance of the opcode or not.			<li><b>fl_end_note</b>, is a flag reporting whether global duration of current Csound instrument has been elapsed or it is still in progress. When current instrument instance is ending, <i><b>moscil</b></i> artificially extends its life of some k-rate cycles to allow sending a note-off message.		</ul>		<p>Here is the initialization function (in the file <a href="Midiout.c"><b>midiout.c</b></a><b>)</b>:</p>		<p>1 void moscil_set(MOSCIL *p) 2 {<br>		3 if (p-&gt;h.insdshead-&gt;xtratim &lt; EXTRA_TIME)<br>		4 p-&gt;h.insdshead-&gt;xtratim = EXTRA_TIME;<br>		5 p-&gt;istart_time = (float) kcounter * onedkr;<br>		6 p-&gt;fl_first_note = TRUE;<br>		7 p-&gt;fl_note_expired = TRUE;<br>		8 p-&gt;fl_end_note = FALSE;<br>		9 }</p>		<p>source <b>12</b></p>		<ul>			<li>Lines 3-4 of source 12 check if the instrument extra time life value is already set by another opcode within the same Csound instrument; if not, set it to <b>EXTRA_TIME</b> value (a constant decalred in the same file that express the k-periods number of instrument extra time).			<li>Line 5 calculates current instrument start time in seconds and stores the result in <b>istart_time </b>member of <b>MOSCIL</b> structure. <b>kcounter</b> is a global variable created and initialized in file <b>oload.c </b>containing the number of k-period elapsed since current Csound session<b>; onedkr</b> is a global variable created and initialized in file <b>oload.c </b>containing 1/kr.			<li>Lines 6-8 set the three flags to their initial values.		</ul>		<p>And here is the k-rate function (in the file <a href="Midiout.c"><b>midiout.c</b></a><b> </b>too<b>)</b>:</p>		<p>1 void moscil(MOSCIL *p) 2 {<br>		3 if (p-&gt;fl_first_note) {<br>		4 p-&gt;fl_first_note = FALSE;<br>		5 goto first_note;<br>		6 }<br>		7 if (!(p-&gt;fl_note_expired)) {<br>		8 if (p-&gt;h.insdshead-&gt;relesing) {<br>		9 p-&gt;fl_note_expired = TRUE;<br>		10 p-&gt;fl_end_note = TRUE;<br>		11 note_off(p-&gt;last_chn, p-&gt;last_num,<br>		12 p-&gt;last_vel);<br>		13 }<br>		14 else if ( p-&gt;last_dur<br>		15 &lt; (float)kcounter * onedkr<br>		16 - p-&gt;istart_time )<br>		17 {<br>		18 p-&gt;fl_note_expired = TRUE;<br>		19 note_off(p-&gt;last_chn,p-&gt;last_num,<br>		20 p-&gt;last_vel);<br>		21 }<br>		22 }<br>		23 else {<br>		24 if ( !p-&gt;fl_end_note<br>		25 &amp;&amp; p-&gt;last_pause + p-&gt;last_dur<br>		26 &lt; (float) kcounter * onedkr - p-&gt;istart_time<br>		27 &amp;&amp; !(p-&gt;h.insdshead-&gt;relesing)) {<br>		28 register float ftemp;<br>		29 p-&gt;istart_time = p-&gt;istart_time<br>		30 + p-&gt;last_pause<br>		31 + p-&gt;last_dur;<br>		32 p-&gt;last_dur = (ftemp = *p-&gt;kdur) &gt; 0 ?<br>		33 ftemp : onedkr;<br>		34 /* dur must be at least 1/kr */<br>		35 p-&gt;last_pause = (ftemp = *p-&gt;kpause) &gt; 0 ?<br>		36 ftemp : onedkr;<br>		37 first_note:<br>		38 {<br>		39 register int temp;<br>		40 p-&gt;last_chn = (temp = abs((int) *p-&gt;kchn)) &lt;<br>		41 NUMCHN ? temp : NUMCHN-1;<br>		42 p-&gt;last_num = (temp = abs((int) *p-&gt;knum)) &lt;<br>		43 128 ? temp : 127;<br>		44 p-&gt;last_vel = (temp = abs((int) *p-&gt;kvel)) &lt;<br>		45 128 ? temp : 127;<br>		46 }<br>		47 p-&gt;fl_note_expired = FALSE;<br>		48 note_on(p-&gt;last_chn, p-&gt;last_num,<br>		49 p-&gt;last_vel);<br>		50 }<br>		51 }<br>		52 }</p>		<p>source <b>13</b></p>		<ul>			<li>Lines 3-5 of source 13 check if current MIDI note is the first note of current <i><b>moscil</b></i> instance: if it is, it goes to line 37 in which there is a routine sending a note-on MIDI message . This routine is executed each time a note duration and a pause duration have elapsed (see below for details). Lines 4-5 are executed only once per <i><b>moscil</b></i> instance.			<li>Line 7 checks if at current time a note is activated or a pause is pending. If there is an active note (i.e. if it is not expired) then line 8 checks if the life of current instrument instance is ending; in this case lines 11-12 send a note-off message to avoid the last note to hang forever, otherwise lines 14-16 check if current note duration has elapsed and, in this case, lines 18-20 send a note-off message to MIDI OUT port.			<li>If a pause is pending (see program flow in line 7 and 23) lines 24-27 check the following conditions: instrument life must not be terminating (line 24); last pause must be elapsed (lines 25-26); instrument life must not be in extra-time period. If these three conditions are true, a note on message is sent to MIDI OUT port (lines 48-49) and istart_time, istart_dur, last_pause, last_chn, last_num and last_vel member of structure MOSCIL are re-initialized<br>			(lines 29-45).		</ul>		<h3><b>CONCLUSION</b></h3>		<p>In this chapter we learned to implement new realtime opcodes. I hope these opcodes can be only the beginning of a trend. I also invite you to go beyond the capabilities of MIDI, implementing a more complete music network system allowing floating point messages such as ZIPI and SKINI (by Perry Cook). The next step will be to implement external applications supporting a grafical interface which simulate an array controller-sliders to allow the interactive realtime generation of any MIDI message. So a person will use only the computer in a concert, without the need for external midi devices. Another possibility could be the translation of MIDI to SCSI opcodes to allow two computer run at the some time controlling each others in realtime, because SCSI protocol is very much faster than MIDI. This will allow to use virtual-reality input devices for controlling Csound in a very precise, fast and refined way.	</body></html>