<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>Wave Terrain Synthesis</title>		<meta name="Author" content="Josep M Comajuncosas">	</head>	<body bgcolor="white">		<h1>22. Wave Terrain Synthesis with Csound</h1>		<h2>Josep M. Comajuncosas</h2>		<h3>WT Synthesis</h3>		<p>As an extension to ordinary wavetable synthesis, wave terrain synthesis (WTS) <i>extends the principle of wavetable lookup to the scanning of three-dimensional surfaces</i> (see the <i>Computer Music Tutorial</i>, by Curtis Roads, pp.163-167). One can interpret WT Synthesis as <i>two-variable function synthesis</i>, and even implement it as pure orc code, but then the computational costs are incremented substantially. It&acute;s better to deal with a 2-dymensional table, and index it in a way similar to wavetable synthesis.</p>		<h3>Implementation</h3>		<p>The lack of arrays in Csound is a major problem when one tries to implement this kind of algorithms. Some estrategies are possible, notably those involving the new R.Whittle opcodes for table manipulation, or the<i> zak system</i>. In my designs I used the table generator <i>ftgen</i>, which is able to create tables from whithin the orchestra, though in a non-standard way.<br>		<i>ftgen</i> is intended to be called in the header statement, but, as I needed full control over the parameters of the table being generated, I placed it in an instrument which is executed first and generates the tables using a simple loop. I created a squared surface of n*n points as a row of n tables of size n (this constraints the surface sides to be multiple of 2). This method is straightforward and fast, and a wide variety of different surfaces can be generated this way.</p>		<p>To get predictable waveforms from WT synthesis one must begin with simple surfaces and paths. But by simply looking at the surface a great deal of information can be extracted. Using Winsound, for example, you can get a close idea of the surface by looking at those hundreds of tables generated being rapidly displayed, like multiple slices of the surface. To index the table one must design an <i>orbit</i>, that is, an arbitrary path trough the surface. It is important to notice that the resulting waveform is influended both by the surface and by the orbit itself. Both for simplicity and predictability I often use circular or spiral orbits. Some instruments use more complex paths, though.</p>		<p>Let&acute;s as an example consider the surface (given in the example num. 7)</p>		<p>z(x,y) = sin(2*pi*x)*sin(2*pi*y) with both x and y in [0,1]<br>		</p>		<center>			<p><img src="surface.gif" height="300" width="400"></p>		</center>		<p>Indexing it with a circular orbit of radius r centered at (.5, .5)</p>		<p>x = .5 + r*cos(2*pi*f)<br>		y = .5 + r*sin(2*pi*f)</p>		<p>will give us the following output</p>		<p>z = sin(2*pi*(.5 + r*cos(2*pi*f))*sin(2*pi*.5 + r*sin(2*pi*f))</p>		<p>which is the product (amplitude modulation) of two frequency-modulated signals. For the serious researches, further analysis should be necessary, of course.</p>		<p>The indexation is not without problems with Csound, for the ordinary<i> table</i> and <i>tablei </i>ugens don&acute;t allow to change the table number at k rate. In my first attempts (version 3.47 beta) I used tablera (again in a non-standard way), but this forces ksmps =1. The new <i>tablekt </i>and <i>tableikt</i> opcodes (from v. 3.47) are the most suitable ones for this purpose. I&acute;ve already used them in most of those designs. With <i>tablera</i> one must take into account that the indexes are truncated. 2D-Linear interpolation will be used to improve the s/n ratio without the need of large memory requirements. With <i>tableikt</i> the table look-up process already perfoms interpolation, and the result is much more elegant, resulting in a faster implementation.<br>		You must also consider the convenience of using<i> limit</i> or<i> wrap mode</i> in <i>tableikt.</i> With periodic waveforms the wrap mode will elegantly solve the problem of indexing accidentally outside the [0,1] range.<br>		</p>		<h3>Examples</h3>		<p>		<table border="0" cols="1" width="100%">			<tr>				<td>All the instruments have been tested with Winsound 3.47. The opcodes used have been recently implemented, so previous versions won&acute;t work at all, except maybe for the first instruments, from v. 3.45</td>			</tr>		</table>		&nbsp;</p>		<ul>			<li>wts1		</ul>		<p><a href="wts1.orc">orc</a> <a href="wts1.sco">sco</a></p>		<p>This first orchestra shows the basic implementation of WT synthesis. The surface is simply an inclined plane which, indexed by a circular orbit, will give a <i>pure</i> sine wave as output.</p>		<ul>			<li>wts2		</ul>		<p><a href="wts2.orc">orc</a> <a href="wts2.sco">sco</a></p>		<p>Let&acute;s compare the previous code with this one, with 2-D interpolation implemented as orc code. The quality has been greatly improved at some computational cost. All the remaining examples will use interpolation. With it one can use fairly small tables (256 points or less) without causing a noticeable table-lookup noise.</p>		<ul>			<li>wts3		</ul>		<p><a href="wts3.orc">orc</a> <a href="wts3.sco">sco</a></p>		<p>When the surface itself is sinusoidal (or more complex) we can obtain FM like timbres. The same applies to using different frequencies in the x and the y component of the (circular) orbit. More experiments later on.</p>		<ul>			<li>wts4		</ul>		<p><a href="wts4.orc">orc</a> <a href="wts4.sco">sco</a></p>		<p>Now we&acute;ll use the new <i>tableikt</i> opcode, which works like<i> tablei</i> but allowing k-rate table change, with interpolated read-out like in <i>tablei</i>. Even without any further refinement the result should be much better than using <i>tablera</i> with no interpolation.</p>		<ul>			<li>wts5		</ul>		<p><a href="wts5.orc">orc</a> <a href="wts5.sco">sco</a></p>		<p>And the same instrument with interpolation.</p>		<ul>			<li>wts6		</ul>		<p><a href="wts6.orc">orc</a> <a href="wts6.sco">sco</a></p>		<p>Till now we&acute;ve not done anything new, as all the tables generated are identical and the result could be perfectly the same using a single one (a simple <i>oscili </i>unit!). Let&acute;s try now to create true 2-D tables. First, we&acute;ll use the previous design but gradually changing the initial phase of the cosine wave stored in the tables.</p>		<ul>			<li>wts7		</ul>		<p><a href="wts7.orc">orc</a> <a href="wts7.sco">sco</a></p>		<p>This instrument implements the surface given as an example in the Introduction. The orbit is a spiral whose radius is controled by an envelope. Look carefully at the code to see how can you implement a virtual envelope to all the tables (here a sine wave).</p>		<ul>			<li>wts8		</ul>		<p><a href="wts8.orc">orc</a> <a href="wts8.sco">sco</a></p>		<p>Other GEN routines could be used as well, each one with its own applications. This one uses GEN11 varying dynamically r (a&nbsp; multiplier in an amplitude coefficient series). It creates a kind of frequency-dependant resonance, an effect similar can be obtained with waveshaping. At low frequencies the sound is great!</p>		<ul>			<li>wts9		</ul>		<p><a href="wts9.orc">orc</a> <a href="wts9.sco">sco</a></p>		<p>This instruments implements dynamic waveshaping, storing in each table a slightly different GEN13-generated table. The orbit indexes first a zone with only the 1st harmonic (though not in a fixed table, but in a elliptic path which provides a minimally evolving timbre), then one with only even harmonics, afterwards a zone with all the harmonics present and finally just with odd harmonics. Quite costly to implement without WTS.</p>		<ul>			<li>wts10		</ul>		<p><a href="wts10.orc">orc</a> <a href="wts10.sco">sco</a></p>		<p>The last example uses a fairly simple surface indexed by a complex orbit, setting the frequencies of the <i>oscil </i>units associated to the x and y coordinates to different values, which creates a typical timbral evolution, ranging from tremolo effects to FM timbres.&nbsp; A non-periodic (inharmonic) signal can be obtained simply by setting the frequencies of the oscil units controlling the x and the y dimensions of the path to mutually prime numbers. The idea is not very different from ordinary FM synthesis. One could use a chaotic orbit and see how it sounds, but I believe the result would&acute;t be much different from using that chaotic orbit itself to generate the sound...<br>		</p>		<h3>Compositional Applications</h3>		<p>The next three examples are suposed to be more useful. There&acute;s nothing new in them, but the timbres are more interesting.</p>		<ul>			<li>Example 1:		</ul>		<p><a href="example1.orc">orc</a> <a href="example1.sco">sco</a></p>		<p>Once the table has been stored in memory, it is efficient to index it with multiple and slightly different orbits, for example placing the center of the orbit at different places in the surface. This orquestra creates in this way a very dense, deep analog-like drone sound.</p>		<ul>			<li>Example 2:		</ul>		<p><a href="example2.orc">orc</a> <a href="example2.sco">sco</a></p>		<p>Not to forget more <i>creative</i> timbres, here is a sample. The surface is make of random values following a Weibull distribution. Variations in the variable of GEN21-10 and in the orbit provide a timbre which ranges from noise to a quasi-periodic granulated signal (enhanced with the interpolation in the table look-up and the lowpass filter before the output).<br>		</p>		<ul>			<li>Example 3:		</ul>		<p><a href="example3.orc">orc</a> <a href="example3.sco">sco</a></p>		<p>A timbral change from brass to clarinet can be implemented with dynamic waveshaping and other refinements. Some people call this <i>morphing</i>... Don&acute;t expect too much of this design as it is entirely empyrical, in fact the effect is too subtle.<br>		</p>		<h3>Conclusions and Further Work</h3>		<p>WTS has shown to be a simple yet effective way to create complex timbral textures. With its graphical background it is also quite easy to predict the basic character of the sound, and the code is computationally fast, though the memory requirements can be quite large. To design arbitrary surfaces my method is not enough flexible, though. Sometimes it would be necessary to implement them as orquestra code, but then all the computational efficiency would be lost. WTS could be also used as a tool for sound modification, by using a recording as one dimension of the surface, or as the orbit. I&acute;ve not carried out any experiments in this direction.<br>	</body></html>