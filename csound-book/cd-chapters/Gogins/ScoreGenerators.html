<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN"><!--last modified on Monday, October 18, 1999 12:51 AM --><html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>Algorithmic Score Generators</title>		<meta name="Author" content="Michael Gogins">	</head>	<body text="black" bgcolor="#eeeeee" link="#0000ee" alink="red" vlink="#551a8b">		<h1>8. Algorithmic Score Generators</h1>		<h2>Michael Gogins</h2>		<p>Computer music actually began with algorithmic composition, not synthesis, and algorithmic composition has remained a focus of research throughout the brief history of this field. Thus a general survey is beyond the scope of this chapter (some pointers to additional resources are provided at the end). The purpose of this chapter is to develop a narrow yet deep understanding of some basic principles of algorithmic composition, as illustrated by sample programs in Java that generate scores for Csound.</p>		<p>The focus is on esthetics and composition, as much as the details of software. <i>Why</i> write software to write music, instead of just writing music? <i>What</i> compositional techniques might be fruitful at this dawn in the history of the field? <i>How</i> does one make music with free stuff like Csound and Java?</p>		<p>After working through this chapter, you should be able to write your own score generators. The scores produced by the sample programs are suitable for synthesis with Csound using either the the plain old command-line approach, or the ScoreManager object from the chapter &quot;Creating and Using a Platform-Independent Graphical User Interface for Csound in Java.&quot;</p>		<h3>A Very Brief Historical Introduction</h3>		<p>Algorithmic composition is not new. It began with the wind chimes of the most ancient civilizations, and the Aeolian harp. In a more considered sense it it goes back at least as far as Mozart&#146;s musical dice game. Similar systems were peddled in the 19th century (Scholes 1975). More recently, but predating computers, Joseph Schillinger (1946, 1948; DeGazio, no date) worked out a system of composition that lends itself to algorithmic score generation.</p>		<p>Mozart&#146;s game and Schillinger&#146;s system are informal examples of generative grammars. Some music theorists, notably Lerdahl and Jackendoff (1983), cast their theories as completely formal systems, generative grammars in the mathematical sense. It is a natural thought to turn the rules on their head, to use theory to synthesize compositions from parts instead of analyzing them (Holtzman 1981; Roads 1978, 1985).</p>		<p>In the modern age, yet still predating computers, some composers turned to another generative principle, chance. A notable example is Iannis Xenakis (1992), who in his later career used computers to implement and extend probabilistic algorithms. There is an obvious synergy between the grammatical and the probabilistic approaches, in that random variables can select structures and rules in a generative grammar.</p>		<p>Running alongside the history of compositional algorithms on paper or as works of the intellect is a parallel history, of algorithms embodied in mechanisms. They range from the Aeolian harp, through clockwork and carillons to various gadgets of the Renaissance and Enlightenment (Ord-Hume 1973, Buchner 1978, Lyr 1955, Prieberg 1975), through the electronic fantasias of such inspired eccentrics as Raymond Scott (1992) with his Electronium or &quot;instantaneous composing machine&quot; of the late 1950&#146;s, to the composing machine built by the engineers who made the RCA synthesizer used by Milton Babbitt (Olson and Belar 1961, Hiller 1970), and culminate in the modular synthesizer, whose oscillators and filters and sequencers, patched together with complex nets of cords, burbled and whacked their way into unforeseeable progressions and polyrhythms.</p>		<p>Here a theme emerges, to be pursued on the computer down into its mathematical basis: the machine becomes unpredictable and makes fascinating sounds that the composer attempts to shepherd into artful form, not always unsuccessfully, with his or her knobs and switches.</p>		<p>But electronic systems, so vigorously proliferating in the 1970s, have faded in favor of the universal machine: the computer.</p>		<p>The very first piece of computer music was perhaps Hiller and Isaacson&#146;s Iliac Suite, for String Quartet (1957a, 1957b). It does not involve sound synthesis at all, but is an algorithmic composition in which random variables select structures and rules for elaborating structures. Hiller invented fundamental concepts in algorithmic composition (1970, Hiller and Isaacson 1959), and made other important pieces, including The Computer Cantata (Hiller and Baker 1964) and HPSCHD, a collaboration with John Cage (Cage and Hiller 1969, Hiller and Cage 1968).</p>		<p>An even broader influence upon composition is that of Cage himself, who used aleatoric procedures for both composition and performance, e.g. in Music of Changes (1961, pp. 57-61), and who also mapped natural forms onto musical scores, e.g. the star charts in Atlas Eclipticalis (Cage 1992). These works can be considered (to some extent, for he also used his own judgment) algorithmic compositions, because after chosing source materials and mappings, he generated the scores with pre-defined procedures. After all, tossing a coin is also a procedure.</p>		<p>That is what an algorithm is: a definite procedure. A recipe. Mindless instructions an idiot can follow. But a quick enough idiot with clever enough instructions can do a great deal... in fact, any single thing...yet, not all things!</p>		<p>If you wish to to grasp algorithmic composition at the deepest level, a brief detour to review the fundamental qualities and limitations of algorithms may be helpful (this and the following two paragraphs may be skipped without harm to your understanding of how to write score generators).</p>		<p>The starting point is that any algorithm can be reduced to one shortest possible program on a universal computer (Chaitin 1974a). However, it has been proved that there is no single algorithm capable of examining any other algorithm and deciding either (a) whether it will halt or, because of some bug or infinite loop, run forever, or (b) whether it has been reduced to its shortest form. Point (a) is the halting theorem (Turing in Davis 1965). Point (b), following from (a), is the incompleteness theorem (G&ouml;del in Davis 1965). Readers desiring an introduction to this topic are urged to consult Chaitin (1974b); for a historical resume, see Davis (1965).</p>		<p>These abstract considerations have a definite musical corrollary. There can never, not even in principle, be a &quot;critic algorithm&quot; capable of deciding, for any arbitrary score generator, whether it will make good music. Proof: the critic can&#146;t decide if a given generator will halt, except by simulating its execution; so, if the generator doesn&#146;t halt, neither does the critic. The only way to tell is to run the generator and listen to the music.</p>		<p>In short, score generators are &quot;computationally irreducible&quot; (Peitgen, J&uuml;rgens, and Saupe 1990). All score generating programs are computationally irreducible - not only those based on mathematics, but also those based on music theory. What this means is that digital computers are incapable of composing by themselves, and that score generators are the instruments of human composers, not replacements for them.</p>		<p>Recently, new methods of algorithmic composition have been developed using chaotic dynamics and fractal geometry (see &quot;Fractal Music,&quot; below). These fields of mathematics are concerned with the complex behavior exhibited by simple nonlinear systems. Not only can completely deterministic systems produce statistically random output (the pseudo-random number generators Hiller and Cage used are just such systems), but iterating completely random selections from a fixed pool of functions can produce precisely determined output (Gogins 1991).</p>		<p>This chapter introduces a compositional program based on chaotic dynamics (LogMuse), and concludes with a purely deterministic generative grammar working at a specifically musical level of abstraction (MinimalMuse). I believe this order of presentation, though not historical, best elucidates the esthetic and technical issues raised by algorithmic composition. Another fractal music generator, which illustrates the compositional use of a variety of fractals (GrafMuse), can be found in Appendix C.</p>		<h3>Do You Know How the Music Will Sound?</h3>		<p>The first question non-computer musicians usually ask computer musicians is: &quot;Do you know how the music will sound?&quot; (that is, before running the score generator). It is a naive question, yet a profound and revealing one.</p>		<p>The implication is clear: If one doesn&#146;t hear music in one&#146;s head before sitting down at the computer, one can&#146;t really be composing.</p>		<p>The answer is: It is impossible in principle to imagine in advance, in detail, for most score generators, how the music will sound.</p>		<p>That, of course, is exactly why score generators are useful for composing in the first place. If they produced only what could be imagined in advance, they would be only score transcribers, not score generators.</p>		<p>In short, score generators can definitely be used to make music that could never be imagined without them. However, is it any good, can it be any good, and how does one make it good?</p>		<p>Good music isn&#146;t written merely by tossing coins or inking star charts onto staves. Cage didn&#146;t do only that! How can an instrument that is more or less unpredictable actually be used? Is there any middle path between complete predictability, which is redundant, and total randomness, which is a crap shoot? What does it mean to say one understands an algorithm? How, in practice, are algorithms used to compose? It is helpful to rephrase the question in terms of an actual algorithm, a very basic one that will clarify the issues. In the Java programming language:</p>		<pre>y1 = y * c * 4 * (1.0 - y);</pre>		<p>This is the famous &quot;logistic equation&quot; often used to introduce chaos (e.g. Pietgen, J&uuml;rgens and Saupe 1992, pp. 585-653). When an equation is iterated, that is, when its value at time t is used as an argument to compute its value at time t + 1, it is known as a &quot;dynamical system&quot;. The logistic equation can be iterated 1,000 times by putting it into a loop and re-assigning its value to y, as follows:</p>		<pre>y = 0.5;for(t = 0; t &lt; 1000; t++){	y1 = y * c * 4.0 * (1.0 - y);	y = y1;}</pre>		<p>Obviously this system is controlled by the parameter c. The original question, &quot;Do you know how the music will sound?&quot;, can now be restated as, &quot;For a given value of c, do you know how the value of y will evolve?</p>		<p>I have implemented this loop as a Csound score generator in Java (Applet 1 and Listing 1), in Microsoft QuickBASIC, which comes with most IBM compatible PCs (Appendix A), and in ANSI C (Appendix B). The programs demonstrate, in each language, how to open, write to, and close files; how to make a Csound orchestra; how to set up a generating loop; how to make a Csound score; how to run Csound; and how (on Windows, anyway) to play the generated soundfile. These are the basic tasks that any score generator for Csound must perform. In each program the most important line is the one that writes note statements into the score file, because Csound chokes on numbers that are not in just the right format.</p>		<p>Java is a good choice for score generating programs for several reasons. It is a complete language, with interfaces, classes, file access, and mathematical functions. It is a rapid development environment, with GUI generators and integrated debuggers, which is important for computer music, where many programs are written to run only once or a few times. The syntax of Java is like that of C with classes, or a simplified C++, so many programmers will be able to use it immediately. Best of all, Java uses a &quot;virtual machine&quot; so that not only the source code, but also the compiled classes, are portable from one computer architecture to another. Last but not least, Java is available for little or nothing on the Internet or on CD-ROMs in books about Java. Java is always slower than compiled languages such as C or C++, but that is not critical for score generators.</p>		<p>Unfortunately, as of the time of writing, Web browsers contain security provisions that prevent applets from reading or writing files. This keeps applets from writing scores or even running Csound. In the future, Web browsers will probably allow users to set the level of security they desire so that applets can read and write files on their computers.</p>		<p>In the meantime, fortunately, at least on Windows computers on which the jview Java virtual machine has been installed (it comes with Microsoft Internet Explorer), every applet in this chapter can be run in standalone mode from this Web page by clicking on the corresponding &quot;standalone mode&quot; link, which opens a batch file that runs the applet outside the browser. In this mode, every applet is completely functional and can read files, write files, and run Csound. On other computers, the applets can still be run in standalone mode by setting up the classpath to include Silence.ScoreManager, and running the Java virtual machine with the applet&#146;s class name (see the appropriate documentation for details).</p>		<h4>Applet 1. A Simple Logistic Equation Score Generator.</h4>		<p><br>		<applet code="GoginsChapters.ScoreGenerators.LogMuse.LogMuse.class" width="302" height="102" align="bottom">		</applet></p>		<h4><a href="LogMuse.bat">Logistic Equation Score Generator in Standalone Mode.</a></h4>		<p><embed name="LogMuse.mp3" src="logmuse.mp3" width="300" height="45" align="bottom" autoplay="false"></p>		<p><a href="logmuse.mp3">LogMuse.mp3</a></p>		<p>Note: When run in standalone mode, these applets can load and save files and run Csound.</p>		<h4>Listing 1. A Simple Logistic Equation Score Generator.</h4>		<pre>//  S I L E N C E//  A system for making music on computers by means of software alone.//  Copyright (C) 1997 by Michael Gogins. All rights reserved.import java.io.*;import java.awt.*;import java.applet.*;//  A simple logistic equation score generator.public class LogMuse extends Applet{	public String argumentValues[];    	//	All Java standalone programs must have    	//	a static main() function.    	public static void main(String argv[])    	{        		LogMuse logMuse = new LogMuse();        		logMuse.argumentValues = argv;        		Frame frame = new Frame();        		frame.add(logMuse);        		frame.show();        		logMuse.init();        		frame.resize(logMuse.size().width + frame.insets().left * 2, logMuse.size().height + frame.insets().top);        		logMuse.move(frame.insets().left, frame.insets().top);        		logMuse.start();    	}    	public void generate()    	{		//  	Variables for the generator.		double c;		double y;		double y1;		int i;		int n;		// 	Variables for music.		//  	The dimensions that are not generated have default values.		double instrument = 1;		double start;		double length = 2;		double octave;		double decibels = 70;		double pan = 0;		//  	Mapping coefficients.		double pulse = .25;		double bass = 6;		double range = 4;		//  	Variables for rendering the score.		FileOutputStream fileOutputStream = null;		PrintStream printStream = null;		//  	You can paste a Csound instrument definition right into BASIC code like this.		String orchestra =			&quot;sr =    44100\n&quot;			+ &quot;kr =    44100\n&quot;			+ &quot;ksmps =     1\n&quot;			+ &quot;nchnls =    2\n&quot;			+ &quot;\n&quot;			+ &quot;; Frequency modulation instrument.\n&quot;			+ &quot;instr 1\n&quot;			+ &quot;; LOGGING\n&quot;			+ &quot;; p1 = Instrument\n&quot;			+ &quot;; p2 = Start\n&quot;			+ &quot;; p3 = Length\n&quot;			+ &quot;; p4 = Octave\n&quot;			+ &quot;; p5 = Decibels\n&quot;			+ &quot;; p6 = Pan\n&quot;			+ &quot;print p2, p3, p4, p5, p6\n&quot;			+ &quot;\n&quot;			+ &quot;; INITIALIZATION\n&quot;			+ &quot;iwavetable = 1\n&quot;			+ &quot;imodulator = .5\n&quot;			+ &quot;ifmamplitude = 1\n&quot;			+ &quot;index = 1.375\n&quot;			+ &quot;iattack = .025\n&quot;			+ &quot;irelease = .125\n&quot;			+ &quot;isustain = p3  - (iattack + irelease)\n&quot;			+ &quot;if isustain &gt; 0 goto longenvelope\n&quot;			+ &quot;isustain = 0.03\n&quot;			+ &quot;p3 = iattack + isustain + irelease\n&quot;			+ &quot;longenvelope:\n&quot;			+ &quot;ifrequency = cpsoct(p4)\n&quot;			+ &quot;icarrier =  .998\n&quot;			+ &quot;icarrierb =  1.002\n&quot;			+ &quot;; Normalize to 80 dB = ampdb(80).\n&quot;			+ &quot;iamplitude = ampdb(p5) * 15848.926 / 12729.0\n&quot;			+ &quot;ileftpan = (0.5 - p6) / 2.0\n&quot;			+ &quot;irightpan = (0.5 + p6) / 2.0\n&quot;			+ &quot;\n&quot;			+ &quot;; KONTROL\n&quot;			+ &quot;kindenv expseg .00001, iattack, 1, isustain, .1, irelease, .00001\n&quot;			+ &quot;kindex = kindenv * index * ifmamplitude\n&quot;			+ &quot;\n&quot;			+ &quot;; AUDIO\n&quot;			+ &quot;aouta foscili iamplitude, ifrequency, icarrier, imodulator, kindex, iwavetable\n&quot;			+ &quot;aoutb foscili iamplitude, ifrequency, icarrierb, imodulator, kindex, iwavetable\n&quot;			+ &quot;afmout = (aouta + aoutb) * kindenv * 2.556\n&quot;			+ &quot;outs ileftpan * afmout, irightpan * afmout\n&quot;			+ &quot;endin\n&quot;;		//	Try to read c from the command line, otherwise use a default.		try		{			Double buffer = new Double(argumentValues[1]);			c = buffer.doubleValue();		}		catch(ArrayIndexOutOfBoundsException e)		{			c = .98473;		}		catch(NullPointerException e)		{			c = .98473;		}		//	Try to read n from the command line, otherwise use a default.		try		{			Integer buffer = new Integer(argumentValues[2]);			n = buffer.intValue();		}		catch(ArrayIndexOutOfBoundsException e)		{			n = 100;		}		catch(NullPointerException e)		{			n = 100;		}		//  	Create a score file.		try		{			fileOutputStream = new FileOutputStream(&quot;test.sco&quot;);			printStream = new PrintStream(fileOutputStream);			//  	Initial value of y.			y = .5;			//  	Write the initial state of the system as a Csound comment.			printStream.println(&quot;; Hello Csound!\n; c = &quot; + c + &quot;\n; y = &quot; + y + &quot;\n; n = &quot; + n);			//  	GENERATE THE SCORE			//  	Write the function table for the instrument.			printStream.println(&quot;f 1 0 16384 10 1 ; High-fidelity sine wave.&quot;);			// 	Iterate to write the notes.			for(i = 0; i &lt; n; ++i)		{			////////////////////////////////////////////////////////////////////			//  	GENERATION			y1 = y * c * 4 * (1.0 - y);			//  	MAPPING			start = i * pulse;			octave = bass + y1 * range;			//  	Round off to 12 tone equal temperament.			octave = ((int)(octave * 12.0 + .5)) / 12.0;			//  	RENDERING			//  	Write a note into the Csound score.			printStream.println(&quot;i &quot; + instrument + &quot; &quot; + start + &quot; &quot; + length + &quot; &quot; + octave + &quot; &quot; + decibels + &quot; &quot; + pan);			//  	Iterate.			y = y1;			////////////////////////////////////////////////////////////////////		}		//  	RENDER THE SOUNDFILE		//  	Write the orchestra file.		fileOutputStream = new FileOutputStream(&quot;test.orc&quot;);		printStream = new PrintStream(fileOutputStream);		printStream.println(orchestra);		printStream.close();		//  	Render the generated files using Csound.		Runtime runtime = Runtime.getRuntime();		Process process = runtime.exec(&quot;winsound -WsRo LogMuse.wav test.orc test.sco&quot;);		try		{			process.waitFor();		}		catch(Exception e)		{			System.out.println(e.getMessage());		}		//  	PLAY THE SOUNDFILE		runtime.exec(&quot;MPLAYER LogMuse.wav&quot;);	}	catch(IOException e)	{		System.out.println(e.getMessage());	}    	public void init()	{		super.init();		//{{INIT_CONTROLS		setLayout(null);		addNotify();		resize(302,102);		setFont(new Font(&quot;TimesRoman&quot;, Font.BOLD, 12));		buttonGenerate = new java.awt.Button(&quot;Generate&quot;);		buttonGenerate.reshape(12,48,276,36);		buttonGenerate.setFont(new Font(&quot;TimesRoman&quot;, Font.BOLD, 16));		add(buttonGenerate);		labelScoreGenerator = new java.awt.Label(&quot;Logistic Equation Score Generator version 1&quot;);		labelScoreGenerator.reshape(0,12,300,30);		labelScoreGenerator.setFont(new Font(&quot;TimesRoman&quot;, Font.BOLD, 14));		add(labelScoreGenerator);		//}}	}	public boolean handleEvent(Event event)	{		if (event.target == buttonGenerate &amp;&amp; event.id == Event.ACTION_EVENT)		{			generate();			return true;		}		return super.handleEvent(event);	}	//{{DECLARE_CONTROLS	java.awt.Button buttonGenerate;	java.awt.Label labelScoreGenerator;	//}}}</pre>		<p>This program has only enough user interface code to show up as an applet on a Web page. This program is completely self-contained (except, of course, for Csound). Even the instrument is built into the code. This reflects my experience that if more than one file is needed to document or recreate a piece, a critical one always seems to get lost.</p>		<h2>Generating, Mapping, Rendering</h2>		<p>In the sample program I separated the generating equation, from the code to map the generated points onto musical dimensions, from the rendering. This hierarchy appears over and over again in algorithmic composition:</p>		<ol>			<li><i>Generation. </i>The actual compositional algorithm may be borrowed from a non-musical field such as chaotic dynamics, fractal geometry, biology, or linguistics; or it may be a program in a specifically musical composing language.			<li>Unless the generator is specifically musical, there must be a <i>mapping</i> onto a musical space, i.e. dimensions of music theory. This space may be more or less abstract, it can represent times, pitches, chord types, root progressions, rhythmic patterns, collections of motives, tone rows, etc.			<li><i>Rendering</i>, where the physical score and soundfile are produced.		</ol>		<h2>Parametric Composition</h2>		<p>The original question, &quot;Do you know how the music will sound?&quot;, has been restated as, &quot;In the logistic dynamical system, for a given value of c, do you know how the value of y will evolve?&quot;</p>		<p>The system is controlled by the parameter c, ranging from 0 to 1. In some cases the answer is indeed obvious. If c is 0, then after the first iteration y is always 0. For other cases, let us generate some experimental scores. For that purpose, we will use a more sophisticated yet simpler version of the logistic equation score generator that uses a ScoreManager object to hold and render the generated score (Applet 2; for code and details see the chapter &quot;Implementing and Using a Platform-Independent Graphical User Interface for Csound in Java&quot;).</p>		<h4>Applet 2. A Simple Logistic Equation Score Generator with Controllable Parameters.</h4>		<p><br>		<applet code="GoginsChapters.ScoreGenerators.LogMuseDialog.LogMuseDialog.class" width="400" height="201" align="bottom">		</applet></p>		<h4><a href="LogMuseDialog.bat">Logistic Equation Score Generator with Controllable Parameters in Standalone Mode.</a></h4>		<p>Set c to .5. The first part of the result is shown in Score 1.</p>		<h4>Score 1.</h4>		<p><img src="SCORE1.GIF" width="995" height="130" align="BOTTOM" border="0"></p>		<p>Now set c to .75. The first part of the result is shown in Score 2. The system oscillates between 2 points, gradually settling into a stable orbit. When a dynamical system settles into a stable orbit, that orbit is called the &quot;attractor&quot; of the system.</p>		<h4>Score 2.</h4>		<p><img src="SCORE2.GIF" width="993" height="173" align="BOTTOM" border="0"></p>		<p>Perhaps as c increases in value, the orbit becomes more complex. Try c = .9. The result is shown in Score 3. No matter how many times it is iterated, the system never displays a periodic orbit. However, the orbit is an attractor, because no matter what value initial value of y is used, the same orbit results; it is stable. A stable orbit that never repeats seems a bit strange, so this is called a &quot;strange attractor&quot; or &quot;chaotic attractor.&quot;</p>		<h4><embed src="c9.mp3" width="300" height="45" align="bottom" autoplay="false"></h4>		<h4><a href="c9.mp3">c9.mp3</a></h4>		<h4>Score 3.</h4>		<p><img src="SCORE3.GIF" width="993" height="355" align="BOTTOM" border="0"></p>		<p>Now try c = .95. The result is shown in Score 4. Obviously the idea that as c increases, so does complexity, is too simple.</p>		<h4>Score 4.</h4>		<p><img src="SCORE4.GIF" width="995" height="180" align="BOTTOM" border="0"></p>		<p>Let us write a program (Applet 3) to increase the value of c from 0.66 to 1 in 1000 steps, and iterate 10 notes for each step. The generating loop is shown in Listing 2. Instead of writing the notes directly into a score file, they are put into a ScoreManager object (see the chapter &quot;Creating and Using a Platform-Independent Graphical User Interface for Csound in Java&quot;). The result is shown, <i>not</i> in 12-tone equal temperament, in ScoreManager&#146;s piano-roll display (Figure 1). This is called a &quot;parametric map,&quot; because it maps attractors corresponding to many values of the parameter c.</p>		<h4>Applet 3. Logistic Map Score Generator.</h4>		<p><br>		<applet code="GoginsChapters.ScoreGenerators.LogMap.LogMap.class" width="360" height="325" align="bottom">		</applet></p>		<h4><a href="LogMap.bat">Logistic Map Score Generator in Standalone Mode.</a></h4>		<h4>Listing 2. Logistic Map Score Generator.</h4>		<pre>void generate(){	//	Clear out the old score.	score.initialize();	//	Generate a new score.	double cIncrement = (cFinal - cInitial) / cn;	double c = cInitial;	double y1;	for(int ci = 0; ci &lt; cn; ci++)	{		//	Start each increment at the same value of y.		double y = .5;		//	Pre-iterate to find the attractor.		for(int i = 0; i &lt; 100; i++)		{			y1 = y * c * 4.0 * (1.0 - y);			y = y1;		}		//	Make notes only from the attractor.		for(int i = 0; i &lt; n; i++)		{			////////////////////////////////////////////			// GENERATE			y1 = y * c * 4.0 * (1.0 - y);			// MAP TO MUSIC			start = ((ci * n) + i) * pulse;			octave = bass + y1 * range;			// RENDER THE SCORE			// Store a note in the score manager.			score.noteAdd(instrument, start, length, octave, decibels, pan);			// Iterate n.			y = y1;			////////////////////////////////////////////		}		//	Iterate c to explore chaos.		c += cIncrement;	}}</pre>		<p><img src="FIGURE1.GIF" width="1024" height="768" align="BOTTOM" border="0"></p>		<h4>Figure 1.</h4>		<p>As c increases, y tends to settle into an attractor first of period 1, then of period 2, then 4, and so on. This is known as &quot;bifurcation&quot; or &quot;period doubling.&quot; But note the band of attractors with period 3; any quadratic-type dynamical system with an attractor of period 3 also has chaotic attractors (Li and Yorke 1975).</p>		<p>Feigenbaum (1983) proved that the ratio of proportionality between values of c which double in period is a constant, 4.6692..., and moreoever that it is a universal constant characterizing all &quot;quadratic-like&quot; dynamical systems. Hence the exact equation used to generate a score is of secondary importance. What is really important is Feigenbaum&#146;s constant, period doubling, and chaos.</p>		<p>Note again the bands of periodicity within chaotic regions. They suggest it is possible to compose music by exploring the map of the system, and selecting parameters near transitions from periodicity to chaos. At such points the system oscillates between periodicity and chaos as it evolves, manifesting thematic and textural contrasts. Score 5, based on a constant of 0.965, is an example (note lengths have been increased).</p>		<h4>Score 5.</h4>		<p><img src="SCORE5.GIF" width="1001" height="531" align="BOTTOM" border="0"></p>		<p>This is somewhat more musical than the first examples, so we are getting somewhere. And the period doubling is an infinite series, so there is an infinite number of transitions between periodicity and chaos, each differing in detail from all others.</p>		<p>Therefore: For arbitrary inputs to a chaotic score generator, sometimes the music can be imagined in advance (simple periodicity), but much more often it cannot (complex periodicity and chaos), and the most interesting music lies on the borderlines of chaos. It is possible to compose by exploring this parameter space on a computer. In fact, this is an entirely new method of composition - one possible only on a computer.</p>		<p>Although the logistic equation is a simple algorithm, a number of composers have used it, e.g. Gary Nelson in <i><b>The Voyage of the Golah Iota</b></i> (1993).</p>		<h3><embed src="c965.mp3" width="300" height="45" align="bottom" autoplay="false"></h3>		<h3><a href="c965.mp3">c965.mp3</a></h3>		<h3>A &quot;Minimalist&quot; Generative Grammar</h3>		<p>Let us now turn to another style of algorithmic composition, and one more characteristic of the history of the field, based on a generative grammar. Such a grammar (also called a context-free language) is a mathematical system (Chomsky 1957). It consists of:</p>		<ol>			<li>A <i>vocabulary </i>of symbols (digits, letters, words, or even sentences).			<li>An <i>axiom </i>or initial sequence of one or more symbols.			<li>A set of <i>rewriting rules</i> of the form, &quot;replace symbol x with symbol y.&quot; The rewriting rules are initially applied to the axiom, resulting in a rewritten sequence or production. The rules are then applied to the production, to the production of the production, and so on. The production may grow or shrink as the rewriting is reiterated.			<li>Either some symbols are <i>terminal</i>, and the rewriting ends when all non-terminal symbols have been rewritten as terminal symbols, or the rewriting rules are applied a specified number of times or <i>iterations</i>.		</ol>		<p>This is a powerful concept, because it completely captures the notion of a discrete recursive function. Complex systems modeled by generative grammars include English syntax (Chomsky 1957), the growth and branching of plants (Prusinkewicz and Lindenmayer, 1993), and musical tonality (Lerdahl and Jackendoff, 1983).</p>		<h2>Minimalist Procedures</h2>		<p>A precise definition of Minimalism is elusive. For present purposes, consider it to be music composed of short motives, or &quot;cells&quot; (Warburton 1988), repeated and combined in such a way that the resulting music is complex and not completely predictable (DeLio 1984, Mertens 1983, Nyman 1974). In a piece consisting of two cells repeating simultaneously, the two might be identical except for total duration; or one might be a note shorter than the other; or a third, shorter cell might be inserted into the repetitions from time to time, so that when the cells are simultaneously repeated, a differential canon evolves. Or a set of cells might be played in sequence by a group of players, each choosing in aleatoric fashion when to cease repeating one cell and advance to the next (Terry Riley&#146;s In C, 1989).<p4>The unpredictability of the intervals that result from combining cells in different phases is similar to the unpredictability of the sequences that arise in a chaotic dynamical system. A similar mechanism is at work in both cases: &quot;stretch and fold.&quot; The shift in phase is analogous to multiplication by the constant in the dynamical system (stretch), and the repetition of the cells is analogous to the iteration and reflection of the dynamical system back into its attractor (fold).</p>		<h4>Applet 4. A Minimalist Generative Grammar Score Generator.</h4>		<p><br>		<applet code="GoginsChapters.ScoreGenerators.MinimalMuse.MinimalMuse.class" width="721" height="496" align="bottom">		</applet></p>		<h4><a href="MinimalMuse.bat">Minimalist Generative Grammer in Standalone Mode.</a></h4>		<p>Applet 4 presents a simple generative grammar in Java, MinimalMuse, that generates scores in a sort of Minimalist style from short programs. MinimalMuse is a Lindenmayer system: it has only non-terminal symbols, in which the rewriting rules are applied a specified number of times. The idea is that a pen moves around on a score, obeying a few simple commands. Pen and score have dimensions similar to my 6-dimensional Csound score:<instrument, start, length, pitch in semitones (instead of linear octaves), decibels, pan>. The pen commands are:</p>		<ol>			<li><b>note</b>: Write a note on the score using the current state of the pen, and advance the current length of the pen in time.			<li><b>instrument <i>number</i></b>: Set the pen&#146;s instrument to number.			<li><b>start <i>seconds</i></b>: Set the pen&#146;s time to seconds.			<li><b>length <i>seconds</i></b>: Set the pen&#146;s length to seconds.			<li><b>advance <i>seconds</i></b>: Move the pen forward seconds in time; can be a negative number.			<li><b>rest</b>: Without writing a note, advance the current length of the pen in time.			<li><b>tempo <i>multiplier</i></b>: Multiply the pen&#146;s length by multiplier.			<li><b>pitch <i>semitones</i></b>: Set the pen&#146;s pitch to semitones (middle C = 60).			<li><b>transpose <i>semitones</i></b>: Transpose the pen&#146;s pitch by semitones (can be a fraction).			<li><b>decibels <i>value</i></b>: Set the pen&#146;s loudness to decibels.			<li><b>dynamics <i>multiplier</i></b>: Multiply the pen&#146;s decibels by multiplier.			<li><b>pan <i>value</i></b>: Set the pen&#146;s pan to value.			<li><b>push</b>: Store the current state of the pen by pushing it on a stack.			<li><b>pop</b>: Restore the earlier state of the pen by popping it from the stack.		</ol>		<p>MinimalMuse is implemented along the same pattern as most generative grammars. It has a lexer that parses symbols out of the axiom and intermediate productions (a Java StreamTokenizer object), a compiler that rewrites the axiom and intermediate productions to generate a final production (the MinimalMuse.generate() function), a lexer that parses symbols out of the final production (another StreamTokenizer), and a parser that interprets the symbols (MinimalMuse.render()) to execute score-writing actions. MinimalMuse uses the same tagged text file format as ScoreManager or HTML (Listings 3 and 4).</p>		<p>MinimalMuse is a very simple grammar. More sophisticated ones include the Java compiler that rewrites source code &quot;java&quot; files into object code &quot;class&quot; files; the Java virtual machine that interprets object code &quot;class&quot; files to execute computational actions; and Csound itself, which has one parser for orchestra files and another parser for score files, and executes opcode actions to compile soundfiles.</p>		<p>Using MinimalMuse, a two-cell phase canon at the unison can be written as shown in Listing 3. Cell0 is the basic motive. Cell1 simply repeats cell0. Cell2 repeats cell0 also, but adds a rest after each repetition. The axiom generates notes by means of Cell1 , then goes back to the beginning of the score and repeats notes using Cell12. This creates phasing.</p>		<h4>Listing 3.</h4>		<pre>&amp;ltCsMinMuse&gt;&amp;ltCsAxiom&gt;push instrument 1 cell1 pop instrument 2 cell2&lt;/CsAxiom&gt;&amp;ltCsRules&gt;cell0 = note transpose 2 note transpose 14 note tempo 2 transpose 7 note transpose -6 note tempo .5 transpose -6 note transpose 3 note rest transpose -2 note transpose 12 transpose -3 note transpose -3 note transpose -3 note transpose -3 note note transpose -12 note rest notecell1 = cell0 cell0 cell1cell2 = cell0 rest cell0 rest cell2&lt;/CsRules&gt;&amp;ltCsIterations 12&gt;&lt;/CsMinMuse&gt;</pre>		<p>A more elaborate example is shown in MinMuse1 (Listing 4), which can be found on the CD-ROM:</p>		<h4>Listing 4.</h4>		<pre>&amp;lt;CsMinMuse&amp;gt;&amp;lt;CsAxiom&amp;gt; length .75 push tempo .5 cell6 pop transpose 5 cell6 cell6&amp;lt;/CsAxiom&amp;gt;&amp;lt;CsRules&amp;gt;cell6 = push push push instrument 1 pan -.5 cell5 pop transpose -12 intrument 3 pan 0 cell4 pop instrument 2 pan .5 cell4 pop transpose -12 instrument 3 cell5 transpose 12cell5 = cell3 transpose 6 rest cell5 transpose -6 cell3cell4 = cell3 transpose 6 advance 1.25 cell4 transpose -6 cell3cell3 = cell1 advance .375 transpose 3 cell1 transpose -3 cell3cell2 = cell1 transpose -5 cell1 transpose 5 note cell2cell1 = cell0 transpose 2 rest cell0 dynamics 0.9090909090909 transpose -2 cell0 transpose -5 dynamics 1.1 note transpose 5 note restcell0 = note transpose 12 transpose -4 note rest dynamics 2 transpose 2 note transpose -5 note note dyanmics .5 transpose -5 note rest&amp;lt;/CsRules&amp;gt;&amp;lt;CsIterations 7&amp;gt;&amp;lt;/CsMinMuse&amp;gt;</pre>		<p>This piece contains a hierarchy of relationships, which were chosen by trying a variety of cells and assembly techniques and listening to the results. The basic cell is cell0, a very simple and boring little motive. Cell1 assembles a series of cell0s and adds a note. Cell2 assembles a series of cell1s and adds a note, then specifies itself; this has the effect of invoking a repeat of cell1 for every iteration of the generator. cell3 is identical to cell2, except that the series of cell1s is in a different pitch relationship, and the second repeat is offset by .375 seconds; this causes cell2 and cell3, should they play simultaneously, to go out of phase and return to phase. Cell4 and cell5 assemble repeats of cell3s with a tempo change at the repeat and another time offset; this too causes phasing at a higher level of structure. Cell6 assembles several cell5s at different stereo positions and instrument selections using push and pop; they cause each cell5 to start at the same instant, after which their elements begin to go in and out of phase. Finally, the axiom assembles several cell6s at the highest level of structure. One cell6 plays once at half tempo, and cell6 also plays twice at normal tempo during the same period. Seven iterations of the generator produce 6,144 notes.</p>		<p><embed src="minmuse1.mp3" width="300" height="45" align="bottom" autoplay="false"></p>		<p><a href="minmuse1.mp3">MinMuse1.mp4</a></p>		<h3>Conclusion</h3>		<p>The esthetic and compositional conclusions to be drawn from this hasty plunge into score generation are perhaps few, but I do not believe they are either vague or trivial. In the first place, by resorting to mathematics in general and chaos in particular, algorithms can easily be made to generate a truly limitless variety of scores that no one could otherwise imagine. Some algorithms can in principle generate any possible score (Gogins 1992b).</p>		<p>The problem with algorithmic composition is not lack of talent or imagination, or even of skill, but surfeit of material. Furthermore, there is no algorithm that can be relied upon to weed through this mass of material.</p>		<p>Therefore the methods used to actually compose with score generators are not the same as with through-composed music (which is far from uniform in method itself). Parametric composition is one possibility. Trial and error, leading to familiarity and skill with one algorithm or a related family of algorithms, is another. Languages designed specifically for composing are also promising, especially as they can be used to gain very precise control over pitch relationships, which are definitely a weak point in other algorithms.</p>		<p>With fractal music in particular, the compositional process is a more like sculpture, or better yet photography, than it is like writing a narrative, which has been one naive metaphor for the act of composing. With a fractal, the composer has a form, an object, which he or she may circle, poke at, magnify, twist, or otherwise try to obtain a rewarding musical perspective upon. Most people who give themselves to this art will discover that, at a certain point, a piece becomes interesting; after working with an interesting pice for a time, it may (sometimes quite suddenly) become music. There was a harmony, a specifically musical justness of proportion, hidden in the form, that the work of the musician brought to sound.</p>		<p>Should a score that has been generated by an algorithm be treated as material for to be edited and reworked on paper, or combined with manually composed material? Or if a score is not satisfactory as it stands, is it better to change the parameters, or the algorithm itself, and regenerate the score as a whole? This is not a matter to be decided dogmatically. Yet, for me, a compelling reason to use score generators is that their algorithms impose a certain formal unity upon the scores. This unity is all too easy to break with editing.</p>		<h3>Some Notes on Instrument Design for Score Generators</h3>		<p>Csound is not just a software synthesizer, it is a language for writing software synthesizers (Vercoe 1984). It can sound as good as, or better than, the best hardware. An excellent source of Csound instruments is Gather (1995), and The Csound Front Page (Leeds University 1996) has links to other instrument and orchestra samples.</p>		<p>The usual practice is to make instruments that are exactly suited to the requirements of a particular score. This approach is completely valid, but it is not best for the kind of algorithmic composition discussed here. That requires instruments which can be mixed and matched to create ad hoc arrangements. To this end, I have defined the following convention for instruments and scores:</p>		<ul>			<li>p1 = instrument number (1 to 200)			<li>p2 = start time in seconds (0 to whatever)			<li>p3 = length in seconds (0 to whatever)			<li>p4 = linear octave (middle C = 8)			<li>p5 = decibels (0 to 84)			<li>p6 = pan (-1 extreme left through 0 at middle to +1 extreme right)		</ul>		<p>Additional pfields required by an instrument start with p7. Using this convention, any instrument can be used with any score. In addition, instruments for score generators should work over a wide range of pitches, over a wide range of durations, over a wide range of dynamic levels, and be dynamically balanced, that is, they should produce the same subjective loudness for the same numerical loudness in the score. The most important considerations are duration and balance.</p>		<p>An instrument has a characteristic timbre that is crucially defined by its attack and decay transients. However, a score generator may well produce notes shorter than these transients. Those notes will sound as nasty clicks in the soundfile. To avoid this, write instruments that fix pfield 3, duration, if it is too short. Csound will read the new value of p3 and extend the note beyond the scored duration. For example:</p>		<pre>isustain = p3 - (iattack + idecay + irelease)if isustain &gt; 0 goto longenvelopeisustain = 0p3 = iattack + idecay + isustain + ireleaselongenvelope:</pre>		<p>As for balance, the ampdb function in Csound returns an amplitude of 15,848.926 for 80 decibels. A start can be made on balancing an instrument by compiling a note at 80 decibels and recording the amplitude actually synthesized. The instrument can then be normalized using the equation</p>		<pre>iamplitude = ampdb(p5) * 15848.926 / iamplituderecorded</pre>		<p>However, balance often needs to be refined by trial and error. For this purpose, instruments can be tested with a short score that contains one long tone at 80 decibels in each octave from 6 to 12, a sequence of notes over wide range of pitches, durations, and dynamics, and notes shorter than any transient. Certain timbres work better with score generators than others. In general, neither tones that are always short nor those that are always sustained work well, but tones with distinctive attacks and long decays (like the piano, the general-purpose instrument par excellence) tend to be useful. Similarly, tones that are too simple in overtone structure sound poor in solo, but tones too busy in overtone structure sound awful in tutti.</p>		<p>All such considerations are of course merely suggestions arising from experience. The imagination and, above all, the ear must rule.</p>		<h3>Additional Resources</h3>		<p>For a general survey of algorithmic composition, read chapters 17, 18, and 19 in The Computer Music Tutorial (Roads 1996), and search the World Wide Web. For an annotated catalog of compositional algorithms, see Coenen (1994). For an annotated catalog of available score generating software, see Hepis (1993). For a discography of computer music including many algorithmic compositions, see Pope (1993). Two leading software systems for score generation are Common Music (Taube 1996) and Symbolic Composer (Stone 1997). The hardware-software system Capybara/Kyma must also be noted (Symbolic Sound Corporation 1997).</p>		<p>Java is available for free on the Internet (Sun Microsystems 1997, EarthWeb 1997), and often comes on the CD-ROMs included with books on Java. The Java samples in this chapter were tested with Microsoft Visual J++ and Version 1.0 of Java, and also with Symantec Visual Caf&eacute; version 1.0.</p>		<h3>References Cited</h3>		<p>Barnsley, Michael. 1993 [1998]. <i><b>Fractals Everywhere</b></i>, Second Edition. Boston: Academic Press. Textbook on fractal geometry that provides a unified mathematical treatment of iterated function systems, Julia and Mandelbrot sets, and fractals. Invaluable resource for the geometric approach to algorithmic composition.</p>		<p>Buchner, A. 1978. <i><b>Mechanical Musical Instruments</b></i>. Westport: Greenwood Press. Cage, John. 1973 [1961]. Silence: Lectures and Writings by John Cage. Hanover, New Hampshire: Wesleyan University Press. A vital resource.</p>		<p>Cage, John. 1992 [1961-1962]. &quot;Atlas Eclipticalis,&quot; for flutes, piccolo, bass clarinet, contrabassoon, trombone, contrabass. The Barton Workshop Performs John Cage, Etcetera 2 KTC 3002, CD.</p>		<p>Cage, John, and Lejaren Hiller. 1969 [1968-1969]. <i><b>HPSCHD</b></i>. Nonesuch H-71224, LP.</p>		<p>Chaitin, Gregory J. 1974a. &quot;Information-Theoretic Limitations of Formal Systems,&quot; <i><b>Journal of the Association for Computing Machinery</b></i>, Volume 21, pp. 403-424.</p>		<p>Chaitin, Gregory J. 1974b. &quot;Randomness and Mathematical Proof,&quot; <i><b>Scientific American</b></i>, Volume 232, Number 5, pp. 47-52.</p>		<p>Chomsky, Noam. 1957. <i><b>Syntactic Structures</b></i>. The Hague: Mouton. The first influential scientific theory (of the syntax of natural langauges) cast in the form of a generative grammar.</p>		<p>Coenen, Alcedo. 1994. <i><b>Amsterdam Catalogue of Composition Algorithms</b></i> (http://mars.let.uva.nl/ACCA/ACCA.html).</p>		<p>Cope, David. 1989. &quot;The Step by Step Simulation of a Mozart Sonata,&quot; in <i><b>Proceedings of the European Workshop on Artificial Intelligence and Music</b></i>. Genoa: Computer Music Laboratory, University of Genoa.</p>		<p>DaGazio, Bruno. No date. <i><b>Nikola Tesla and Joseph Schillinger: The Music of NT: The Man Who Invented the Twentieth Century</b></i> (http://www-ks.rus.uni-stuttgart.de/people/schulz/fmusic/tesla.html).</p>		<p>Davis, Martin (editor). 1965. <i><b>The Undecidable: Basic Papers on Undecidable Propositions, Unsolvable Problems and Computable Functions</b></i>. Hewlett, New York: Raven Press.</p>		<p>Dodge, Charles. 1986. &quot;Musical Fractals,&quot; <i><b>Byte Magazine</b></i>, Volume 11, Number 6, pp. 185-196.</p>		<p>Dodge, Charles., 1988. &quot;Profile: A Musical Fractal,&quot; <i><b>Computer Music Journal</b></i>, Volume 12, Number 3, pp. 10-14.</p>		<p>Earthweb. 1997. <i><b>Gamelan: The Official Directory for Java</b></i> (http://www-b.gamelan.com/index.shtml).</p>		<p>Evans, Brian. 1995. <i><b>Hearing the Mandelbrot Set</b></i> (http://www.vanderbilt.edu/VUCC/Misc/Art1/Sonify/Mandi.html).</p>		<p>Feigenbaum, M. J. &quot;Universal Behavior in Nonlinear Systems,&quot; <i><b>Physica</b></i> 7D, pp. 16-39.</p>		<p>Gather, John-Philipp. 1995. <i><b>Amsterdam Catalog of Csound Computer Instruments 1.1</b></i>. An extremely useful compendium of working Csound implementations of classical computer music instrument designs.</p>		<p>Giffin, Noel. 1997. <i><b>Welcome to the Fractint WWW Pages</b></i> (http://spanky.triumf.ca/www/fractint/fractint.html).</p>		<p>Greenhouse, Robert. 1995. <i><b>The Well-Tempered Fractal v3.0: A Composer's Tool for the Derivation of Musical Motifs, Phrases and Rhythms From The Beauty and Symmetry of Fractals, Chaotic Attractors and Other Mathematical Functions</b></i> (http://www-ks.rus.uni-stuttgart.de/people/schulz/fmusic/wtf/). A fractal composing program for IBM compatible PCs.</p>		<p>Gogins, Michael. 1991. &quot;Iterated Function Systems Music,&quot; <i><b>Computer Music Journal</b></i>, Volume 15, Number 1, pp. 40-48.</p>		<p>Gogins, Michael. 1992a. &quot;Fractal Music with String Rewriting Grammars,&quot; <i><b>News of Music 13</b></i>, pp. 146-170.</p>		<p>Gogins, Michael. 1992b. &quot;How I Became Obsessed with Finding a Mandelbrot Set for Sounds,&quot; <i><b>News of Music 13</b></i>, pp. 129-139.</p>		<p>Hepis, Leonidas. 1993. <i><b>List of Tools</b></i> (http://mars.let.uva.nl/ACCA/ACCA.ToolsList.html). An extensive annotated list of software for algorithmic composition.</p>		<p>Hiller, Lejaren. 1970. &quot;Music Composed with Computers - A Historical Survey,&quot; in H. Lincoln (editor), <i><b>The Computer and Music</b></i>. Ithaca: Cornell University Press pp. 42-96.</p>		<p>Hiller, Lejaren and John Cage. 1968. &quot;HPSCHD: An Interview by Larry Austin,&quot; <i><b>Source</b></i>, Volume 2, Number 2, pp. 10-19.</p>		<p>Hiller, Lejaren Arthur, and L. M. Isaacson. 1957a. <i><b>Illiac suite, for String Quartet</b></i>. New York: New Music Edition.</p>		<p>Hiller, Lejaren Arthur, and Isaacson. 1957b. <i><b>Illiac suite, for String Quartet</b></i>. Heliodor HS 25053, LP.</p>		<p>Hiller, Lejaren and Isaacson, L. M. (editors). 1959. <i><b>Experimental Music: Composition with an Electronic Computer</b></i>. New York: McGraw-Hill.</p>		<p>Holtzman, S.R. 1981. &quot;Using Generative Grammars for Music Composition,&quot; <i><b>Computer Music Journal</b></i>, Volume 5, Number 1, pp. 51-64.</p>		<p>Huron, David. 1996. <i><b>The Humdrum Toolkit: Software for Music Research </b></i>(http://ccrma-www.stanford.edu/CCRMA/Events/Colloquium/Past/94-11-30.html). The Humdrum Toolkit is a set of (UNIX-based) software tools for music research. For those who are interested, an extensive FAQ (Frequently Asked Questions) document for the Humdrum Toolkit is available via ftp (archive@uwaterloo.ca cd uw-data/humdrum) or by sending an e-mail request to dhuron@ccrma.</p>		<p>Leeds University. 1996. <i><b>The Csound Front Page </b></i>(http://www.leeds.ac.uk/music/Man/c_front.html). The main Web entry point for Csound, including up-to-date builds of public-domain Csound for many platforms, and links to tutorials and samples.</p>		<p>Lerdahl, F., and R. Jackendoff. 1983. <i><b>A Generative Theory of Tonal Music</b></i>. Cambridge, Massachusetts: The MIT Press.</p>		<p>Li, T-Y, and Yorke, J.A. 1985. &quot;Period Three Implies Chaos,&quot; <i><b>American Mathematical Monthly</b></i>, Volume 82, pp. 985-992.</p>		<p>Lyr, R. 1955. &quot;Une merveille de cecanisme: le Componium de T. N. Winkel,&quot; in A. Chapuis (editor). <i><b>Histoire de la boite a musique</b></i>. Lausanne: Edition Scriptar.</p>		<p>Mandelbrot, Benoit. 1983 [1977]. <i><b>The Fractal Geometry of Nature </b></i>(Updated and Augmented). New York: W. H. Freeman and Company. Seminal work on fractals in many fields of science and art.</p>		<p>Mertens, Wim. 1983 [1980]. <i><b>American Minimal Music: La Monte Young, Terry Riley, Steve Reich, Philip Glass</b></i>, translated from the Dutch by J. Hautekiet with a preface by Michael Nyman. London: Kahn and Averill; New York: Alexander Broude.</p>		<p>Millen, Dale. 1990. &quot;Cellular Automata Music,&quot; in <i><b>Proceedings of the 16th International Computer Music Conference</b></i>, Glasgow. San Francisco: International Computer Music Association, p. 314-316.</p>		<p>Mucherino, Nicholas. No date. <i><b>Recursion: A Paradigm for Future Music? </b></i>(http://www-ks.rus.uni-stuttgart.de/people/schulz/fmusic/recursion.html).</p>		<p>Nelson, Gary Lee. 1993. <i><b>Wind, Sand, and Sea Voyages: An Application of Granular Synthesis and Chaos to Musical Composition </b></i>(http://www-ks.rus.uni-stuttgart.de/people/schulz/fmusic/gnelson.html)</p>		<p>Nyman, Michael. 1974. <i><b>Experimental Music: Cage and Beyond</b></i>. London: Studio Visa</p>		<p>Olson, H. and H. Belar. 1961. &quot;Aid to Music Composition System Employing a Random Probability System,&quot; <i><b>Journal of the Acoustic Society of America</b></i>, Volume 33, pp. 1163-1170.</p>		<p>Ord-Hume, A. W. J. G. 1973. <i><b>Clockwork Music</b></i>. New York: Crown Publishers.</p>		<p>Peitgen, Heinz-Otto, Hartmut J&uuml;rgens, and Dietmar Saupe. 1990. &quot;The Language of Fractals,&quot; <i><b>Scientific American</b></i>, August 1990, pp. 11-20.</p>		<p>Peitgen, Heinz-Otto, Hartmut J&uuml;rgens, and Dietmar Saupe. 1992. <i><b>Chaos and Fractals: New Frontiers of Science</b></i>. New York: Springer-Verlag, 1992. Probably the best general introduction to the field, with sample code for realizing a wide variety of fractals. Provides a unifying metaphor for fractal algorithms in the form of the &quot;multiple reduction copying machine.&quot;</p>		<p>Pope, Stephen Travis. 1993. &quot;An Incomplete Diskography of Computer Music,&quot; <i><b>Computer Music Journal</b></i>, Volume 17, Number 4, pp. 5-10.</p>		<p>Pressing, J., 1988. &quot;Nonlinear Maps as Generators of Musical Design,&quot; <i><b>Computer Music Journal</b></i>, Volume 12, Number 2, pp. 35-46.</p>		<p>Prieberg, F. 1975. <i><b>Musica ex Machina</b></i>. Italian edition. Turin: Giulio Einaudi Editore.</p>		<p>Prusinkiewicz, Przemyslaw and Aristid Lindenmayer. 1990. <i><b>The Algorithmic Beauty of Plants</b></i>. New York: Springer-Verlag. An important, indeed inspiring, use of a generative grammar as a theory of plant growth. My Lindenmayer system composing grammar is based on concepts developed in this book.</p>		<p>Riley, Terry. 1989 [1964]. <i><b>In C</b></i>. Celestial Harmonies.</p>		<p>Roads, Curtis. 1978. <i><b>Composing Grammars</b></i>. San Francisco: International Computer Music Association.</p>		<p>Roads, Curtis (editor). 1985. <i><b>Composers and the Computer</b></i>. Madison: A-R Editions.</p>		<p>Roads, Curtis. 1985. &quot;Grammars as Representations for Music,&quot; in C. Roads and J. Strawn (editors), <i><b>Foundations of Computer Music</b></i>. Cambridge, Massachusetts: The MIT Press, pp 403-442.</p>		<p>Roads, Curtis Roads with John Strawn, Curtis Abbott, John Gordon, and Philip Greenspun. 1996. <i><b>The Computer Music Tutorial</b></i>. Cambridge, Massachusetts: The MIT&nbsp;Press. Currently the best one-volume introduction to computer music.</p>		<p>Schillinger, Joseph. 1946 [1941]. <i><b>The Schillinger System of Musical Composition</b></i>. New York: C. Fischer, Inc.</p>		<p>Schillinger, Joseph. 1948. <i><b>The Mathematical Basis of the Arts</b></i>. New York: Philosophical Library.</p>		<p>Scholes, P. 1975. <i><b>The Oxford Companion to Music</b></i>. London: Oxford University press.</p>		<p>Schulz, Claus-Dieter. No date. <i><b>Welcome to the Fractal Music Project </b></i>(http://www-ks.rus.uni-stuttgart.de/people/schulz/fmusic/index.html). Gathers some other WWW fractal music resources.</p>		<p>Scott, Raymond. 1992. <i><b>Reckless Nights and Turkish Twilights: The Music of Raymond Scott</b></i>. Produced by Irwin Chusid, with notes by Irwin Chusid. Columbia Records 53028, CD.</p>		<p>Stone, Peter. 1997. <i><b>Symbolic Composer 4.0 - Now Shipping!</b></i> (http://www.xs4all.nl/~psto/). A Macintosh-based algorithmic composition environment with many score generators and plugin modules.</p>		<p>Sun Microsystems Inc. 1997. <i><b>Javasoft Home Page </b></i>(http://java.sun.com/).</p>		<p>Symbolic Sound Corporation. 1997. <i><b>Symbolic Sound Corporation </b></i>(http://www.symbolicsound.com/). Manufactures a hardware-DSP based system with its own Kyma language for algorithmic synthesis and composition.</p>		<p>Taube, Heinrich. 1996. <i><b>Common Music </b></i>(http://ccrma-www.stanford.edu/CCRMA/Overview/node25.html). A widely used LISP composing environment that runs on most platforms.</p>		<p>Vercoe, Barry. 1984. &quot;CSound: A Manual for the Audio Processing System and Supporting Programs with Tutorials.&quot; Cambridge, Massachusetts: Media Lab, MIT. The user&#146;s guide and reference manual for CSound. An essential resource, too bad it&#146;s out of date and lacks documentation for new opcodes.</p>		<p>Voss, R.F. and J.R. Clarke. 1978. &quot;1/f Noise in music: Music from 1/f noise,&quot; <i><b>Journal of the Acoustical Society of America</b></i>, Volume 63, Number 1, pp. 258 - 263.</p>		<p>Xenakis, Iannis. 1992. <i><b>Formalized Music: Thoughts and Mathematics in Music</b></i>, Revised Edition. Additional material compiled and edited by Sharon Kanach. Harmonologia Series No. 6. Stuyvesant, New York: Pendragon Press. Great book which intellectually grounds the formal, mathematical approach to musical composition. Highly relevant to algorithmic composition and granular synthesis. Warburton, Dan. 1988. &quot;A Working Terminology for Minimal Music,&quot; <i><b>Integral</b></i>, Volume 2, pp. 135-159.</p>		<h3>Appendix A. LogMuse in QBASIC</h3>		<pre>' L O G M U S E' A simple algorithmic score generator for Csound in QuickBASIC.' Michael Gogins' 21 January 1997' Variables for the generator.DIM c AS DOUBLEDIM y AS DOUBLEDIM y1 AS DOUBLEDIM i AS INTEGERDIM n AS INTEGER' Variables for music.' The dimensions that are not generated have default values.DIM instrument AS DOUBLEinstrument = 1#DIM start AS DOUBLEDIM length AS DOUBLElength = 2#DIM octave AS DOUBLEDIM decibels AS DOUBLEdecibels = 70#DIM pan AS DOUBLEpan = 0#' Mapping coefficients.DIM pulse AS DOUBLEpulse = .25#DIM bass AS DOUBLEbass = 6#DIM range AS DOUBLErange = 4#' Variables for rendering the score.DIM file AS INTEGER' You can paste a Csound instrument definition right into BASIC code like this.DIM orchestra AS STRINGorchestra = &quot;sr = 44100&quot; + CHR$(10)orchestra = orchestra + &quot;kr = 44100&quot; + CHR$(10)orchestra = orchestra + &quot;ksmps = 1&quot; + CHR$(10)orchestra = orchestra + &quot;nchnls = 2&quot; + CHR$(10)orchestra = orchestra + &quot;&quot; + CHR$(10)orchestra = orchestra + &quot;; Frequency modulation instrument.&quot; + CHR$(10)orchestra = orchestra + &quot;instr 1&quot; + CHR$(10)orchestra = orchestra + &quot;; LOGGING&quot; + CHR$(10)orchestra = orchestra + &quot;; p1 = Instrument&quot; + CHR$(10)orchestra = orchestra + &quot;; p2 = Start&quot; + CHR$(10)orchestra = orchestra + &quot;; p3 = Length&quot; + CHR$(10)orchestra = orchestra + &quot;; p4 = Octave&quot; + CHR$(10)orchestra = orchestra + &quot;; p5 = Decibels&quot; + CHR$(10)orchestra = orchestra + &quot;; p6 = Pan&quot; + CHR$(10)orchestra = orchestra + &quot;print p2, p3, p4, p5, p6&quot; + CHR$(10)orchestra = orchestra + &quot;&quot; + CHR$(10)orchestra = orchestra + &quot;; INITIALIZATION&quot; + CHR$(10)orchestra = orchestra + &quot;iwavetable = 1&quot; + CHR$(10)orchestra = orchestra + &quot;imodulator = .5&quot; + CHR$(10)orchestra = orchestra + &quot;ifmamplitude = 1&quot; + CHR$(10)orchestra = orchestra + &quot;index = 1.375&quot; + CHR$(10)orchestra = orchestra + &quot;iattack = .025&quot; + CHR$(10)orchestra = orchestra + &quot;irelease = .125&quot; + CHR$(10)orchestra = orchestra + &quot;isustain = p3 - (iattack + irelease)&quot; + CHR$(10)orchestra = orchestra + &quot;if isustain &gt; 0 goto longenvelope&quot; + CHR$(10)orchestra = orchestra + &quot;isustain = 0.03&quot; + CHR$(10)orchestra = orchestra + &quot;p3 = iattack + isustain + irelease&quot; + CHR$(10)orchestra = orchestra + &quot;longenvelope:&quot; + CHR$(10)orchestra = orchestra + &quot;ifrequency = cpsoct(p4)&quot; + CHR$(10)orchestra = orchestra + &quot;icarrier = .998&quot; + CHR$(10)orchestra = orchestra + &quot;icarrierb = 1.002&quot; + CHR$(10)orchestra = orchestra + &quot;; Normalize to 80 dB = ampdb(80).&quot; + CHR$(10)orchestra = orchestra + &quot;iamplitude = ampdb(p5) * 15848.926 / 12729.0&quot; + CHR$(10)orchestra = orchestra + &quot;ileftpan = (0.5 - p6) / 2.0&quot; + CHR$(10)orchestra = orchestra + &quot;irightpan = (0.5 + p6) / 2.0&quot; + CHR$(10)orchestra = orchestra + &quot;&quot; + CHR$(10)orchestra = orchestra + &quot;; KONTROL&quot; + CHR$(10)orchestra = orchestra + &quot;kindenv expseg .00001, iattack, 1, isustain, .1, irelease, .00001&quot; + CHR$(10)orchestra = orchestra + &quot;kindex = kindenv * index * ifmamplitude&quot; + CHR$(10)orchestra = orchestra + &quot;&quot; + CHR$(10)orchestra = orchestra + &quot;; AUDIO&quot; + CHR$(10)orchestra = orchestra + &quot;aouta foscili iamplitude, ifrequency, icarrier, imodulator, kindex, iwavetable&quot; + CHR$(10)orchestra = orchestra + &quot;aoutb foscili iamplitude, ifrequency, icarrierb, imodulator, kindex, iwavetable&quot; + CHR$(10)orchestra = orchestra + &quot;afmout = (aouta + aoutb) * kindenv * 2.556&quot; + CHR$(10)orchestra = orchestra + &quot;outs ileftpan * afmout, irightpan * afmout&quot; + CHR$(10)orchestra = orchestra + &quot;endin&quot; + CHR$(10)' Buffer for writing note statements.DIM buffer AS STRINGc = .75#n = 100' Create a score file.file = FREEFILEOPEN &quot;test.sco&quot; FOR OUTPUT AS file' Initial value of y.y = .5#' Write the initial state of the system as a Csound comment.PRINT #file, &quot;; Hello Csound!&quot;PRINT #file, &quot;; c = &quot; + STR$(c)PRINT #file, &quot;; y = &quot; + STR$(y)PRINT #file, &quot;; n = &quot; + STR$(n)' GENERATE THE SCORE' Write the function table for the instrument.PRINT #file, &quot;f 1 0 16384 10 1 ; High-fidelity sine wave.&quot;' Iterate to write the notes.FOR i = 1 TO n	' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' '	' GENERATION	y1 = y * c * 4# * (1# - y)	' MAPPING	start = i * pulse	octave = bass + y1 * range	' Round off to 12 tone equal temperament.	octave = INT(octave * 12# + 0.5#) / 12#	' RENDERING	' Write a note into the Csound score.	PRINT #file, USING &quot;i #####.###### #####.###### #####.###### #####.###### ####.###### #####.######&quot;; instrument; start; length; octave; decibels; pan	' Iterate.	y = y1	' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' ' 'NEXTCLOSE #file' RENDER THE SOUNDFILE' Write the orchestra file.file = FREEFILEOPEN &quot;test.orc&quot; FOR OUTPUT AS filePRINT #file, orchestraCLOSE #file' Render the generated files using Csound.SHELL &quot;Csound -WsRo test.wav test.orc test.sco&quot;' PLAY THE SOUNDFILESHELL &quot;MPLAYER test.wav&quot;</pre>		<h3>Appendix B. LogMuse in ANSI C</h3>		<pre>//	L O G M U S E//	A simple algorithmic score generator for Csound in ANSI C.//	Michael Gogins//	21 January 1997//	Almost all C programs include these header files.#include <stdlib.h>#include <stdio.h>//	All C console programs have a main() function.int main(int argc, const char *argv[], const char *envp[]){	// Variables for the generator.	double c;	double y;	double y1;	int i;	int n;	// Variables for music.	// The dimensions that are not generated have default values.	double instrument = 1;	double start;	double length = 2;	double octave;	double decibels = 70;	double pan = 0;	// Mapping coefficients.	double pulse = .25;	double bass = 6;	double range = 4;	// Variables for rendering the score.	FILE *file;	// You can paste a Csound instrument definition right into C code like this.	char orchestra[] =		&quot;sr = 44100\n&quot;		&quot;kr = 44100\n&quot;		&quot;ksmps = 1\n&quot;		&quot;nchnls = 2\n&quot;		&quot;\n&quot;		&quot;; Frequency modulation instrument.\n&quot;		&quot;instr 1\n&quot;		&quot;; LOGGING\n&quot;		&quot;; p1 = Instrument\n&quot;		&quot;; p2 = Start\n&quot;		&quot;; p3 = Length\n&quot;		&quot;; p4 = Octave\n&quot;		&quot;; p5 = Decibels\n&quot;		&quot;; p6 = Pan\n&quot;		&quot;print p2, p3, p4, p5, p6\n&quot;		&quot;\n&quot;		&quot;; INITIALIZATION\n&quot;		&quot;iwavetable = 1\n&quot;		&quot;imodulator = .5\n&quot;		&quot;ifmamplitude = 1\n&quot;		&quot;index = 1.375\n&quot;		&quot;iattack = .025\n&quot;		&quot;irelease = .125\n&quot;		&quot;isustain = p3 - (iattack + irelease)\n&quot;		&quot;if isustain &gt; 0 goto longenvelope\n&quot;		&quot;isustain = 0.03\n&quot;		&quot;p3 = iattack + isustain + irelease\n&quot;		&quot;longenvelope:\n&quot;		&quot;ifrequency = cpsoct(p4)\n&quot;		&quot;icarrier = .998\n&quot;		&quot;icarrierb = 1.002\n&quot;		&quot;; Normalize to 80 dB = ampdb(80).\n&quot;		&quot;iamplitude = ampdb(p5) * 15848.926 / 12729.0\n&quot;		&quot;ileftpan = (0.5 - p6) / 2.0\n&quot;		&quot;irightpan = (0.5 + p6) / 2.0\n&quot;		&quot;\n&quot;		&quot;; KONTROL\n&quot;		&quot;kindenv expseg .00001, iattack, 1, isustain, .1, irelease, .00001\n&quot;		&quot;kindex = kindenv * index * ifmamplitude\n&quot;		&quot;\n&quot;		&quot;; AUDIO\n&quot;		&quot;aouta foscili iamplitude, ifrequency, icarrier, imodulator, kindex, iwavetable\n&quot;		&quot;aoutb foscili iamplitude, ifrequency, icarrierb, imodulator, kindex, iwavetable\n&quot;		&quot;afmout = (aouta + aoutb) * kindenv * 2.556\n&quot;		&quot;outs ileftpan * afmout, irightpan * afmout\n&quot;		&quot;endin\n&quot;;	//	Try to read c from the command line, otherwise use a default.	if(argc &gt; 1)	{		c = atof(argv[1]);	}	else	{		c = .9;	}	//	Try to read n from the command line, otherwise use a default.	if(argc &gt; 2)	{		n = atoi(argv[2]);	}	else	{		n = 100;	}	// Create a score file.	file = fopen(&quot;test.sco&quot;, &quot;w+&quot;);	// Initial value of y.		y = .5;	// Write the initial state of the system as a Csound comment.	fprintf(file, &quot;; Hello Csound!\n; c = %g\n; y = %g\n; c = %d\n&quot;, c, y, n);	// GENERATE THE SCORE	// Write the function table for the instrument.	fprintf(file, &quot;f 1 0 16384 10 1 ; High-fidelity sine wave.\n&quot;);	// Iterate to write the notes.	for(i = 0; i &lt; n; ++i)	{		//////////////////////////////////////////////////////		// GENERATION		y1 = y * c * 4 * (1.0 - y);		// MAPPING		start = i * pulse;		octave = bass + y1 * range;		// Round off to 12 tone equal temperament.		octave = ((int)(octave * 12.0 + .5)) / 12.0;		// RENDERING		// Write a note into the Csound score.		fprintf(file, &quot;i %0.9g %0.9g %0.9g %0.9g %0.9g %0.9g\n&quot;, instrument, start, length, octave, decibels, pan);		// Iterate.		y = y1;		//////////////////////////////////////////////////////	}	fclose(file);	// RENDER THE SOUNDFILE	// Write the orchestra file.	file = fopen(&quot;test.orc&quot;, &quot;w+&quot;);	fprintf(file, orchestra);	fclose(file);	// Render the generated files using Csound.	system(&quot;Csound -WsRo test.wav test.orc test.sco&quot;);	// PLAY THE SOUNDFILE	system(&quot;MPLAYER test.wav&quot;);	return 0;}</pre>		<h3>Appendix C. Fractal Music</h3>		<p>The logistic equation was discovered early on in chaotic dynamics and fractal geometry. These fields have since enjoyed an explosive elaboration. Composers have turned to them as a source of material, or even of complete compositions. Not only the logistic equation (Nelson 1993, Pressing 1988), but also 1/f noise (Voss and Clarke 1978), the Koch curve (Dodge 1986, 1988), the Henon attractor (Greenhouse 1995), cellular automata (Millen 1990), Lindenmayer systems (Gogins 1992a, Mucherino), the Mandelbrot set (Evans 1995, Gogins 1992b), and iterated function systems (Gogins 1991) have been used (the references are exemplary only and quite incomplete). This is a broad subject that, again, is far beyond the scope of the present chapter. Of course Mandelbrot (1983) is a classic; an excellent introduction to the mathematics can be found in Pietgen, J&uuml;rgens, and Saupe (1992); a more rigorous treatment is in Barnsley (1993). There are many fractal music sites on the Web. The Fractal Music Project is a good start (Schulz, no date).</p>		<p>Rather than illustrate a mere one or two fractal score generators, the following presents GrafMuse, a Java program that translates graphical images into Csound scores (Applet C-1). Fractal generating programs save images of their fractals, so such a program, like the excellent public-domain FRACTINT (Giffin 1997), as can be used as the generator proper. GrafMuse can then be used for mapping the saved image onto music and rendering it with Csound. In other words, using FRACTINT (or other fractal generator) with GrafMuse, you can make music using any fractal you like.</p>		<h4>Applet C-1. Graphics to Music Translator.</h4>		<p><br>		<applet code="GoginsChapters.ScoreGenerators.GrafMuse.GrafMuse.class" width="765" height="408" align="bottom">		</applet></p>		<h4><a href="GrafMuse.bat">Graphics to Music Translator in Standalone Mode.</a></h4>		<p>GrafMuse&#146;s rendering algorithm maps the &lt;x, y, hue, brightness&gt; dimensions of an image onto the &lt;time, octave, instrument, decibels&gt; dimensions of a score. Of course, if each pixel in the image were translated into a note, the score might be far too busy. Therefore, the image may be filtered for brightness, and only the brightest features rendered as notes.</p>		<p>One drawback of this method is that the rendering is somewhat approximate and is greatly affected by the colors in the image. And of course the composer must have at least a vague notion of how the images will be rendered, and how the piano-roll scores will sound. This can be developed through practice. On the other hand, an advantage of the method is its sheer speed. Dozens of images and trial renderings can be created in a single working session. A better advantage is the sheer richness and strangeness of the forms. This is the real reason for using fractals.</p>		<p>The rest of this section assumes that you have FRACTINT, and demonstrates how to translate fractals into music.<br>		<br>		<img src="GoginsChapters/ScoreGenerators/GrafMuse/FRACT013.GIF" width="1024" height="768" align="BOTTOM" border="0"></p>		<h4>Figure C-1.</h4>		<p>Figure C-1 shows a twisted magnification of the the attractor of a Martin type fractal. The generating equation is:</p>		<pre>x1 = y - sin(x);y1 = a - x;x = x1;y = y1;</pre>		<p>The shape of the attractor depends upon a, which in this case is 3.1 A number of trial renderings were made. In the end, I chose to use 33-tone equal temperament and an orchestra of 5 instruments to create a 4 minute soundfile. I also doubled the lengths of the notes. The complete FRACTINT parameter file is given in Listing C-1.</p>		<h4>Listing C-1.</h4>		<pre>Martin { reset=1950 type=martin center-mag=-5.50538/-3.62973/0.1232742/1/-17.5 params=3.1 float=y maxiter=32000 inside=0 colors=00000e0e00eee00e0eeL0eeeLLLLLzLzLLzzzLLzLzzzLzzz000555&lt;3&gt;HHHKKKOO\ OSSSWWW___ccchhhmmmssszzz00z&lt;3&gt;z0z&lt;3&gt;z00&lt;3&gt;zz0&lt;3&gt;0z0&lt;3&gt;0zz&lt;2&gt;0GzVVz&lt;3&gt;zV\ z&lt;3&gt;zVV&lt;3&gt;zzV&lt;3&gt;VzV&lt;3&gt;Vzz&lt;2&gt;Vbzhhz&lt;3&gt;zhz&lt;3&gt;zhh&lt;3&gt;zzh&lt;3&gt;hzh&lt;3&gt;hzz&lt;2&gt;hlz00\ S&lt;3&gt;S0S&lt;3&gt;S00&lt;3&gt;SS0&lt;3&gt;0S0&lt;3&gt;0SS&lt;2&gt;07SEES&lt;3&gt;SES&lt;3&gt;SEE&lt;3&gt;SSE&lt;3&gt;ESE&lt;3&gt;ESS&lt;2\ &gt;EHSKKS&lt;2&gt;QKSSKSSKQSKOSKMSKK&lt;2&gt;SQKSSKQSKOSKMSKKSK&lt;2&gt;KSQKSSKQSKOSKMS00G&lt;3\ &gt;G0G&lt;3&gt;G00&lt;3&gt;GG0&lt;3&gt;0G0&lt;3&gt;0GG&lt;2&gt;04G88G&lt;2&gt;E8GG8GG8EG8CG8AG88&lt;2&gt;GE8GG8EG8CG\ 8AG88G8&lt;2&gt;8GE8GG8EG8CG8AGBBG&lt;2&gt;FBGGBGGBFGBDGBCGBB&lt;2&gt;GFBGGBFGBDGBCGBBGB&lt;2\ &gt;BGFBGGBFGBDGBCGpQX&lt;2&gt;qSUqTTpTR000gUQ }</pre>		<p><img src="GoginsChapters/ScoreGenerators/GrafMuse/FRACT021.GIF" width="1024" height="768" align="BOTTOM" border="0"></p>		<h4>Figure C-2.</h4>		<p>FRACTINT contains its own formula parser, and Figure 2 shows an image generated using it. The generating equation is specified in a formula file (Listing C-2).</p>		<h4>Listing C-2.</h4>		<pre>Real portion of p1 100Imaginary portion of p1 0Real portion of p2 100Imaginary portion of p2 0First Function sinz = c = pixel, d = fn1(pixel), k = 1 + p1:z = z^c * k;z = d / z,|z| &lt;= (5 + p2)</pre>		<p>The other FRACTINT parameters are shown in Listing C-3.</p>		<h4>Listing C-3.</h4>		<pre>{ reset=1820 type=formula formulafile=gogins.frm formulaname=blinds function=sin corners=0.030942785962/0.024646585101/2.4617605813/2.4585704945/0.030207\ 395306/2.4627411022 params=100/0/100/0 float=y potential=255/300/0 colors=000C0M&lt;2&gt;60NB0BG00L00&lt;40&gt;a00a10b30&lt;2&gt;c91dC4&lt;44&gt;ST0RU0RT0SS0TR0UQ0\ VP1&lt;2&gt;XM6Yb7&lt;15&gt;kNYlL_lM_&lt;26&gt;cqFbsEbrE&lt;15&gt;WP1WO0WM0VK0&lt;7&gt;S50R30R30&lt;12&gt;K9\ 0KA1JA1JB2IB3&lt;27&gt;3PM&lt;8&gt;ga3kc1pd0uf0uf0te0sdL&lt;6&gt;mZUI0MG0ME0M }</pre>		<p>Because of its regularity, I rendered this image using a chiming, shifting wash of sounds. It was necessary to rotate carefully through the colors of the image in order to achieve a palette that would cause the image to be rendered with neither too many nor too few notes.</p>		<p><embed src="fract021.mp3" width="300" height="45" align="bottom" autoplay="false"></p>		<h3><a href="fract021.mp3">Fractal021.mp3</a></h3>		<h3>Appendix D. References Consulted</h3>		<p>The following references are garnered not only from my own reading but also from many other sources as well. I have appended notes on some that I myself have found most useful. The focus is on algorithmic composition (primarily) and synthesis (secondarily), with an emphasis on non-real-time, software-only systems. Even within these limits, the list is far from complete.</p>		<p>Ames, Charles. 1982. &quot;Statistics and Compositional Balance,&quot; <i><b>Perspectives of New Music </b></i>, Volume 23, Number 2.</p>		<p>Ames, Charles. 1987. &quot;Automated Composition in Retrospect: 1956-1986,&quot; <i><b>Leonardo</b></i>, Volume 20, Number 2, pp. 169-185.</p>		<p>Ames, Charles. 1989. &quot;The Markov Process as a Compositional Model: A Survey and Tutorial,&quot; <i><b>Leonardo Music Journal</b></i>, Volume 22, Number 2.</p>		<p>Ames, Charles. 1991a. &quot;Quantifying Musical Merit,&quot; <i><b>Interface</b></i>, Volume 20, Number 1.</p>		<p>Ames, Charles. 1991b. &quot;A Catalog of Statistical Distributions: Techniques for Transforming Random, Determinate and Chaotic Sequences,&quot; <i><b>Leonardo Music Journal</b></i>, Volume. 1, Number. 1.</p>		<p>Ames, Charles. 1992. &quot;A Catalog of Sequence Generators: Accounting for Proximity, Pattern, Exclusion, Balance and/or Randomness,&quot; <i><b>Leonardo Music Journal</b></i>, Volume 2, Number 1.</p>		<p>Ames, Charles. 1993. &quot;How to Level a Driver Sequence,&quot; <i><b>Leonardo Music Journal</b></i>, Volume 3, Number 1.</p>		<p>Ames, Charles. 1985. &quot;Tutorial on Automated Composition,&quot; <i><b>Proceedings of the International Computer Music Conference</b></i>, 1985.</p>		<p>Arfib, Daniel. 1991. &quot;Analysis, Transformation, and Resynthesis of Musical Sounds with the Help of a Time-Frequency Representation,&quot; in Giovanni De Poli, Aldo Piccialli, and Curtis Roads (ed), <i><b>Representations of Musical Signals</b></i>. Cambridge, Massachusetts: The MIT Press, 1991, pages 87-118. An overview of time-frequency signal transforms, especially the Gabor transform, as representations of musical sound. Time-frequency transforms provide the theoretical basis for granular synthesis and other time-frequency signal processing algorithms.</p>		<p>Baggi, D. (editor) 1992. <i><b>Readings in Computer-Generated Music</b></i>. IEEE Computer Society Press.</p>		<p>Barnsley, Michael. 1993 [1998]. <i><b>Fractals Everywhere</b></i>, Second Edition. Boston: Academic Press. Textbook on fractal geometry that provides a unified mathematical treatment of iterated function systems, Julia and Mandelbrot sets, and fractals. Invaluable resource for the geometric approach to algorithmic composition.</p>		<p>Bastiaans, Martin J. 1980. &quot;Gabor's Expansion of a Signal into Gaussian Elementary Signals,&quot; <i><b>Proceedings of the IEEE</b></i>, Volume 68, Number 4, pages 538-539.</p>		<p>Biles, Al. 1997. <i><b>GenJam </b></i>(http://www.it.rit.edu/~jab/GenJam.html). An interactive genetic algorithm that learns to play jazz solos.</p>		<p>Brun, Herbert. 1969. &quot;Infraudibles,&quot; in Heinz v. Foerster and James W. Beauchamp (editors), <i><b>Music by Computers</b></i>. New York, J. Wiley.</p>		<p>Brun, Herbert. 1970. &quot;From Musical Ideas to Computers and Back,&quot; in Harry B. Lincoln (editor), <i><b>The Computer and Music</b></i>. Ithaca, Cornell University Press.</p>		<p>Beman, Jeffrey C. No date. <i><b>Minor Research Project One: A Survey of Algorithmic Composition Techniques with an Examination of the Potential use of Algorithmic Composition Techniques in Multi-Media Software</b></i>. Submitted in partial fulfillment of the requirements for the degree of Master of Music in Electronic and Computer Music Research at the Peabody Conservatory of Music The Peabody Institute of The Johns Hopkins University. Baltimore, Maryland (http://www.peabody.jhu.edu/artists/composers/beman/minorProject_1.text).</p>		<p>Bidlack, R. 1992. &quot;Chaotic Systems as Simple (But Complex) Compositional Algorithms,&quot; <i><b>Computer Music Journal</b></i>, Volume 16, Number 3, pp. 34-47.</p>		<p>Bolognesi, T. 1983. &quot;Automatic Composition: Experiments with Self-Similar Music,&quot; <i><b>Computer Music Journal</b></i>, Volume 7, Number 1, pp. 25-36.</p>		<p>Braut, Christian. 1994. <i><b>The Musician's Guide to MIDI</b></i>. Paris: Sybex. An exhaustive consideration of the current state of the MIDI standard, with sample code and extensive tables. Marred by some typos, but get it if you plan to do any MIDI programming.</p>		<p>Buchner, A. 1978. <i><b>Mechanical Musical Instruments</b></i>. Westport: Greenwood Press.</p>		<p>Cage, John. 1973 [1961]. <i><b>Silence: Lectures and Writings by John Cage</b></i>. Hanover, New Hampshire: Wesleyan University Press. A vital resource.</p>		<p>Cage, John. 1992 [1961-1962]. &quot;Atlas Eclipticalis,&quot; for flutes, piccolo, bass clarinet, contrabassoon, trombone, contrabass. <i><b>The Barton Workshop Performs John Cage</b></i>, Etcetera 2 KTC 3002, CD.</p>		<p>Cage, John, and Lejaren Hiller. 1969 [1968-1969]. <i><b>HPSCHD</b></i>. Nonesuch H-71224, LP.</p>		<p>Center for Complex Systems Research (CCSR) of the Beckman Institute (BI) and the Physics Department of the University of Illinois at Urbana Champaign (UIUC) and of the Virtual Environment Group (VEG) of the National Center for Supercomputing Applications (NCSA). 1995. <i><b>Chua&#146;s Oscillator: Applications of Chaos to Sound and Music </b></i>(http://www.ccsr.uiuc.edu/People/gmk/Projects/ChuaSoundMusic/ChuaSoundMusic.html)</p>		<p>Chaitin, Gregory J. 1974a. &quot;Information-Theoretic Limitations of Formal Systems,&quot; <i><b>Journal of the Association for Computing Machinery</b></i>, Volume 21, pp. 403-424.</p>		<p>Chaitin, Gregory J. 1974b. &quot;Randomness and Mathematical Proof,&quot; <i><b>Scientific American</b></i>, Volume 232, Number 5, pp. 47-52.</p>		<p>Chomsky, Noam. 1957. <i><b>Syntactic Structures</b></i>. The Hague: Mouton. The first influential scientific theory (of the syntax of natural langauges) cast in the form of a generative grammar.</p>		<p>Coenen, Alcedo. 1994. <i><b>Amsterdam Catalogue of Composition Algorithms </b></i>(http://mars.let.uva.nl/ACCA/ACCA.html).</p>		<p>Cope, David. 1969. <i><b>Towers</b></i>. Champaign, Illinois: Media Press.</p>		<p>Cope, David. 1971. <i><b>New Directions in Music</b></i>. Dubuque, Iowa: W.C. Brown Co.</p>		<p>Cope, David. 1976. <i><b>New Music Notation</b></i>. Dubuque, Iowa: Kendall/Hunt Publishing Co.</p>		<p>Cope, David. 1977. <i><b>New Music Composition</b></i>. New York: Schirmer Books.</p>		<p>Cope, David. 1987. &quot;An Expert System for Computer-Aided Composition,&quot; <i><b>Computer Music Journal</b></i>, Volume 11, Number 4.</p>		<p>Cope, David. 1989. &quot;The Step by Step Simulation of a Mozart Sonata,&quot; in <i><b>Proceedings of the European Workshop on Artificial Intelligence and Music</b></i>. Genoa: Computer Music Laboratory, University of Genoa.</p>		<p>Cope, David. 1991. <i><b>Computers and Musical Style</b></i>, The Computer Music and Digital Audio Series, Volume 6. Madison, Wisconsin: A-R Editions.</p>		<p>Cope, David. 1992. &quot;Computer Modeling of Musical Intelligence in EMI,&quot; <i><b>Computer Music Journal</b></i>, Volume 16, Number 2.</p>		<p>Conger, Jim. 1989. <i><b>Midi Sequencing in C</b></i>. Redwood City, California: M &amp; T Books, 1989. Portions of the code for reading and writing MIDI files in Silence are based on ideas in this book.</p>		<p>Michael Cziesperger. 1989. &quot;Introducing Standard MIDI Files,&quot; <i><b>Electronic Musician</b></i>, Volume 5, Number 4, pp. 49 ff.</p>		<p>Dannenberg, R.B. 1989. &quot;The Canon Score Language,&quot; <i><b>Computer Music Journal</b></i>. Volume 13, Number 1, pp. 47-56.</p>		<p>DaGazio, Bruno. No date. <i><b>Nikola Tesla and Joseph Schillinger: The Music of NT: The Man Who Invented the Twentieth Century </b></i>(http://www-ks.rus.uni-stuttgart.de/people/schulz/fmusic/tesla.html).</p>		<p>DeLio, Thomas. 1984. <i><b>Circumscribing the Open Universe: Essays on John Cage, Morton Feldman, Christiann Wolff, Robert Ashley, and Alvien Lucier</b></i>. Lanham and London: University Press of America.</p>		<p>Davis, Martin (editor). 1965. <i><b>The Undecidable: Basic Papers on Undecidable Propositions, Unsolvable Problems and Computable Functions</b></i>. Hewlett, New York: Raven Press.</p>		<p>De Poli, Giovanni, Aldo Piccialli, and Curtis Roads (editors). 1991. <i><b>Representations of Musical Signals</b></i>. Cambridge, Massachusetts: The MIT Press. Important technical reference to alternative representations of musical sound, not limited to digitized waveforms or the Fourier transform.</p>		<p>De Poli, Giovanni and Aldo Piccialli. 1991. &quot;Pitch-Synchronous Granular Synthesis.&quot; Giovanni De Poli, Aldo Piccialli, and Curtis Roads (editors), <i><b>Representations of Musical Signals</b></i>. Cambridge, Massachusetts: The MIT Press, 1991, pages 187-219.Devaney, R.L., 1988. &quot;Fractal Patterns Arising in Chaotic Dynamical Systems,&quot; in H.-O. Peitgein and P.H. Richter (editors), The Science of Fractal Images. New York: Springer-Verlag.</p>		<p>DiScipio, A., 1990. &quot;Composition by Exploration of Nonlinear Dynamical Systems,&quot; in S. Arnold and G. Hair (editors), <i><b>Proceedings of the 1990 International Computer Music Conference</b></i>. San Francisco: International Computer Music Association, pp. 324-327.</p>		<p>DiScipio, Agostino. 1995. &quot;Inseparable Models of Materials and of Musical Design in Electroacoustic and Computer Music,&quot; <i><b>Interface</b></i>, Volume 24.</p>		<p>Earthweb. 1997. <i><b>Gamelan: The Official Directory for Java </b></i>(http://www-b.gamelan.com/index.shtml).</p>		<p>Essl, K@rlheinz. 1996. <i><b>Real Time Composition Library 2.3 for MAX (1993-96) Software-Environment for Computer Aided Composition </b></i>(http://www.ping.at/users/essl/works/rtc.html).</p>		<p>Dodge, Charles. 1986. &quot;Musical Fractals,&quot; <i><b>Byte Magazine</b></i>, Volume 11, Number 6, pp. 185-196.</p>		<p>Dodge, Charles., 1988. &quot;Profile: A Musical Fractal,&quot; <i><b>Computer Music Journal</b></i>, Volume 12, Number 3, pp. 10-14.</p>		<p>Dodge, Charles and Thomas A. Jerse. 1985. <i><b>Computer Music: Synthesis, Composition, and Performance</b></i>. New York: Schirmer Books. A standard reference in the field, with illuminating discussions of classic software instruments for which there exist CSound implementations on various anonymous FTP sites.</p>		<p>Dunn, John. No date. <i><b>Algorithmic DNA Music by John Dunn </b></i>(http://www.algoart.com/dnamusic).</p>		<p>Embree, Paul M. and Bruce Kimble. 1991. <i><b>C Language Algorithms for Digital Signal Processing</b></i>. Englewood Cliffs, New Jersey: Prentice-Hall.</p>		<p>Evans, Brian. 1995. <i><b>Hearing the Mandelbrot Set </b></i>(http://www.vanderbilt.edu/VUCC/Misc/Art1/Sonify/Mandi.html).</p>		<p>Feigenbaum, M. J. &quot;Universal Behavior in Nonlinear Systems,&quot; <i><b>Physica 7D</b></i>, pp. 16-39.</p>		<p>Foley, James D., Andries van Dam, Steven K. Feiner, and John F. Hughes. 1991 [1990]. <i><b>Computer Graphics: Principles and Practice</b></i>, Second Edition. Reading, Massachusetts: Addison-Wesley Publishing Company. Standard text in the field of computer graphics. The six-dimensional representation of note space is based on concepts expounded in this book for the purposes of image manipulation and three-dimensional rendering in computer graphics. The color model for note space is also based on ideas in this book.</p>		<p>Allen Forte. 1973. <i><b>The Structure of Atonal Music</b></i>. New Haven:&nbsp;Yale University Press. Explains the hierarchy of pitch relationships in atonal music.</p>		<p>Gabor, D. 1946. &quot;Theory of Communication,&quot; <i><b>The Journal of the Institution of Electrical Engineers</b></i>, Part III, Volume 93, pages 429-457. The original article setting forth the time-frequency representation of sound.</p>		<p>Gabor, D. 1947. &quot;New Possibilities in Speech Transmission,&quot; <i><b>The Journal of the Institution of Electrical Engineers</b></i>, Part III, Volume 94, Number 32, pages 369-387.</p>		<p>Gabor, D. 1947. &quot;Acoustical Quanta and the Theory of Hearing,&quot; <i><b>Nature</b></i>, Volume 159, Number 1044, pages 591-594. Discusses experimental measurements of human hearing and their relevance for the time-frequency representation of sound.</p>		<p>Gardner, Martin. 1980. &quot;White and brown melodies, fractals and 1/f fluctuations,&quot; <i><b>Scientific American</b></i>, Volume 5. This article is what started me thinking I could compose by means of mathematics.</p>		<p>Gather, John-Philipp. 1995. <i><b>Amsterdam Catalog of Csound Computer Instruments 1.1</b></i>. An extremely useful compendium of working Csound implementations of classical computer music instrument designs.</p>		<p>Giffin, Noel. 1997. <i><b>Welcome to the Fractint WWW Pages </b></i>(http://spanky.triumf.ca/www/fractint/fractint.html).</p>		<p>Gogins, Michael. 1992a. &quot;Fractal Music with String Rewriting Grammars,&quot; <i><b>News of Music 13</b></i>, pp. 146-170.</p>		<p>Gogins, Michael. 1992b. &quot;How I Became Obsessed with Finding a Mandelbrot Set for Sounds,&quot; <i><b>News of Music 13</b></i>, pp. 129-139.</p>		<p>Gogins, Michael. 1991. &quot;Iterated Function Systems Music,&quot; <i><b>Computer Music Journal</b></i>, Volume 15, Number 1, pp. 40-48.</p>		<p>Gogins, Michael. 1995. &quot;Gabor Synthesis of Recurrent Iterated Function Systems&quot;, <i><b>Proceedings of the International Computer Music Conference</b></i>. San Francisco: International Computer Music Association.</p>		<p>Graves, David Thomas. 1981. &quot;The Use of Mathematics in Selected Aspects of Music&quot;, Ph.D. dissertation, The Union for Experimenting Colleges and Universities. Useful compendium of references for mathematical analysis of tuning systems and serial music.</p>		<p>Greenhouse, Robert. 1995. <i><b>The Well-Tempered Fractal v3.0: A Composer's Tool for the Derivation of Musical Motifs, Phrases and Rhythms From The Beauty and Symmetry of Fractals, Chaotic Attractors and Other Mathematical Functions </b></i>(http://www-ks.rus.uni-stuttgart.de/people/schulz/fmusic/wtf/). A fractal composing program for IBM compatible PCs.</p>		<p>Harley, James. 1995. &quot;Generative Processes in Algorithmic Composition: Chaos and Music,&quot; <i><b>Leonardo</b></i>, Volume 28, Number 3. Correlations between chaos theory and music are described, and serve as the basis for the computer program CHAOTICS, a set of modules which serve as tools for composition.</p>		<p>Hiller, L. 1970. &quot;Music Composed with Computers - A Historical Survey,&quot; in H. Lincoln (editor), <i><b>The Computer and Music</b></i>. Ithaca: Cornell University Press pp. 42-96.</p>		<p>Hiller, Lejaren. 1996 [1957]. &quot;Iliac Suite for String Quartet,&quot; <i><b>Lejaren Hiller Retrospective</b></i>. Wergo WE124, CD.</p>		<p>Hiller, L. and Baker, R. &quot;Computer Cantata: A Study in Compositional Method,&quot; <i><b>Perspectives of New Music</b></i>, Volume 3, pp. 62-90.</p>		<p>Hiller, L. and John Cage. 1968. &quot;HPSCHD: An Interview by Larry Austin,&quot; <i><b>Source</b></i>, Volume 2, Number 2, pp. 10-19.</p>		<p>Hiller, Lejaren Arthur, and L.M. Isaacson. 1957a. <i><b>Illiac suite, for String Quartet</b></i>. New York: New Music Edition.</p>		<p>Hiller, Lejaren Arthur, and Isaacson. 1957b. <i><b>Illiac suite, for String Quartet</b></i>. Heliodor HS 25053, LP.</p>		<p>Hiller, Lejaren and Isaacson, L. M. (editors). 1959. <i><b>Experimental Music: Composition with an Electronic Computer</b></i>. New York: McGraw-Hill.</p>		<p>Holtzman, S.R. 1981. &quot;Using Generative Grammars for Music Composition,&quot; <i><b>Computer Music Journal</b></i>, Volume 5, Number 1, pp. 51-64.</p>		<p>Holm, Frode. 1992. &quot;Understanding FM implementation: A Call for Common Standards,&quot; <i><b>Computer Music Journal</b></i>, Volume 16, Number 1, Spring 1992, pages 34-42.</p>		<p>Honing, H., 1990. &quot;POCO: An Environment for Analysing, Modifying, and Generating Expression in Music,&quot; in S. Arnold and G. Hair (editors), <i><b>Proceedings of the 1990 Interational Computer Music Conference</b></i>. International Computer Music Association: San Francisco, pp. 364-368.</p>		<p>Howe, Hubert S., Jr. 1975. <i><b>Electronic Music Synthesis: Concepts, Facilities, Techniques</b></i>. New York: W.W. Norton &amp; Co.</p>		<p>Huron, David. 1996. <i><b>The Humdrum Toolkit: Software for Music Research </b></i>(http://ccrma-www.stanford.edu/CCRMA/Events/Colloquium/Past/94-11-30.html). The Humdrum Toolkit is a set of (UNIX-based) software tools for music research. For those who are interested, an extensive FAQ (Frequently Asked Questions) document for the Humdrum Toolkit is available via ftp (archive@uwaterloo.ca cd uw-data/humdrum) or by sending an e-mail request to dhuron@ccrma.</p>		<p>Jacobs, Bruce L. No date. <i><b>VARIATIONS: Algorithmic Composition for Acoustic Instruments </b></i>(http://www.eecs.umich.edu/~blj/algorithmic_composition).</p>		<p>Johnson-Laird, P.N., 1991. &quot;Jazz Improvisation: A Theory at the Computational Level,&quot; in <i><b>Representing Musical Structure</b></i>. New York: Academic Press, p. 291-323. Jones, M.R. 1993. &quot;Dynamics of Musical Patterns: How do Melody and Rhythm Fit Together?,&quot; in T.J. Tighe and W.J. Dowling (editors), <i><b>Psychology and Music: The Understanding of Melody and Rhythm</b></i>. London: Academic Press, pp. 67-92.</p>		<p>Kindermann, Lars. 1996. <i><b>MusiNum - The Music in the Numbers </b></i>(http://www.forwiss.uni-erlangen.de/~kinderma/musinum.html).</p>		<p>Koenig, Gottfried Michael. 1970a. &quot;Project 1: A Programme for Musical Composition,&quot; <i><b>Electronic Music Report</b></i>, Volume 2, pp. 32-34 (reprinted Amsterdam: Swets and Zeitlinger, 1977).</p>		<p>Koenig, Gottfried Michael. 1970b. &quot;Project 2: A Programme for Musical Composition,&quot; <i><b>Electronic Music Report</b></i>, Volume 3, pp. 1-16 (reprinted Amsterdam: Swets and Zeitlinger, 1977).</p>		<p>Koenig, Gottfried Michael. &quot;Genesis of Form in Technically Conditioned Environments,&quot; <i><b>Interface</b></i>, Volume 16, Number 3.</p>		<p>Koenig, Gottfried Michael. &quot;Aesthetic Integration of Computer-Composed Scores,&quot; <i><b>Computer Music Journal</b></i>, Volume 7, Number 4.</p>		<p>Koza, J.R. 1992. <i><b>Genetic Programming</b></i>. Cambridge, Massachusetts: The MIT Press.</p>		<p>Laske, Otto. 1981. &quot;Composition Theory in Koenig's Project One and Project Two,&quot; <i><b>Computer Music Journal</b></i>, Volume 5, Number 4, pp. 54-65.</p>		<p>Laske, Otto. 1992. &quot;A Conversation with Marvin Minsky,&quot; <i><b>AI Magazine</b></i>. 1992, p. 31-45.</p>		<p>Laske, Otto and Minsky, Marvin (editors). 1992. <i><b>Understanding Music with AI: Perspectives on Music Cognition</b></i>. Menlo Park, California: The AAAI Press.</p>		<p>Leach, J.F. 1995. &quot;Nature, Music, and Algorithmic Composition,&quot; <i><b>Computer Music Journal</b></i>, Volume 19, Number 2, pp. 23-33.</p>		<p>Leach, J. L. and J. P. Fitch. 1996. <i><b>The Algorithmic Composition Home Page </b></i>(http://www2.bath.ac.uk/~mapjll/algo-comp.html). Leeds University. 1996. The Csound Front Page (http://www.leeds.ac.uk/music/Man/c_front.html). The main Web entry point for Csound, including up-to-date builds of public-domain Csound for many platforms, and links to tutorials and samples.</p>		<p>Lerdahl, F., and R. Jackendoff. 1983. <i><b>A Generative Theory of Tonal Music</b></i>. Cambridge, Massachusetts: The MIT Press.</p>		<p>Hepis, Leonidas. 1993. <i><b>List of Tools </b></i>(http://mars.let.uva.nl/ACCA/ACCA.ToolsList.html). An extensive annotated list of software for algorithmic composition.</p>		<p>Li, T-Y, and Yorke, J.A. 1985. &quot;Period Three Implies Chaos,&quot; <i><b>American Mathematical Monthly</b></i>, Volume 82, pp. 985-992.</p>		<p>Little, David Clark. No date. <i><b>Composing with Chaos; Applications of a New Science for Music </b></i>(http://www-ks.rus.uni-stuttgart.de/people/schulz/fmusic/index.html).</p>		<p>Lyr, R. 1955. &quot;Une merveille de cecanisme: le Componium de T. N. Winkel,&quot; in A. Chapuis (editor). <i><b>Histoire de la boite a musique</b></i>. Lausanne: Edition Scriptar.</p>		<p>Mandelbrot, Benoit. 1983 [1977]. <i><b>The Fractal Geometry of Nature </b></i>(Updated and Augmented). New York: W. H. Freeman and Company. Seminal work on fractals in many fields of science and art.</p>		<p>Mayer-Kress, G., I. Choi, R. Bargar. 1993. &quot;Sound Synthesis and Music Composition using Chua's Oscillator ,&quot; <i><b>Proc, NOLTA93</b></i>, Hawaii.</p>		<p>Mayer-Kress, G., I. Choi, N. Weber, R. Bargar, A. Hpbler. 1993. &quot;Musical Signals from Chua's Circuit,&quot; <i><b>IEEE Transactions on Circuits and Systems</b></i>, Volume 40, special issue on &quot;Chaos in Nonlinear Electric Circuits&quot;, pp. 688-695.</p>		<p>Mayer-Kress., G., R. Bargar, I. Choi. 1994. &quot;Musical Structures in Data From Chaotic Attractors,&quot; <i><b>Technical Report CCSR-92-14</b></i>, Proceedings of the International Symposium on the Auditory Display (ICAD92), Santa Fe, Volume XVIII, Santa Fe Institute Series in the Sciences of Complexity. Reading: Addison Wesley.</p>		<p>Mathews, Max V., with Joan E. Miller, F.R. Moore, J.R. Pierce and J.C. Risset. 1969. <i><b>The Technology of Computer Music</b></i>. Cambridge, Massachusetts:&nbsp;The MIT Press. Clearly outlines the author's ground-breaking basic engineering for digital sound synthesis, now taken for granted by most software sound synthesis systems.</p>		<p>Matsuba, Stephen N. and Bernie Roehl. 1996. <i><b>Special Edition: Using VRML</b></i>. Indianapolis: Que. There is a considerable similarity in underlying philosophy and mathematical application between Virtual Reality Modeling Language and generative grammars.</p>		<p>Mertens, Wim. 1983 [1980]. <i><b>American Minimal Music: La Monte Young, Terry Riley, Steve Reich, Philip Glass</b></i>, translated from the Dutch by J. Hautekiet with a preface by Michael Nyman. London: Kahn and Averill; New York: Alexander Broude.</p>		<p>Microsoft Corporation. 1991. <i><b>Microsoft Windows Multimedia Programmer&#146;s Reference</b></i>. Redmond, Washington: Microsoft Press.</p>		<p>Millen, Dale. 1990. &quot;Cellular Automata Music,&quot; in <i><b>Proceedings of the 16th International Computer Music Conference</b></i>, Glasgow. San Francisco: International Computer Music Association, p. 314-316.</p>		<p>Moore, F. Richard. 1990. <i><b>Elements of Computer Music</b></i>. Englewood Cliffs, New Jersey. A standard reference for software synthesis and signal processing.</p>		<p>Mucherino, Nicholas. No date. <i><b>Recursion: A Paradigm for Future Music?</b></i> (http://www-ks.rus.uni-stuttgart.de/people/schulz/fmusic/recursion.html).</p>		<p>Nelson, Gary Lee. 1993. <i><b>Wind, Sand, and Sea Voyages: An Application of Granular Synthesis and Chaos to Musical Composition </b></i>(http://www-ks.rus.uni-stuttgart.de/people/schulz/fmusic/gnelson.html)</p>		<p>Nyman, Michael. 1974. <i><b>Experimental Music: Cage and Beyond</b></i>. London: Studio Visa</p>		<p>Olafsson, Kjartan. 1997. <i><b>Calmus: Calculated Music </b></i>(1988-1997) (http://rvik.ismennt.is/~kjol/).</p>		<p>Olson, H. and H. Belar. 1961. &quot;Aid to Music Composition System Employing a Random Probability System,&quot; <i><b>Journal of the Acoustic Society of America</b></i>, Volume 33, pp. 1163-1170.</p>		<p>Ord-Hume, A. W. J. G. 1973. <i><b>Clockwork Music</b></i>. New York: Crown Publishers.</p>		<p>Peitgen, Heinz-Otto, Hartmut J&uuml;rgens, and Dietmar Saupe. 1990. &quot;The Language of Fractals,&quot; <i><b>Scientific American</b></i>, August 1990, pp. 11-20.</p>		<p>Peitgen, Heinz-Otto, Hartmut J&uuml;rgens, and Dietmar Saupe. 1992. <i><b>Chaos and Fractals: New Frontiers of Science</b></i>. New York: Springer-Verlag, 1992. Probably the best general introduction to the field, with sample code for realizing a wide variety of fractals. Provides a unifying metaphor for fractal algorithms in the form of the &quot;multiple reduction copying machine.&quot;</p>		<p>Peitgen, Heinz-Otto and Dietmar Saupe (editors). 1988. <i><b>The Science of Fractal Images</b></i>. New York: Springer-Verlag. Sample code for Lindenmayer systems, iterated function systems, and Julia and Mandelbrot sets.</p>		<p>Pierce, John R. 1992 [1983]. <i><b>The Science of Musical Sound</b></i>, Revised Edition. New York: W. H Freeman and Company. An introduction to musical hearing and musical acoustics.</p>		<p>Pope, Stephen Travis. 1993. &quot;An Incomplete Diskography of Computer Music,&quot; <i><b>Computer Music Journal</b></i>, Volume 17, Number 4, pp. 5-10.</p>		<p>Pope, Stephen Travis. 1995. <i><b>Musical Object Development Environment </b></i>(http://datura.cerl.uiuc.edu/netStuff/mode.html). The Musical Object Development Environment (MODE) is a general-purpose music description and composition system written in the Smalltalk-80 language using the ParcPlace Systems, Inc. Visualworks\Smalltalk libraries and run-time system.</p>		<p>Press, William H., Saul A. Teukolsky, William T. Vetterling, and Brian P. Flannery. 1992 [1988]. <i><b>Numerical Recipes in C: The Art of Scientific Computing</b></i>, Second Edition. Cambridge: The Cambridge University Press.</p>		<p>Pressing, J., 1988. &quot;Nonlinear Maps as Generators of Musical Design,&quot; <i><b>Computer Music Journal</b></i>, Volume 12, Number 2, pp. 35-46.</p>		<p>Prieberg, F. 1975. <i><b>Musica ex Machina</b></i>. Italian edition. Turin: Giulio Einaudi Editore.</p>		<p>Prusinkiewicz, Przemyslaw and Aristid Lindenmayer. 1990. <i><b>The Algorithmic Beauty of Plants</b></i>. New York: Springer-Verlag. An important, indeed inspiring, use of a generative grammar as a theory of plant growth. My Lindenmayer system composing grammar is based on concepts developed in this book.</p>		<p>Rahn, John. 1980. <i><b>Basic Atonal Theory</b></i>. New York: Schirmer Books. A very clear introduction to what one hears, and why, in atonally composed music.</p>		<p>Reid, Christopher E. and Thomas B. Passin. 1992. <i><b>Signal Processing in C</b></i>. New York: John Wiley &amp; Sons, Inc., 1992.</p>		<p>Riley, Terry. 1989 [1964]. <i><b>In C</b></i>. Celestial Harmonies.</p>		<p>Roads, Curtis. 1978. <i><b>Composing Grammars</b></i>. San Francisco: International Computer Music Association.Roads, Curtis (editor). 1985. Composers and the Computer. Madison: A-R Editions.</p>		<p>Roads, Curtis. 1985. &quot;Grammars as Representations for Music,&quot; in C. Roads and J. Strawn (editors), <i><b>Foundations of Computer Music</b></i>. Cambridge, Massachusetts: The MIT Press, pp 403-442.</p>		<p>Roads, Curtis (editor). 1989. <i><b>The Music Machine: Selected Readings from Computer Music Journal</b></i>. Cambridge, Massachussetts: The MIT Press.</p>		<p>Roads, Curtis Roads with John Strawn, Curtis Abbott, John Gordon, and Philip Greenspun. 1996. <i><b>The Computer Music Tutorial</b></i>. Cambridge, Massachusetts: The MIT&nbsp;Press. Currently the best one-volume introduction to computer music.</p>		<p>Roads, Curtis and John Strawn (editors). 1988 [1985]. <i><b>Foundations of Computer Music</b></i>. Cambridge, Massachusetts: The MIT Press. Reproduces seminal articles in the field.</p>		<p>Schillinger, Joseph. 1946 [1941]. <i><b>The Schillinger System of Musical Composition</b></i>. New York: C. Fischer, Inc.</p>		<p>Schillinger, Joseph. 1948. <i><b>The Mathematical Basis of the Arts</b></i>. New York: Philosophical Library.</p>		<p>Scholes, P. 1975. <i><b>The Oxford Companion to Music</b></i>. London: Oxford University press.</p>		<p>Schulz, Claus-Dieter. No date. <i><b>Welcome to the Fractal Music Project </b></i>(http://www-ks.rus.uni-stuttgart.de/people/schulz/fmusic/index.html). Gathers some other WWW fractal music resources.</p>		<p>Schwanauer, Stephan and Levitt, David A. (editors). 1993. <i><b>Machine Models of Music</b></i>. Cambridge, Massachussetts: The MIT Press.</p>		<p>Scott, Raymond. 1992. <i><b>Reckless Nights and Turkish Twilights: The Music of Raymond Scott</b></i>. Produced by Irwin Chusid, with notes by Irwin Chusid. Columbia Records 53028, CD.</p>		<p>Spector, L., and Alpern, Adam. 1994. &quot;Criticism, Culture, and the Automatic Generation of Artworks,&quot; in <i><b>Proceedings of the Twelfth National Conference on Artificial Intelligence</b></i>, AAAI-94, 1994. : p. 3-8.</p>		<p>Spector, L., and Alpern, Adam, 1995. &quot;Induction and Recapitulation of Deep Musical Structure,&quot; in <i><b>Proceedings of the IJCAI-95 Workshop On Arificial Intelligence and Music</b></i>.</p>		<p>Stone, Peter. 1997. <i><b>Symbolic Composer 4.0 - Now Shipping!</b></i> (http://www.xs4all.nl/~psto/). A Macintosh-based algorithmic composition environment with many score generators and plugin modules.</p>		<p>Sun Microsystems Inc. 1997<i><b>. Javasoft Home Page </b></i>(http://java.sun.com/).</p>		<p>Symbolic Sound Corporation. 1997. <i><b>Symbolic Sound Corporation </b></i>(http://www.symbolicsound.com/). Manufactures a hardware-DSP based system with its own Kyma language for algorithmic synthesis and composition.</p>		<p>Taube, Heinrich. 1991. &quot;Common Music: A Music Composition Language in Common Lisp and CLOS,&quot; <i><b>Computer Music Journal</b></i>, Volume 15, Number 2, pp. 21-32.</p>		<p>Taube, Heinrich. 1996. <i><b>Common Music </b></i>(http://ccrma-www.stanford.edu/CCRMA/Overview/node25.html). A widely used LISP composing environment that runs on most platforms.</p>		<p>Taube, Heinrich and Tobias Kunze. 1996. <i><b>Capella: A Graphical Interface for Algorithmic Composition </b></i>(http://ccrma-www.stanford.edu/CCRMA/Overview/node26.html). This is a Macintosh graphical front end for Common Music.</p>		<p>Todd, Peter M. and D.G. Loy (editors). 1991. <i><b>Music and Connectionism</b></i>. Cambridge, Massachussetts: The MIT Press</p>		<p>Truax, Barry. 1990. &quot;Chaotic Non-Linear Systems and Digital Synthesis: An Exploratory Study,&quot; in <i><b>Proceedings of the 16th International Computer Music Conference</b></i>, Glasgow. San Francisco: International Computer Music Association, pp. 100-103.</p>		<p>Vercoe, Barry. 1984. &quot;CSound: A Manual for the Audio Processing System and Supporting Programs with Tutorials.&quot; Cambridge, Massachusetts: Media Lab, MIT. The user&#146;s guide and reference manual for CSound. An essential resource, too bad it&#146;s out of date and lacks documentation for new opcodes.</p>		<p>Voss R.F. 1988. &quot;Fractal Music,&quot; in Peitgen, Heinz-Otto and Dietmar Saupe (editors), <i><b>The Science of Fractal Images</b></i>. New York: Springer-Verlag.</p>		<p>Voss, R.F., and J. Clarke. 1975. &quot;1/f noise in music and speech,&quot; <i><b>Nature</b></i>, Volume 258 , pp. 317-318.</p>		<p>Voss, R.F. and J.R. Clarke. 1978. &quot;1/f Noise in music: Music from 1/f noise,&quot; <i><b>Journal of the Acoustical Society of America</b></i>, Volume 63, Number 1, pp. 258 - 263.</p>		<p>Xenakis, Iannis. 1992. <i><b>Formalized Music: Thoughts and Mathematics in Music</b></i>, Revised Edition. Additional material compiled and edited by Sharon Kanach. Harmonologia Series No. 6. Stuyvesant, New York: Pendragon Press. Great book which intellectually grounds the formal, mathematical approach to musical composition. Highly relevant to algorithmic composition and granular synthesis.</p>		<p>Wagon, Stan. 1991. <i><b>Mathematica in Action</b></i>. New York: W. H. Freeman and Company. Unusually clear book on Mathematica programming that provides sample programs which can be adapted for musical composition.</p>		<p>Warburton, Dan. 1988. &quot;A Working Terminology for Minimal Music,&quot; <i><b>Integral</b></i>, Volume 2, pp. 135-159.</p>		<p>Wegner, Tim and Bert Tyler. 1993. <i><b>Fractal Creations</b></i>, Second Edition. Corte Madera. Documents FRACTINT and provides many sample fractals and simplified explanations of the underlying mathematics.</p>		<p>Wishart, Trevor. 1994. <i><b>Audible Design: A Plain and Easy Introduction to Practical Sound Composition</b></i>. York: Orpheus the Pantomime. Interesting discussion of compositional techniques for sound considered as such.</p>		<p>Winsor, Phil. 1978. <i><b>Computer-Assisted Music Composition</b></i>. Princeton: Petrocelli Books.</p>		<p>Winsor, Phil and Gene DeLisa. 1991. <i><b>Computer Music in C</b></i>. Blue Ridge Summit, Pennsylvania: Windcrest Books.</p>		<p>Wolfram, Stephen. 1996 [1988]. <i><b>The Mathematica Book</b></i>, Third Edition.. Reading, Massachusetts: Wolfram Media. The primary reference for Mathematica.</p>		<p>Wolfram Research, &quot;MathLink Reference Guide, Mathematica Version 2.2&quot;, Mathematica Technical Report, 1993.	</body></html>