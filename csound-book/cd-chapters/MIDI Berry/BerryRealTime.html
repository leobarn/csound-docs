<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<meta name="generator" content="Adobe GoLive 4">		<title>Realtime Chapter</title>	</head>	<body bgcolor="white">		<h1><b>3. Real-time Synthesis in Csound with MIDI Control</b></h1>		<h2><b>Michael Berry</b></h2>		<p>Csound was not originally designed to produce audio in real-time. At the time it was written, only large mainframes were fast enough to use for Csound and often sound files had to be taken to another machine with a digital-to-analog converter (DAC) just to hear the sound at all. Computers are much faster now and most come with a built in DAC. In fact, in the last 2 years, desktop computers capable of running Csound in real-time have become the standard.</p>		<p>Obviously, speed is the criterion for determining real-time performance. Csound must continually provide the next output sample before the previous sample has finished playing. If it ever falls behind, you will hear an audible dropout. Even if the gap is only a single sample in duration it will be heard as a full frequency click. In order to effectively use Csound in real-time, you need to understand more about how Csound generates audio.</p>		<p>Csound executes as a series of loops. For example, each time a note begins there is an i-time loop, and each k-period there is a k-time loop. We are concerned with the output buffer loop. As Csound runs, output samples are accumulated in internal memory, in what is called a buffer. When the number of samples in the buffer is equal to the software buffer size, designated in the command line (<i>&#151;b</i>), Csound dumps these samples. Ordinarily this happens when sound is written to the hard-disk, but in real-time the samples are sent to the DAC. Then Csound starts to fill the buffer again and the process repeats itself.</p>		<p>Once the samples are sent to the DAC, the DAC converts them into an analog signal for amplifiers, headphones, etc. We can calculate exactly how long it will take to play a buffer, if we know the sample rate. For instance, if the buffer is 1024 mono samples and the sampling rate is 44100, the buffer is 23.2 milliseconds long. With these settings Csound would have 23.2 ms. to generate the next buffer of samples and pass it to the DAC in order to avoid a gap.</p>		<p>The DAC also has a buffer built in which is used for its internal processing. Csound allows us to designate the size of this buffer using the <i>&#151;B</i> flag on the command line. This buffer is usually set smaller than, or equal to, the software buffer <i>&#151;b</i>.</p>		<p>We can avoid having dropouts, simply by setting the buffers to be enormously big. Unfortunately, there is a trade-off. Csound is constantly working to stay ahead of the sound that we are hearing. There is a delay between when Csound generates a sound and when we hear it. This delay is called <i>latency</i>. When we are controlling Csound in real-time, this is the delay between the time that we change a control and the time that we hear the change. We can calculate the maximum amount of latency based upon our software and hardware buffer settings. The equation is as follows:</p>		<p>maximum latency(ms.) = 1000*(software buffer + hardware buffer)*nchnls/sr</p>		<p>If we were to use settings of <i>&#151;b</i> 1024 and <i>&#151;B</i> 256 in stereo and at sr = 44100, our maximum latency would be 58 ms. When sounds have a short attack time, most keyboard players notice latency when it is larger than 20 ms. In order to stay below 20 ms., our buffers would have to be less than 441 samples in total. Since many systems impose power of 2 limits on the sizes of buffers, this would mean<i> &#151;b</i> 256 and<i> &#151;B</i> 128.</p>		<p>Each computer system will have different limitations for using Csound in real-time. You can only find effective buffer sizes through trial and error. However, no matter what system you use, you will reach a point where Csound will not be able to produce sound fast enough. In that case, you will have to make the instrument simpler and faster, make the buffers larger (thus increasing the latency,) or use fewer notes.</p>		<p><font size="4"><b>Optimizing Orchestras for Speed</b></font></p>		<p>There are some simple guidelines to optimizing Csound orchestras for speed. The first is to make the maximum use of RAM. Lets take the example of creating a sine wave. The standard practice is to use an interpolating oscillator (<b>oscili</b>) on a function table (<i>f-table</i>) with 1025 points. When used on the same table, the interpolating function sounds better than its non-interpolating sibling (<b>oscil</b>). However, it also takes twice as long to process. If we use a table with 16536 points with <b>oscil</b>, it will sound better than <b>oscili</b> on 1025 points and run twice as fast. Thus. whenever possible, gain quality by using bigger tables instead of interpolating opcodes.</p>		<p>The math in an orchestra can also be streamlined. Never use a division when it is possible to multiply by the inverse. Division can take 4 to 8 times as long to process a multiplication.</p>		<p>Instead of:</p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="477">			<tr>				<td width="9%" valign="top">asig</td>				<td width="11%" valign="top">oscil</td>				<td width="80%" valign="top">kamp/8, 200, 1</td>			</tr>		</table>		</p>		<p>use:</p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="477">			<tr>				<td width="9%" valign="top">asig</td>				<td width="11%" valign="top">oscil</td>				<td width="80%" valign="top">kamp*.125, 200, 1</td>			</tr>		</table>		</p>		<p>Sometimes division is unavoidable, such as when you are dividing by a variable:</p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="477">			<tr>				<td width="9%" valign="top">asig</td>				<td width="11%" valign="top">oscil</td>				<td width="80%" valign="top">kamp/kenv, 200, 1</td>			</tr>		</table>		</p>		<p>However, division using an i-rate variable can always be replaced by multiplication. Instead of:</p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="477">			<tr>				<td width="9%" valign="top">ifreq</td>				<td width="19%" valign="top">midictrl</td>				<td width="73%" valign="top">16</td>			</tr>			<tr>				<td width="9%" valign="top">asig</td>				<td width="19%" valign="top">oscil</td>				<td width="73%" valign="top">kamp, 200/ifreq, 1</td>			</tr>		</table>		</p>		<p>use:</p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="477">			<tr>				<td width="11%" valign="top">ifreq</td>				<td width="13%" valign="top">midictrl</td>				<td width="76%" valign="top">16</td>			</tr>			<tr>				<td width="11%" valign="top">ifreq</td>				<td width="13%" valign="top">=</td>				<td width="76%" valign="top">200/ifreq</td>			</tr>			<tr>				<td width="11%" valign="top">asig</td>				<td width="13%" valign="top">oscil</td>				<td width="76%" valign="top">kamp, ifreq, 1</td>			</tr>		</table>		</p>		<p>Now the division is only performed when the instrument is initialized, instead of at every</p>		<p>k-period. Another small speed increase can be realized by &quot;in-lining&quot; math functions. Instead of:</p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="482">			<tr>				<td width="10%" valign="top">kfilt</td>				<td width="7%" valign="top">=</td>				<td width="83%" valign="top">kfreq*kamp</td>			</tr>			<tr>				<td width="10%" valign="top">aout</td>				<td width="7%" valign="top">tone</td>				<td width="83%" valign="top">asig, kfilt</td>			</tr>		</table>		</p>		<p>use:</p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="185">			<tr>				<td width="20%" valign="top">aout</td>				<td width="19%" valign="top">tone</td>				<td width="61%" valign="top">asig, kfreq*kamp</td>			</tr>		</table>		</p>		<p>Try to avoid conditional statements and instruments that require excessive initialization. Conditional statements can be quite slow in Csound. Lengthy initializations can mean that there will be too much processing at the beginning of a note, leading to dropouts whenever a new note begins, even though the note plays without gaps after it is initialized.</p>		<p>Finally, you can change to mono or decrease the sampling rate. These choices are primarily aesthetic, but be careful not to choose stereo and high sampling rates simply because that is the way you always work. If you are on stage playing through a keyboard amp, stereo is meaningless and 22050 kHz may sound just good as 44100 kHz. By changing these settings you can play 4 times as many notes at one time, or cut the latency by 75%!</p>		<p><font size="4"><b>Using <i>xyin</i></b></font></p>		<p>Standard Csound instruments can only be adjusted through a tedious process of trial and error. The <b>xyin</b> opcode is an excellent option for speeding up the process of tweaking an existing instrument because <b>xyin</b> returns the coordinates of the mouse at preset intervals. Clearly, you can then use these coordinates to control values in an instrument. You can insert <b>xyin</b> into an existing orchestra without having to make changes in the score. Whenever the instrument which has the <b>xyin</b> is active, it will respond to the mouse.</p>		<p>The manual defines <b>xyin</b> as follows:</p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="455">			<tr>				<td width="12%" valign="top">kx, ky</td>				<td width="10%" valign="top"><b>xyin</b></td>				<td width="78%" valign="top">iprd, ixmin, ixmax, iymin, iymax[, ixinit, iyinit]</td>			</tr>		</table>		</p>		<p>The minimum and maximum arguments set the size of the <b>xyin</b> window. The <i>iprd</i> argument determines how often (in seconds) a new coordinate is sensed. And the result, <i>kx</i> and <i>ky</i>, are the current mouse coordinates. If the mouse leaves the sensing window, the last coordinates are held until the mouse re-enters the window. The optional <i>ixinit</i> and <i>iyinit </i>arguments allow you to set a beginning coordinate for the mouse.</p>		<p>The file <i>ch21_1.orc</i> has two instruments. They are identical except that <i>instr 2102</i> has an <b>xyin</b> added to control two of the parameters of the <b>fof </b>opcode. As you might know, <b>fof</b> is a complex opcode and it is often hard to predict exactly what will happen aurally when you alter a parameter. In <i>instr 2101</i>, only the base frequency and the formant frequency of the <b>fof </b>opcode are set in the score (<i>p4</i> and <i>p5</i>) and the other parameters are set to reasonable values. The score plays a single note for 10 seconds.</p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="482">			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="2">instr</td>				<td valign="top" colspan="5">2101</td>			</tr>			<tr>				<td width="10%" valign="top">asig</td>				<td valign="top" colspan="2">fof</td>				<td valign="top" colspan="5">20000, p4, p5, 0, 40, .003, .02, .007, 200, 1, 2, p3</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="2">out</td>				<td valign="top" colspan="5">asig</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="2">endin</td>				<td valign="top" colspan="5">&nbsp;</td>			</tr>			<tr>				<td valign="top" colspan="8">&nbsp;</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="2">instr</td>				<td valign="top" colspan="5">2102</td>			</tr>			<tr>				<td width="10%" valign="top">kx,ky</td>				<td valign="top" colspan="2">xyin</td>				<td valign="top" colspan="5">.01, 0, 500, 0, 300</td>			</tr>			<tr>				<td width="10%" valign="top">asig</td>				<td valign="top" colspan="2">fof</td>				<td valign="top" colspan="5">20000, p4, p5+kx, 0+(ky*.02),40, .003, .02, .007, 200, 1, 2, p3</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="2">out</td>				<td valign="top" colspan="5">asig</td>			</tr>			<tr>				<td width="10%" valign="top">&nbsp;</td>				<td valign="top" colspan="2">endin</td>				<td valign="top" colspan="5">&nbsp;</td>			</tr>			<tr>				<td valign="top" colspan="8">&nbsp;</td>			</tr>			<tr>				<td valign="top" colspan="2">f 1</td>				<td width="8%" valign="top">0</td>				<td width="8%" valign="top">4097</td>				<td width="9%" valign="top">10</td>				<td valign="top" colspan="3">1</td>			</tr>			<tr>				<td valign="top" colspan="2">f 2</td>				<td width="8%" valign="top">0</td>				<td width="8%" valign="top">1025</td>				<td width="9%" valign="top">5</td>				<td width="11%" valign="top">0.0001</td>				<td width="9%" valign="top">1025</td>				<td width="43%" valign="top">1</td>			</tr>			<tr>				<td valign="top" colspan="2">; in</td>				<td width="8%" valign="top">st</td>				<td width="8%" valign="top">dur</td>				<td width="9%" valign="top">freq</td>				<td valign="top" colspan="3">form</td>			</tr>			<tr>				<td valign="top" colspan="2">i 2101</td>				<td width="8%" valign="top">0</td>				<td width="8%" valign="top">30</td>				<td width="9%" valign="top">300</td>				<td valign="top" colspan="3">650</td>			</tr>			<tr>				<td valign="top" colspan="2">i 2102</td>				<td width="8%" valign="top">31</td>				<td width="8%" valign="top">30</td>				<td width="9%" valign="top">300</td>				<td valign="top" colspan="3">650</td>			</tr>		</table>		</p>		<p><font face="Geneva" size="1"><b>Figure 21.1</b> Orchestra and score code for <i>instr 2101 </i>and <i>2102</i>, here a simple <b>fof </b>instrument (<i>2101</i>) is enhanced with real-time <b>xyin </b>control (<i>2102</i>).</font></p>		<p>In <i>instr 2102</i> we have added the <b>xyin</b> opcode. This creates a sensing window 500 pixels wide and 300 pixels tall. The coordinates are updated every 1/100th of a second. With these settings, <i>kx</i> is returned as a number from 0 to 500 and <i>ky</i> will be from 0 to 300.</p>		<p>In the <b>fof</b> opcode, <i>kx</i> is used unaltered to set the formant frequency. The <i>p4</i> value from the score is added to the current horizontal coordinate of the mouse. With our score, the formant frequency will be 650 (<i>p5</i> + 0) when the mouse pointer is at the far left of the sensing window, and move up to 1150 (<i>p5</i> + 500) when the mouse pointer is at the right side of the window. The <i>ky </i>value is scaled before it is used to affect the octaviation index. The range will be from 0 at the top to 6 (300 * .02) at the bottom.</p>		<p>When we run the score in real-time, the mouse will control two of the parameters. You can quickly find intriguing settings by simply moving the mouse into different regions of the sensing window. You can even simulate the effect of envelopes on the particular parameters by moving the mouse over a range of the window.</p>		<p>You can insert <b>xyin</b> into standard Csound instruments that are under development. Once you have an idea of the range of values you may want to use for a particular parameter, simply use the coordinates to move over that range. This allows you to pinpoint the exact values you would like to use in the final instrument. You can also use <b>xyin</b> as a performance tool, but you are limited to only two controls at a time. Additionally, you cannot alter the score during the performance.</p>		<p><font size="4"><b>Using MIDI</b></font></p>		<p>Csound also has a full suite of opcodes to interpret incoming MIDI messages. However, MIDI cannot be mixed into a conventional orchestra and score. An instrument must be completely controlled either by MIDI or from a score file. You cannot simply add a MIDI controller to an orchestra as we added <b>xyin</b>. You must design the instrument with MIDI in mind.</p>		<p>Before covering the MIDI opcodes, you should understand how Csound deals with incoming MIDI messages. Csound assigns the sixteen MIDI channels to instruments 1 through 16. Messages on channel 1 are received by instrument 1, channel 2 goes to instrument 2, and so on. Instruments beyond 16 cannot receive MIDI.</p>		<p>When Csound receives a note-on message on a particular channel, it creates a note for that instrument just as if it were reading from a score. When it receives a matching note-off, it terminates the note for that instrument. Your instruments must be triggered by note-ons and note-offs For example, an instrument which only reacts to controllers still needs to be triggered by a note-on at the beginning of the note, even if that note-on is not used for anything else in the instrument.</p>		<p>Because notes are triggered by note-ons and not by the score, the notes cannot have any parameter fields. In particular, since there is no <i>p3</i> field, Csound does not know how long a note is going to last until it ends. This means that envelopes cannot be dependent on the length of a note. It also means that the release portion of an envelope must be calculated differently, as I will show later.</p>		<p>Csound looks to see if there are any new MIDI messages once per <b>k</b>-period. If any are present, Csound processes the oldest one. Csound handles only one MIDI message per <b>k</b>-period. This means that a six-note chord will be triggered one note at a time, and each attack will be separated by the length of a single <i>ksmps</i>. Csound does not react well to huge streams of MIDI data. For example, since only one controller message can be handled per <b>k</b>-period, sending messages more often will only cause Csound to lag behind and create a larger latency than normal. You can increase responsiveness by making the</p>		<p><b>k</b>-periods shorter, though this has the side effect of slowing down the overall processing speed.</p>		<p>Midi.orc contains five tutorial MIDI instruments which I will describe in detail. I have designed them in mono, using very simple sound generators, to make them runable on as many systems as possible. Of course, you can substitute any Csound sound generation opcodes that your system can support in real-time. These instruments require a MIDI controller which can sense velocity and which has two assignable continuous controllers. I have used controllers 7 and 16, but you can change these as needed.</p>		<p><img src="Image1.gif" width="248" height="230"></p>		<p><font face="Geneva" size="1"><b>Figure 21.2</b> Block diagram of <i>instr 2103</i>, MIDI control of a table-lookup oscillator.</font></p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="477">			<tr>				<td width="11%" valign="top">&nbsp;</td>				<td width="16%" valign="top">instr</td>				<td width="73%" valign="top">2103</td>			</tr>			<tr>				<td width="11%" valign="top">inote</td>				<td width="16%" valign="top">cpsmidi</td>				<td width="73%" valign="top">&nbsp;</td>			</tr>			<tr>				<td width="11%" valign="top">iveloc</td>				<td width="16%" valign="top">ampmidi</td>				<td width="73%" valign="top">10000</td>			</tr>			<tr>				<td width="11%" valign="top">aout</td>				<td width="16%" valign="top">oscil</td>				<td width="73%" valign="top">iveloc, inote, 1</td>			</tr>			<tr>				<td width="11%" valign="top">&nbsp;</td>				<td width="16%" valign="top">out</td>				<td width="73%" valign="top">aout</td>			</tr>			<tr>				<td width="11%" valign="top">&nbsp;</td>				<td width="16%" valign="top">endin</td>				<td width="73%" valign="top">&nbsp;</td>			</tr>		</table>		</p>		<p><font face="Geneva" size="1"><b>Figure 21.3</b> Orchestra code for <i>instr 2103</i>, a simple MIDI instrument.</font></p>		<p>Instrument 3 is almost the simplest possible MIDI instrument. When a note-on is received on channel 1, <b>cpsmidi</b> converts the note number to cycles per second, using a standard tempered scale. <b>ampmidi</b> reads the velocity of the note-on and automatically scales it from 0 to the value given in <i>iscal</i> (in this case, 10000). These values are used to control an <i>oscil</i>, where the velocity becomes the amplitude and the note number becomes the frequency.</p>		<p>Since a MIDI instrument does not read notes from a score, there are no <b>i</b>-card entries in Midi.sco. The score is still used to store the definitions of the <i>f-table</i>s. In addition, Midi.sco contains the following line:</p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="477">			<tr>				<td width="10%" valign="top">f 0</td>				<td width="90%" valign="top">120</td>			</tr>		</table>		</p>		<p>An f0 command instructs Csound to run for a specified amount of time, in this case 120 seconds. These instruments will be playable for 120 seconds, at which time Csound will stop executing. The instruments can be run without an f0 statement, but Csound will not stop executing unless you force it to abort.</p>		<p>Instrument 1 operates just like a standard synthesizer, with one exception: there is no preset limit on the number of notes that may sound at the same time. Instead, this number will be determined by how many notes your system can generate in real-time. This means there is no automatic protection from clipping. With instrument 1, if you have 4 or more full velocity notes, notes will begin to clip.</p>		<p><img src="Image2.gif" width="462" height="288"></p>		<p><font face="Geneva" size="1"><b>Figure 21.4</b> Block diagram for <i>instr 2104</i>, a MIDI instrument with mapped controller messages.</font></p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="477">			<tr>				<td width="13%" valign="top">&nbsp;</td>				<td width="18%" valign="top">instr</td>				<td width="69%" valign="top">2104</td>			</tr>			<tr>				<td width="13%" valign="top">inote</td>				<td width="18%" valign="top">cpsmidi</td>				<td width="69%" valign="top">&nbsp;</td>			</tr>			<tr>				<td width="13%" valign="top">iveloc</td>				<td width="18%" valign="top">ampmidi</td>				<td width="69%" valign="top">10000</td>			</tr>			<tr>				<td width="13%" valign="top">kctl7</td>				<td width="18%" valign="top">midictrl</td>				<td width="69%" valign="top">7</td>			</tr>			<tr>				<td width="13%" valign="top">ictl16</td>				<td width="18%" valign="top">midictrl</td>				<td width="69%" valign="top">16</td>			</tr>			<tr>				<td width="13%" valign="top">itab</td>				<td width="18%" valign="top">table</td>				<td width="69%" valign="top">ictl16+1, 6</td>			</tr>			<tr>				<td width="13%" valign="top">aout</td>				<td width="18%" valign="top">oscil</td>				<td width="69%" valign="top">iveloc, inote, itab</td>			</tr>			<tr>				<td width="13%" valign="top">&nbsp;</td>				<td width="18%" valign="top">out</td>				<td width="69%" valign="top">aout*kctl7*0.0078125</td>			</tr>			<tr>				<td width="13%" valign="top">&nbsp;</td>				<td width="18%" valign="top">endin</td>				<td width="69%" valign="top">&nbsp;</td>			</tr>		</table>		</p>		<p><font face="Geneva" size="1"><b>Figure 21.5</b> Orchestra code for <i>instr 2104</i>, midi instrument with mapped and scaled controllers.</font></p>		<p>Instrument 4 addresses this concern by adding a volume control. In MIDI, controller 7 is customarily used for volume control, though with Csound any controller can be used for any purpose. <i>midictrl</i> 7 reads the current value of controller 7 and stores it in the variable <i>kctl7</i>, which is then used in the <i>out</i> command to scale the output signal. The value 0.0078125 is used in place of division by 128. The line kctl7 * 0078125 turns the controller value (0 -127) into a value between 0 and just less than 1. Csound only reads controllers as 7-bit values (0 - 127). It will not interpret a 14-bit controller value, which some MIDI systems form by combining two 7-bit controller messages.</p>		<p>Instrument 2 also contains a line to read controller 16, which is used to switch between <i>f-table</i>s 1 through 4 for the <b>oscil</b> command. The <i>f-table</i> field in <b>oscil</b> is an <b>i</b> variable and has to be an integer. After we read the controller value into the variable <i>ictl16</i>, we use a table command to look up the integer.</p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="293">			<tr>				<td width="8%" valign="top">f6</td>				<td width="6%" valign="top">0</td>				<td width="14%" valign="top">128</td>				<td width="14%" valign="top">-17</td>				<td width="58%" valign="top">0 1 32 2 64 3 96 4</td>			</tr>		</table>		</p>		<p><b>GEN17 </b>was designed specifically for making stepped translation tables. The table is 128 points long so that we can use the controller values directly. -17 inhibits rescaling so that the values remain between 1 and 4. The controller value is 0 - 127, but <b>table</b> requires an index of 1 - 128, so we add one.</p>		<p><b>i</b> variables can only be determined before a note begins and cannot be changed during the note. If you play instrument 2, you will notice that when you change controller 16, nothing will happen until the next note you play. Also, when you first start instrument 2, no sound will come out until you move controller 7. Csound assumes that all controllers are at 0 when you start. If you want a different starting value you need to move each controller before you begin to play. This will load the current value into Csound. In the case of controller 16, this means that you can choose which table to use before you play any notes.</p>		<p><img src="Image3.gif" width="433" height="306"></p>		<p><font face="Geneva" size="1"><b>Figure 21.6</b> Block diagram of <i>instr 2105</i>, a MIDI instrument with linear MIDI envelope and a &quot;velocity switch&quot; algorithim.</font></p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="365">			<tr>				<td width="15%" valign="top">&nbsp;</td>				<td width="21%" valign="top">instr</td>				<td width="64%" valign="top">2105</td>			</tr>			<tr>				<td width="15%" valign="top">knote</td>				<td width="21%" valign="top">cpsmidib</td>				<td width="64%" valign="top">&nbsp;</td>			</tr>			<tr>				<td width="15%" valign="top">iveloc</td>				<td width="21%" valign="top">ampmidi</td>				<td width="64%" valign="top">10000</td>			</tr>			<tr>				<td width="15%" valign="top">kctl7</td>				<td width="21%" valign="top">midictrl</td>				<td width="64%" valign="top">7, 100</td>			</tr>			<tr>				<td width="15%" valign="top">ivel</td>				<td width="21%" valign="top">veloc</td>				<td width="64%" valign="top">&nbsp;</td>			</tr>			<tr>				<td width="15%" valign="top">itab</td>				<td width="21%" valign="top">table</td>				<td width="64%" valign="top">ivel+1, 6</td>			</tr>			<tr>				<td width="15%" valign="top">kenv</td>				<td width="21%" valign="top">linenr</td>				<td width="64%" valign="top">1, 1, 2, .01</td>			</tr>			<tr>				<td width="15%" valign="top">aout</td>				<td width="21%" valign="top">oscil</td>				<td width="64%" valign="top">iveloc*kenv, knote, itab</td>			</tr>			<tr>				<td width="15%" valign="top">&nbsp;</td>				<td width="21%" valign="top">out</td>				<td width="64%" valign="top">aout*kctl7*0.0078125</td>			</tr>			<tr>				<td width="15%" valign="top">&nbsp;</td>				<td width="21%" valign="top">endin</td>				<td width="64%" valign="top">&nbsp;</td>			</tr>		</table>		</p>		<p><font face="Geneva" size="1"><b>Figure 21.7</b> Orchestra code for <i>instr 2105</i>, a midi instrument with scaled controllers and velocity switching.</font></p>		<p>Instrument 5 shows how a MIDI controller can be initialized to a starting value. The value of 100 in the optional field of midictrl means that Csound will assume that the initial position of the controller is 100, not 0. You will not need to move controller 7 in order to hear sound with this instrument.</p>		<p>Instrument 3 uses note velocity instead of controller 16 to switch between <i>f-table</i>s. Csound frees you to use a single piece of data in multiple ways. Because we have already designed a table to translate a 7-bit value into the integer we need, we use the <i>veloc</i> command instead of the <i>ampmidi</i> command. This returns the velocity of the note as a value between 0 -127, just as controller 16 did in instrument 2, which we can then use in the same table command as in instrument 2.</p>		<p>We have also added an envelope to the note using the <b>linenr</b> opcode, which is a special envelope for use with MIDI instruments. It automatically extends the note to allow for a release after the note-off is received. This is the only way to create a release envelope in Csound. In this case, there is a 1 second attack and a 2 second release. The .01 determines how steep the release is. Smaller numbers make a sharper cutoff.</p>		<p>Finally, we have changed the <b>cpsmidi</b> command to <b>cpsmidib</b>. <b>cpsmidib</b> automatically combines the current pitch bend and the note number in Hertz. It is expressed as a <b>k</b> value so that we can use the pitch wheel continuously while a note is playing. <b>cpsmidib</b> always sets the pitch bend range to +/- 1 semitone.</p>		<p><img src="Image4.gif" width="475" height="332"></p>		<p><font face="Geneva" size="1"><b>Figure 21.8</b> Block diagram of <i>instr 2106</i>, a MIDI instrument with pitch bend and smoothing via the <b>interp</b> opcode.</font></p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="437">			<tr>				<td width="13%" valign="top">&nbsp;</td>				<td width="17%" valign="top">instr</td>				<td width="70%" valign="top">2106</td>			</tr>			<tr>				<td width="13%" valign="top">knote</td>				<td width="17%" valign="top">cpsmidib</td>				<td width="70%" valign="top">12</td>			</tr>			<tr>				<td width="13%" valign="top">inote</td>				<td width="17%" valign="top">cpsmidib</td>				<td width="70%" valign="top">&nbsp;</td>			</tr>			<tr>				<td width="13%" valign="top">iveloc</td>				<td width="17%" valign="top">ampmidi</td>				<td width="70%" valign="top">10000</td>			</tr>			<tr>				<td width="13%" valign="top">kctl7</td>				<td width="17%" valign="top">midictrl</td>				<td width="70%" valign="top">7, 100</td>			</tr>			<tr>				<td width="13%" valign="top">ivel</td>				<td width="17%" valign="top">veloc</td>				<td width="70%" valign="top">&nbsp;</td>			</tr>			<tr>				<td width="13%" valign="top">itab</td>				<td width="17%" valign="top">table</td>				<td width="70%" valign="top">ivel+1, 6</td>			</tr>			<tr>				<td width="13%" valign="top">anote</td>				<td width="17%" valign="top">interp</td>				<td width="70%" valign="top">knote, inote</td>			</tr>			<tr>				<td width="13%" valign="top">kenv</td>				<td width="17%" valign="top">linenr</td>				<td width="70%" valign="top">1, 1, 2, .01</td>			</tr>			<tr>				<td width="13%" valign="top">aout</td>				<td width="17%" valign="top">oscil</td>				<td width="70%" valign="top">iveloc*kenv, anote, itab</td>			</tr>			<tr>				<td width="13%" valign="top">&nbsp;</td>				<td width="17%" valign="top">out</td>				<td width="70%" valign="top">aout*kctl7*0.0078125</td>			</tr>			<tr>				<td width="13%" valign="top">&nbsp;</td>				<td width="17%" valign="top">endin</td>				<td width="70%" valign="top">&nbsp;</td>			</tr>		</table>		</p>		<p><font face="Geneva" size="1"><b>Figure 21.9</b> Orchestra code for <i>instr2106</i>, a midi instrument with controllers, velocity switching, and pitch bend.</font></p>		<p>In instrument 6 we use the pitch bend information to create bends of +/- one octave. We use the optional field of cpsmidib to set the range to 12, which gives us +/- 12 semitones.</p>		<p>Many MIDI synthesizers and controllers do not send full, 14-bit, pitch change messages. Instead, the manufacturers save money by sending 7-bit messages, even if they use the full 14 bits for internal synthesis. 7-bit values often result in audible steps when used to control changes in pitch. If you run instrument 4 without the <b>interp</b> command you will hear the steps clearly. <b>interp</b> smoothes the corners on the steps. <b>interp </b>requires an initial value to begin interpolation. <i>inote</i> is assigned to be the initial value of the note-on message.</p>		<p>There are still only 128 possible locations for the pitch wheel, though we are smoothing the transition between steps. This is a common problem when you use MIDI with Csound: 128 values often do not give an adequate resolution for many Csound parameters, so some smoothing scheme is needed.</p>		<p><img src="Image5.gif" width="556" height="564"></p>		<p><font face="Geneva" size="1"><b>Figure 21.10</b> A block diagram of <i>instr 2107</i>, a midi instrument with a sub-oscillator and velocity controller attack time and a continous cnotrolled low pass filter for EQ.</font></p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="356">			<tr>				<td width="17%" valign="top">&nbsp;</td>				<td width="20%" valign="top">instr</td>				<td width="63%" valign="top">2107</td>			</tr>			<tr>				<td width="17%" valign="top">knote</td>				<td width="20%" valign="top">cpsmidib</td>				<td width="63%" valign="top">&nbsp;</td>			</tr>			<tr>				<td width="17%" valign="top">iveloc</td>				<td width="20%" valign="top">ampmidi</td>				<td width="63%" valign="top">10000</td>			</tr>			<tr>				<td width="17%" valign="top">kctl7</td>				<td width="20%" valign="top">midictrl</td>				<td width="63%" valign="top">7</td>			</tr>			<tr>				<td width="17%" valign="top">ivel</td>				<td width="20%" valign="top">veloc</td>				<td width="63%" valign="top">&nbsp;</td>			</tr>			<tr>				<td width="17%" valign="top">itab</td>				<td width="20%" valign="top">table</td>				<td width="63%" valign="top">ivel+1, 6</td>			</tr>			<tr>				<td width="17%" valign="top">kenv</td>				<td width="20%" valign="top">linenr</td>				<td width="63%" valign="top">1, 1, 2, .01</td>			</tr>			<tr>				<td width="17%" valign="top">kctl16</td>				<td width="20%" valign="top">midictrlsc</td>				<td width="63%" valign="top">16, 2000, 200</td>			</tr>			<tr>				<td width="17%" valign="top">kfilt</td>				<td width="20%" valign="top">table</td>				<td width="63%" valign="top">kctl16, 10</td>			</tr>			<tr>				<td width="17%" valign="top">aout</td>				<td width="20%" valign="top">oscil</td>				<td width="63%" valign="top">iveloc*kenv, knote, itab</td>			</tr>			<tr>				<td width="17%" valign="top">kenv2</td>				<td width="20%" valign="top">linenr</td>				<td width="63%" valign="top">1, (128-iveloc)*.03125, .5, .01</td>			</tr>			<tr>				<td width="17%" valign="top">aout2</td>				<td width="20%" valign="top">oscil</td>				<td width="63%" valign="top">iveloc*kenv2*.5, knote*.5, itab</td>			</tr>			<tr>				<td width="17%" valign="top">afilt</td>				<td width="20%" valign="top">tone</td>				<td width="63%" valign="top">aout+aout2, kfilt</td>			</tr>			<tr>				<td width="17%" valign="top">&nbsp;</td>				<td width="20%" valign="top">out</td>				<td width="63%" valign="top">afilt*kctl7*0.0078125</td>			</tr>			<tr>				<td width="17%" valign="top">&nbsp;</td>				<td width="20%" valign="top">endin</td>				<td width="63%" valign="top">&nbsp;</td>			</tr>		</table>		</p>		<p><font face="Geneva" size="1"><b>Figure 21.12</b> Orchestra code for <i>instr 2107</i>, a midi instrument with a controllers, velocity, mapping, pitch bend, and a sub-oscillator.</font></p>		<p>Instrument 7 shows how a MIDI instrument can grow to be more responsive and more interesting. We have added a second oscillator one octave below the first one, at half volume. This oscillator has its own envelope. The velocity of the note is used to determine the attack time. .03125 = 4 / 128. A velocity of 0 will result in a 4 second attack. A velocity of 127 will cause the attack to be .03125 seconds.</p>		<p>We have also added a low pass filter to the combined output of the two oscillators. The cutoff frequency is set by controller 16. We use a new opcode, <i>midictrlsc</i>, which has a scaling function built in. The range is 2000 and the offset is 200, so kfilt will vary between 200 and 2200 Hz. We use <i>kfilt</i> as the cutoff frequency for the filter.</p>		<p>These instruments show the first steps in designing a MIDI controlled Csound instrument. Csound also has opcodes for reading aftertouch (<b>aftouch</b>) and channel pressure (<b>chpress</b>). These commands are similar to <b>pchbend</b> which we used in instrument 4. Note numbers can also be read as 0 -128 using <b>notenum</b>, or in <b>pch</b> units using <b>pchmidi</b>.</p>		<p><font size="4"><b>The <i>in</i> Opcode</b></font></p>		<p>Real-time synthesis holds the promise of real-time signal processing. In Csound, it is a standard practice to use sound files as input to instruments, either using soundin or by loading the file into a <b>GEN01</b> table. The <b>in</b> commands (<b>in</b>, <b>ins</b>, <b>inq</b>) allow you to retrieve real-time audio input from your computer's analog-to-digital (ADC) converters. Unfortunately, standard desktop systems usually have a large (~300 ms.) latency when using audio from the audio input connections.</p>		<p>The <b>in</b> commands are very similar to <b>soundin</b>, except that no file is specified. They return the current sample values from the analog-to-digital-converter (ADC) in either mono (<b>in</b>), stereo (<b>ins</b>), or quad (<b>inq</b>). There is however, another stage of buffering involved. The ADC hardware buffers the audio and Csound buffers it again. There is no standard way to set the size of these buffers. These buffers increase the amount of latency already present in the output stage.</p>		<p><img src="Image6.gif" width="85" height="93" align="LEFT" hspace="9"></p>		<p>&nbsp;<br>		<br>		<br>		<br>		<br>		<br>		<br>		</p>		<p><font face="Geneva" size="1"><b>Figure 21.11</b> Block diagram of <i>instr 2108</i>, a simple audio input instrument.</font></p>		<p>		<table cellspacing="0" border="0" cellpadding="0" width="477">			<tr>				<td width="9%" valign="top">&nbsp;</td>				<td width="11%" valign="top">instr</td>				<td width="80%" valign="top">2108</td>			</tr>			<tr>				<td width="9%" valign="top">asig</td>				<td width="11%" valign="top">in</td>				<td width="80%" valign="top">&nbsp;</td>			</tr>			<tr>				<td width="9%" valign="top">&nbsp;</td>				<td width="11%" valign="top">out</td>				<td width="80%" valign="top">asig</td>			</tr>			<tr>				<td width="9%" valign="top">&nbsp;</td>				<td width="11%" valign="top">endin</td>				<td width="80%" valign="top">&nbsp;</td>			</tr>		</table>		</p>		<p><font face="Geneva" size="1"><b>Figure 21.12</b> Orchestra code of <i>instr 2108</i>, passing audio direct from input to output.</font></p>		<p>Instrument 8 in In.orc is the simplest possible instrument using real-time input. The input signal is read in mono into <i>asig</i> and then it is immediately sent to the audio outputs. When you run this with In.sco, you will hear the audio input to your computer reflected through the audio output for 30 seconds. It will be delayed by the latency of your system.</p>		<p><font size="4"><b>Conclusion</b></font></p>		<p>R<font size="2">eal-tim</font>e software synthesis and processing is the future of audio production. We are just beginning to see affordable systems which can perform audio manipulation in<font size="2"> </font>r<font size="2">eal-tim</font>e. All of the Csound<font size="2"> </font>r<font size="2">eal-tim</font>e opcodes have been added to a pre-existing structure, which places distinct limitations on their use. Current Csound developers however, are paying more attention to<font size="2"> </font>r<font size="2">eal-tim</font>e possibilities and, slowly, Csound will get faster and more flexible. As computers get faster and manufacturers improve their sound hardware,<font size="2"> </font>r<font size="2">eal-tim</font>e Csound will seem less like an esoteric option and more like an essential feature.	</body></html>