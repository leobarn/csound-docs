<html>	<head>		<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">		<title>Overview</title>		<meta name="generator" content="Adobe GoLive 4">		<meta name="Template" content="C:\APPS\WORD6\TEMPLATE\EREZ1.DOT">	</head>	<body bgcolor="white">		<h1>28. The Design of Equalizers and Compressors for Studio Use</h1>		<h2><font size="4">Erez Webman</font></h2>		<h3>Introduction</h3>		<div align="justify">			<p>Only ten years ago, high-quality music recording and production took place exclusively in big and expansive studios. The equipment used in these studios was usually analog, and the recording was made using a mechanical multitrack tape machine. Since then, this field has undergone a major revolution. The dramatic developments in digital technology gave rise to the appearance of moderately priced hard-disk recording systems. Nowadays, high-quality music production can take place in small studios and even at home. Throughout the recording and mixing stages, various types of signal processing are applied on the audio tracks, changing their sound characteristics either in a subtle or a drastic way. Several examples for such processors are: reverb, noise reduction, filters (equalizers), and dynamic-range processors such as the compressor. Signal processing is frequently used in order to improve the way the recorded signal sounds and to suit its sonic relationships with the other audio tracks in the context of a mix. In a hard-disk recording environment, Csound can be used as an accurate and highly personalized signal processing tool. In this chapter, the design and development of graphic equalizers and dynamics processors are discussed. These processors are amongst the most important units in a typical recording studio.</p>		</div>		<div align="justify">			<p>&nbsp;</p>		</div>		<h3>Filter-Banks and Graphic EQ</h3>		<h3>Introduction</h3>		<div align="justify">			<p>Generally speaking, <i>Filters</i> can be used to shape sound by attenuating or amplifying some of its frequencies. The use of filters in the recording studio is common, and is usually called <i>Equalization (EQ)</i>. Equalization is used in the studio for both technical (corrective) and creative applications. The filtering opcodes provided by Csound are basic filters, such as the two-pole Butterworth implementation (<a href="../../Reference/Manual4.0/sigmod/butterhp.htm"><b>butterlp</b></a>, <a href="../../Reference/Manual4.0/sigmod/butterhp.htm"><b>butterhp</b></a>, <a href="../../Reference/Manual4.0/sigmod/butterhp.htm"><b>butterbp</b></a><b> </b>and <a href="../../Reference/Manual4.0/sigmod/butterhp.htm"><b>butterbr</b></a>). These opcodes allow us to perform drastic spectral attentions. For example, <i>aout butterlp ain,2000 </i>cuts the frequencies above 2KHz with a 12dB-per-octave slope. In the studio, a more delicate tone sculpturing is often required. Typically, one might want to attenuate 2 dB here and amplify by 3 dB there. Such a flexibility can be obtained by using the <i>Graphic Equalizer</i>, which is based on a specific BPF network configuration known as the <i>Filter-Bank</i>. The main goal of this section is the review of the design and development of a graphic EQ in Csound.</p>		</div>		<h3>Frequency Response Curves and Filter-Networks</h3>		<div align="left">			<p>During the development or use of a filter-based signal processor, it is often useful to retrieve the frequency-response curve of the filter, or filter-network in use. A very informative curve can be obtained by scaling the amplitude (Y axis) in dB. It is quite simple to generate such a curve with Csound, by using a <i>sweep signal</i> as the source sound (a sweep signal is a sinus signal with a constant amplitude and a continuously increasing frequency that scans the whole hearing range.) The sweep signal is passed through the analyzed filter (or filter-network) and the filter&#146;s output is saved to a sound file. Then, browsing the output sound file with a commercial wave viewer will reveal the amount of attenuation or amplification applied for each frequency. first provides a Csound code for frequency response curve extraction, followed by an example curve for a LPF with a cut-off point set at 6kHz. Note that the output of this program should be considered as a &quot;pseudo&quot; sound file - it should be viewed only, since its audio information is meaningless.</p>		</div>		<p>;============== FREQUENCY RESPONSE CURVE: ORC FILE ===================</p>		<p>sr = 44100<br>		kr = 44100<br>		ksmps = 1<br>		nchnls = 1<br>		<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">instr</a> 1<br>		;---------------------------------------------------------------------<br>		ksweep <a href="../../Reference/Manual4.0/siggen/line.htm">line</a> 0, p3, 22000 ;Linear line from 0 to 22Khz.<br>		ain <a href="../../Reference/Manual4.0/siggen/oscil.htm">oscil</a> 32000, ksweep, 1 ;Generate a sweep signal.<br>		;---------------------------------------------------------------------<br>		aflt <a href="../../Reference/Manual4.0/sigmod/butterhp.htm"><a href="../../Reference/Manual4.0/sigmod/butterhp.htm">butterlp</a></a> ain, 6000 ;Pass Sweep through the analyzed<br>		; filter (or filter-network.)<br>		;---------------------------------------------------------------------<br>		kflt <a href="../../Reference/Manual4.0/sigmod/samphold.htm">downsamp</a> aflt ;Transform amplitude to dB:<br>		kout = (kflt&gt;1 ? <a href="../../Reference/Manual4.0/valcnv/int.htm">dbamp</a>(<a href="../../Reference/Manual4.0/valcnv/int.htm">abs</a>(kflt)+0.001) : 0)<br>		aout = kout*300 ;Make the results visible.<br>		;---------------------------------------------------------------------<br>		<a href="../../Reference/Manual4.0/sigio/in.htm">out</a> aout<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">endin</a><br>		<br>		;============================= SCO FILE ==============================<br>		f1 0 4096 10 1 ;Sinus ftable used to generate the sweep signal.<br>		i1 0 22 ;Means that each second represents a 1Khz band.<br>		e<br>		;=====================================================================</p>		<center>			<p><font size="1"><i><img height="112" width="180" src="fig1.gif"></i></font></p>		</center>		<div align="justify">			<p><b><a name="_Ref385064031"></a>Figure 1:</b> A Csound code that extract the frequency response curve of a filter, or a filter-network. The graph shown is the frequency response curve of <a href="../../Reference/Manual4.0/sigmod/butterhp.htm"><i>butterlp</i></a> set with a cut-off frequency of 6KHz.</p>		</div>		<div align="justify">			<p>In many cases, it is quite useful to apply a configuration of several filters to shape the sound&#146;s tone. There is obviously a major difference between parallel and serial connection of filters. second demonstrates some proper and improper filter configurations.</p>		</div>		<center>			<p><font size="1"><i><img height="349" width="835" src="fig2.gif"></i></font></p>		</center>		<div align="justify">			<p><b><a name="_Ref385066449"></a>Figure 2:</b> <b>(a,b)</b> Connecting four identical BPFs in series gives much more isolated results than using a single BPF. <b>(c)</b> Serially connected HPF and BPF cuts both the high and low frequencies. <b>(d)</b> Connecting a HPF and a LPF in parallel is usually an improper configuration. <b>(e)</b> Serially connecting two different-band BPFs is probably a bad idea: for obvious reasons, the whole sound is drastically attenuated. <b>(f)</b> Two different-band BPFs should be connected in parallel to give the desired &quot;twin-peaks&quot; effect.</p>		</div>		<p><b>Filter-Banks</b></p>		<div align="justify">			<p>A <i>Filter-Bank</i> is a parallel filter-network configuration consists of band-pass filters which cover the whole hearing range, such as depicted in third. The filter-bank divides the original input sound into several audio signals, each containing a different frequency range of the sound. A summation of all the filter-bank outputs will reconstructs the original sound. When using a filter-bank, each frequency band can be separately manipulated. Various signal processes are based on filter-banks. In our case, flexible filtering can be achieved by separately attenuating or amplifying each of the bands, and then reconstructing the sound by summing up all the modified bands. This process is called <i>Graphic Equalization (EQ)</i> and is demonstrated in third.</p>		</div>		<center>			<p><font size="1"><i><img height="293" width="347" src="fig3.gif"></i></font></p>		</center>		<div align="justify">			<p><b><a name="_Ref385413270"></a>Figure 3:</b> A schematic flow of a filter-bank and a graphic equalizer. A filter-bank is a parallel BPF network. Each filter covers a different frequency range, while all the filters cover the whole hearing spectrum. For musical applications, the distribution of the filter frequencies and width is logarithmic. In the above example, the distribution is of one octave.</p>		</div>		<div align="justify">			<p>Before getting deeper into graphic equalization, the filter-bank properties should be discussed. The following elements characterize a filter-bank:</p>		</div>		<div align="justify">			<ul>				<li><b>Number of Frequency Bands:</b> Generally, the more frequency bands are, the narrower these bands will be. In some situations a large number of bands is desired, while in others, a relatively small number will do better.</div>			<div align="justify">				<li><b>BPF Spacing and Width:</b> For musical applications, the natural distribution of the BPF frequencies and width is logarithmic, and is usually measured in octave units third is an example of a one-octave filter-bank.)</div>			<div align="justify">				<li><b>Integrity of the Re-constructed Sound:</b> When the outputs of a filter-bank are summed without any further processing, a successive decomposition and reconstruction of the original input sound takes place. The degree of similarity between the input and the output sounds is a good indication for the quality of the filter-bank. This rule is especially relevant for graphic EQ design.</div>			<div align="justify">				<li><b>Overlapping Between Frequency Bands:</b> The amount and nature of frequency overlapping between each two adjacent BPFs are important characteristics of a filter-bank. In some situations, obtaining less overlapping or even an ideal total isolation is desired, while for other applications, overlapping is preferred. Practically, a minimal overlapping is unavoidable. In addition, trying to minimize the overlapping might degrade the integrity of the re-constructed sound.			</ul>		</div>		<h3>A Graphic Equalizer Implementation</h3>		<p>;============== 1/3 OCTAVE GRAPHIC EQUALIZER: ORC FILE ===============<br>		sr = 44100<br>		kr = 4410<br>		ksmps = 10<br>		nchnls = 1<br>		<br>		;-------------------------------1. INSTRUMENT #1: SOUND-FILE READER--<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">instr</a> 1<br>		gasig <a href="../../Reference/Manual4.0/sigio/in.htm">soundin</a> &quot;f:\kaza\egtr.wav&quot; ;Read globally for all modules.<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">endin</a><br>		<br>		;-------------------------------2. A SINGLE-BAND EQ MODULE-----------<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">instr</a> 2<br>		iq = 4.318<br>		ifrq = p4 ;Center freq. of current band.<br>		iamp = <a href="../../Reference/Manual4.0/valcnv/int.htm">ampdb</a>(p5) ;Amplification of current band.<br>		icmpamp = <a href="../../Reference/Manual4.0/valcnv/int.htm">ampdb</a>(-10) ;Global amplification.<br>		asig = gasig ;Get sound from global reader.<br>		asig <a href="../../Reference/Manual4.0/sigmod/butterhp.htm">butterbp</a> asig,ifrq,ifrq/iq ;Apply BPF on the sound.<br>		<a href="../../Reference/Manual4.0/sigio/in.htm">out</a> asig*iamp*icmpamp ;Send to output with proper amplification.<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">endin</a><br>		<br>		============================ SCO FILE ================================<br>		;-------------------------------1. INVOKE GLOBAL SOUND-FILE READER ---<br>		i1 0 5<br>		;-------------------------------2. INVOKE SINGLE-BAND EQ MODULES -----<br>		;-------dur-freq--amp(db)<br>		i2 0 5 32 0 ;------ SOME NOTES ABOUT PROGRAMMING STYLE -----<br>		i2 . . 40 0 ; This Csound program is written in a &quot;parallel&quot;<br>		i2 . . 50 0 ; style. Each instance of instr 2 is responsible<br>		i2 . . 63 0 ; for a single band. The results of all the<br>		i2 . . 80 0 ; instances are sent to the output (and summed<br>		i2 . . 101 0 ; by Csound.) Due to performance considerations<br>		i2 . . 127 0 ; the input sound is read only once (instr 1.)i2 . . 160 0 ;<br>		i2 . . 201 0 ; This program can also be written in a &quot;serial&quot;<br>		i2 . . 253 0 ; manner. Such a code looks like:<br>		i2 . . 320 0 ; ..............................................<br>		i2 . . 403 0 ; instr 1<br>		i2 . . 508 0 ; asig <a href="../../Reference/Manual4.0/sigio/in.htm">soundin</a> &quot;f:\kaza\egtr.wav&quot;<br>		i2 . . 640 0 ; aband1 <a href="../../Reference/Manual4.0/sigmod/butterhp.htm">butterbp</a> asig, 32, 32/iq<br>		i2 . . 806 0 ; aband2 <a href="../../Reference/Manual4.0/sigmod/butterhp.htm">butterbp</a> asig, 40, 40/iq<br>		i2 . . 1016 0 ; aband3 <a href="../../Reference/Manual4.0/sigmod/butterhp.htm">butterbp</a> asig, 50, 50/iq<br>		i2 . . 1280 0 ; ...<br>		i2 . . 1613 0 ; and so on<br>		i2 . . 2032 0 ; ..............................................<br>		i2 . . 2560 0 ;<br>		i2 . . 3225 +20 ; For the graphic EQ program, and in many other<br>		i2 . . 4064 0 ; cases, the parallel approach results in a more<br>		i2 . . 5120 0 ; modular and compact code.<br>		i2 . . 6451 0 ;<br>		i2 . . 8127 0 ;<br>		i2 . . 10240 0 ;<br>		i2 . . 12902 0 ;<br>		i2 . . 16255 0 ;<br>		i2 . . 20480 0 ;<br>		;=====================================================================</p>		<div align="justify">			<p><img height="320" width="463" src="fig4.gif"></p>			<p><b><a name="_Ref385419038"></a>Figure 4:</b> A Csound implementation of a Graphic Equalizer.</p>			<p>fourth presents a Csound implementation of a 1/3 octave graphic EQ (Some notes regarding the programming style used can be found in the body of the score file.) The amount of band attenuation or amplification should be specified in the score file, as demonstrated. For convenience, these settings are specified in dB, so a value of 0 means no change, a positive value specifies an amplification, and a negative value indicates attenuation. In a 1/3 octave filter-bank the frequency ratio between every two adjacent BPFs is 2<sup>1/3</sup> (approximately 1.26). The width of each BPF is assigned by the expression <i>ifrq/iq</i> where <i>ifrq</i> is the center-frequency of the filter, and <i>iq</i> is a constant identical to all the BPFs. The larger <i>iq</i> is, the narrower the filters will be. On one hand, if <i>iq</i> is too high, the frequency response of the filter-bank will contain &quot;drops&quot; where frequencies are not covered by any BPF. On the other hand, if <i>iq</i> is relatively low, overlapping among adjacent BPFs will be introduced (which is not always a bad idea, as discussed before). The &quot;natural&quot; <i>iq</i> for a filter-bank with a distribution of <i>x </i>octaves can be calculated according to the following formula:</p>			<p><img src="Image1.gif" width="67" height="31"> In our case, <i>x=1/3</i>, so: <img src="Image2.gif" width="75" height="31"> 4.318.</p>			<p>For one-octave spacing, the formula returns 1.414, and for half-octave: 2.871. The frequency response (&quot;integrity&quot;) of the filter-bank implemented above is shown in fiftha. Globally, the curve is flat. However, along the spectrum, several local drops of up to 2dB are introduced. This phenomenon is unavoidable, given this <i>iq </i>value, and is caused by the shape and phase response of the Butterworth band-pass filter. Hence, any signal passing through the graphic EQ will be slightly colored, even when no amplification or attenuation were specified. In practice, this type of coloration is very subtle and it is usually quite unnoticeable. This filter-bank does introduce some overlapping among adjacent BPFs. Therefore, when specifying a drastic attenuation of a specific band, some of the frequencies designated for attenuation would still pass through the adjacent BPFs. For a more effective attenuation of a specific band, its neighbor bands should be attenuated as well. Anyway, as demonstrated in fifthe, this maximum attenuation of a band is bounded, thus the actual attenuation is lesser than the values specified in the score file. Amplification is less problematic, as can be seen in fifthc. The <i>icmpamp</i> parameter should be used to amplify or attenuate the overall output signal. This parameter could be used to compensate for signal loss or to avoid clipping. For the EQ suggested in fourth, a value of -10dB is a good starting point.</p>			<p>A setting with a lower <i>iq</i> value, such as 2.2, introduces a larger overlapping, resulting in a smoother frequency response (i.e. no -2dB drops, as shown in fifthb.) However, a higher degree of overlapping causes the actual maximal attenuation to be even more limited (fifthf.) The lower value of <i>iq</i> yields wider bands, which are not necessarily a bad idea - it just has a different color.</p>		</div>		<center>			<p><font size="1"><i><img height="262" width="347" src="fig5.gif"></i></font></p>		</center>		<div align="justify">			<p><b><a name="_Ref385426585"></a>Figure 5:</b> Some typical frequency response of the 1/3 octave graphic EQ and the modified overlapping graphic EQ (the one with <i>iq=2.2</i>.)</p>		</div>		<div align="justify">			<p>It is possible to drastically reduce the overlapping among adjacent bands, by making the following modifications to the Csound code shown in fourth: In the ORC file, replace the statement <i>asig <a href="../../Reference/Manual4.0/sigmod/butterhp.htm">butterbp</a> asig,ifrq,ifrq/iq </i>with:</p>		</div>		<p>asig <a href="../../Reference/Manual4.0/sigmod/butterhp.htm">butterbp</a> asig,ifrq,ifrq/iq<br>		asig <a href="../../Reference/Manual4.0/sigmod/butterhp.htm">butterbp</a> asig,ifrq,ifrq/iq<br>		asig <a href="../../Reference/Manual4.0/sigmod/butterhp.htm">butterbp</a> asig,ifrq,ifrq/iq<br>		asig <a href="../../Reference/Manual4.0/sigmod/butterhp.htm">butterbp</a> asig,ifrq,ifrq/iq</p>		<div align="justify">			<p>So each filter-bank band will be filtered by four serially connected BPFs (to review the impact of this change, refer to secondb.) In addition, change the <i>iq</i> value to 2.85. Then, edit the score file and change the line <i>i2 . . 20480</i> to <i>i2 . . 18000</i>. The modified filter-bank yields much narrower frequency bands and a significantly reduced amount of overlapping. In such a configuration, the formula for <i>iq</i> derivation does not hold. The new <i>iq</i> value was set through trial and error, thus optimizing the overall frequency response of the new filter-bank. sixth demonstrates some typical response of this graphic EQ.</p>		</div>		<center>			<p><font size="1"><i><img height="176" width="347" src="fig6.gif"></i></font></p>		</center>		<div align="justify">			<p><b><a name="_Ref385426333"></a>Figure 6:</b> A typical frequency response of the narrow 1/3 octave graphic EQ. This EQ is implemented by applying four BPFs in series for each frequency band. <b>(a)</b> The filter-bank&#146;s frequency response is flat, more or less. The roll-off at 19KHz is unavoidable, but shouldn&#146;t be a real problem in most of the cases. <b>(b)</b> This EQ is capable of very deep and narrow attenuation. <b>(c)</b> Amplification is pretty narrow. However, in extreme settings, some artifacts are introduced. <b>(d)</b> The artifacts of example (c) can be easily minimized by adding some amplification to the adjacent bands.</p>		</div>		<h3>Compressors and their Applications</h3>		<h3>Introduction</h3>		<div align="justify">			<p><i>Dynamics processors </i>manipulate the dynamic range properties of audio signals. In other words, these processes alter the relationships of the loud parts to the soft ones. This family of processors includes <i>compressors</i>, <i>limiters</i>, <i>expanders</i>, <i>noise-gates</i> and some more special algorithms. Altering the dynamics of a sound can substantially change the way it is perceived by the brain, and can improve the way a specific track sounds in a context of a mix. Compressors are probably one of the most useful signal processing units in the recording studio. Generally speaking, a compressor reduces the dynamic range of a signal, by attenuating the amplitude of the its loud parts. When used properly, compression can make an acceptable recording sounds as a great one.</p>		</div>		<div align="justify">			<p>Generally speaking, a <i>compressor</i> gets an input audio signal, and returns a compressed signal as an output. There main predetermined parameters which are used to control the compressor&#146;s behavior are summarized in seventh. eighth demonstrates the compressor effect.</p>		</div>		<p>		<table border="0" cellspacing="2" cellpadding="3">			<tr>				<td valign="top">					<div align="justify">						Threshold dB</div>				</td>				<td width="82%" valign="top">					<div align="justify">						Whenever the input amplitude exceeds the threshold, gain-reduction is applied.</div>				</td>			</tr>			<tr>				<td valign="top">					<div align="justify">						Ratio</div>				</td>				<td width="82%" valign="top">					<div align="justify">						Controls the amount of gain reduction to be applied. Ratio of 1 means no compression. Ratio of 3 means that for each 3dB increase in the input amplitude, the output amplitude is increased in only 1dB.</div>				</td>			</tr>			<tr>				<td valign="top">					<div align="justify">						Attack Time</div>				</td>				<td width="82%" valign="top">					<div align="justify">						The compressor&#146;s reaction-time to an increase in the input signal&#146;s amplitude.</div>				</td>			</tr>			<tr>				<td valign="top">					<div align="justify">						Release Time</div>				</td>				<td width="82%" valign="top">					<div align="justify">						The compressor&#146;s reaction-time to a decrease in the input signal&#146;s amplitude.</div>				</td>			</tr>			<tr>				<td valign="top">					<div align="justify">						Compensation</div>				</td>				<td width="82%" valign="top">					<div align="justify">						Amount of amplification applied on the signal after it was compressed.</div>				</td>			</tr>		</table>		</p>		<div align="justify">			<p><img height="373" width="835" src="fig7.gif"></p>			<p><b><a name="_Ref384995189"></a>Figure 7:</b> The compressor&#146;s main predetermined parameters.</p>			<p>A slow attack time (typically 50-300 msec.) keeps the original transients unaffected, while a faster attack (e.g. 1 msec.) squeezes the whole envelope. Typical release time values range from 30 msec to 3 seconds. Tips on using the compressor are beyond the scope of this book. Throughout the rest of this chapter, the design of a Csound compressor will be described.</p>		</div>		<center>			<p><font size="1"><i><img height="287" width="345" src="fig8.gif"></i></font></p>		</center>		<div align="justify">			<p><b><a name="_Ref384995366"></a>Figure 8:</b> The effect of compression on the sound&#146;s envelope.</p>		</div>		<h3>Designing a Compressor - The First Step</h3>		<div align="justify">			<p>Generally speaking, a compressor algorithm consists of two main elements: the <i>Envelope Detector</i> and the <i>Gain-Reduction Unit</i> (ninth.) The envelope detector generates the envelope of the input signal, and the gain-reduction unit applies the actual compression on the signal. Usually, the envelope detector takes care of the attack and release parameters (for example, if the specified attack time is slow, the generated envelope should respond slowly to an increase in the input signal&#146;s amplitude.) The gain-reduction unit calculates the gain reduction to be applied according to the generated envelope, the threshold and the ratio settings.</p>		</div>		<center>			<p><font size="1"><i><img height="158" width="347" src="fig9.gif"></i></font></p>		</center>		<div align="justify">			<p><b><a name="_Ref384995529"></a>Figure 9:</b> The schematic structure of a compressor.</p>		</div>		<div align="justify">			<p>tenth presents a simple Csound compressor program. The program gets an input sound file and compresses it according to the parameters specified in the score file - threshold<i>,</i> ratio, attack, release and compensation. Part 3 of the program contains a simple envelope follower code, and part 4 consists of the gain reduction unit code.</p>		</div>		<p>;==================== SIMPLE COMPRESSOR: ORC FILE ====================<br>		sr = 44100<br>		kr = 44100<br>		ksmps = 1 ;a setting of kspmps=1 is crucial!<br>		nchnls = 1<br>		<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">instr</a> 1<br>		;-------------------------------1. ENTRY PARAMETERS -----------------<br>		ithresh = p4 ;threshold - in dB (-96 to 0)<br>		iratio = 1/p5 ;ratio - a number &gt;= 1<br>		iattack = p6 ;attack time - in seconds<br>		irelease = p7 ;release time - in seconds<br>		ireamp = <a href="../../Reference/Manual4.0/valcnv/int.htm">ampdb</a>(p8) ;compensation - in dB, usually &gt;= 0<br>		;-------------------------------2. INPUT SOUND -----------------------<br>		ain <a href="../../Reference/Manual4.0/sigio/in.htm">soundin</a> &quot;f:\kaza\violin.wav&quot;<br>		;-------------------------------3. ENVELOPE FOLLOWER -----------------<br>		ita = 1/(iattack*44100)<br>		itr = 1/(irelease*44100)<br>		kenv <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 0<br>		kin <a href="../../Reference/Manual4.0/sigmod/samphold.htm">downsamp</a> ain ;transform to K-type signals.<br>		kin = <a href="../../Reference/Manual4.0/valcnv/int.htm">abs</a>(kin) ;use absolute value of input signal.<br>		kenv = (kin &gt; kenv ? (kenv*(1-ita)+kin*ita) : kenv*(1-itr))<br>		;-------------------------------4. GAIN REDUCTION UNIT ---------------<br>		ihedroom = <a href="../../Reference/Manual4.0/valcnv/int.htm">dbamp</a>(32768) ;value for 16 bit sounds<br>		kenvd = <a href="../../Reference/Manual4.0/valcnv/int.htm">dbamp</a>(kenv+0.0001)-ihedroom ;translate env. to dB<br>		kreduce = (kenvd &gt;= ithresh ? (kenvd-ithresh)*(iratio-1) : 0)<br>		areduce <a href="../../Reference/Manual4.0/sigmod/samphold.htm">interp</a> kreduce<br>		aout = ain*<a href="../../Reference/Manual4.0/valcnv/int.htm">ampdb</a>(areduce)*ireamp ;perform compression<br>		<a href="../../Reference/Manual4.0/sigio/in.htm">out</a> aout<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">endin</a><br>		<br>		;============================= SCORE FILE ============================<br>		;-----Dur.--Thr.--Ratio--Attack--Release--Compensate<br>		i1 0 4 -20 4 0.001 0.1 0<br>		e<br>		;=====================================================================</p>		<div align="justify">			<p><b><a name="_Ref384997551"></a>Figure 10:</b> A Csound compressor code, based on a simple envelope follower algorithm.</p>			<p>The envelope follower updates <i>kenv</i> which holds the temporary envelope value. <i>kenv</i> values are in the range 0..32768. The gain reduction unit translate <i>kenv</i> to dB scale (stored in <i>kenvd</i>). The heart of the gain-reduction unit is the statement <i>kreduce = (kenvd&gt;=ithresh ? (kenvd-ithresh)*(iratio-1)</i>. <i>kreduce</i> holds the amount of gain-reduction (in dB) to be applied on the input signal. If <i>kenvd</i> is lesser than the specified threshold, no gain-reduction is performed (i.e. <i>kreduce=0</i>.)</p>			<p>The suggested envelope follower is a simple and fast method to estimate the input signal envelope, according to the given attack and release values. However, it has some annoying weaknesses. To investigate this method, the following experiment was performed: Consider the audio signals <i>aina</i> (signal A: a 200Hz sinus waveform) and <i>ainb</i> (signal B: a richer waveform) synthesized by the code appears in eleventh. The positive part of their waveform is shown in figures twelftha,b.</p>		</div>		<p>kinamp <a href="../../Reference/Manual4.0/siggen/line.htm">linseg</a> 0,0.2,0,0.0001,1,0.5,0.5,0.5,1,0.5,0,3,0<br>		aina <a href="../../Reference/Manual4.0/siggen/oscil.htm">oscil</a> 30000*kinamp,200,1<br>		apart1 <a href="../../Reference/Manual4.0/siggen/oscil.htm">oscil</a> 1, 258, 1 ;we assume that table 1<br>		apart2 <a href="../../Reference/Manual4.0/siggen/oscil.htm">oscil</a> 1, 520, 1 ; is a sinus wave.<br>		apart3 <a href="../../Reference/Manual4.0/siggen/oscil.htm">oscil</a> 2, 1400, 1<br>		apart4 <a href="../../Reference/Manual4.0/siggen/oscil.htm">oscil</a> 3, 2300, 1<br>		ainb = (apart1+apart2+apart3+apart4)*4400*kinamp</p>		<div align="justify">			<p><img height="336" width="545" src="fig11.gif"></p>			<p><b><a name="_Ref384997774"></a>Figure 11:</b> The two audio signals used to test the envelope follower.</p>		</div>		<center>			<p><font size="1"><i><img height="445" width="416" src="fig12.gif"></i></font></p>		</center>		<div align="justify">			<p><b><a name="_Ref385000986"></a>Figure 12:</b> <b>(a,e)</b> The positive part of the two test signals <i>aina </i>and <i>ainb</i>. <b>(b,c,d,f,g,h) </b>The envelopes of <i>aina</i> and <i>ainb </i>generated by the simple envelope follower (under various attack time values)</p>		</div>		<div align="justify">			<p>A good envelope follower should return similar envelopes for both of the tested signals. The envelopes generated by the suggested envelope follower, with various attack settings are described in twelfth. The results of this experiment reveals two undesired effects: First, for a given attack value, signal B&#146;s envelope is substantially softer than signal A&#146;s. Second, for each signal, the slower the attack value, the softer the envelope is. For all the above settings, it is desired that the envelope value at time &raquo; 1.4 sec would be around 100% (this definitely didn&#146;t happen.) Despite the problems mentioned above, this envelope follower is good enough for many applications - especially when a fast attack value (such as 1 msec) is used. The generated envelope will be smooth enough if <i>attack+release &#179; 30</i> msec. Later in this chapter, a better envelope detection method will be described.</p>		</div>		<h3>Using RMS as an Envelope Follower</h3>		<div align="justify">			<p>RMS is a technique used to measure the &quot;average&quot; energy of a signal, within a specified window of time. In Csound, the rms opcode can be used to obtain these values. Implementing a &quot;straight-forwards&quot; RMS envelope follower is trivial: Replace part 3 of the compressor code shown in tenth with the following Csound code:</p>		</div>		<p>;-------------------------------3. ENVELOPE FOLLOWER ---------------</p>		<p>iwinsize = 1/iattack<br>		kenv rms ain,iwinsize<br>		;----------------------------------------------------------------------------------<br>		</p>		<div align="justify">			<p>There are two main problems with this approach: First, the attack and release cannot be controlled separately - in the above code, the attack value is used to determine both the reaction time for gain-increase and gain-decrease. Second, a setting of <i>attack &lt; 30 </i>msec may cause problems: thirteenth demonstrates the RMS envelope follower behavior. For relatively large attack values, such as 0.1 seconds, the generated envelope is smooth, yet, slow-responding (thirteenthb.) For a faster attack, such as the one demonstrated in thirteenthc, the envelope responds fast enough. However, it contains <i>ripples</i> (thirteenthd.) Once the gain-reduction unit recieves a substantially rippled envelope, it will repeatedly change the gain-reduction applied on the input signal. Since these ripples have an audible frequency, the result would be a distorted output signal. Hence, for compression applications, this method can be used with a minimal useable attack value of about 30 msec (too slow for most of the applications.)</p>		</div>		<p><font face="Arial">kamp <a href="../../Reference/Manual4.0/siggen/line.htm">linseg</a> 0, 0.1, 0, 0.0001, 16000, 0.2, 16000, 0.02, 32000,<br>		0.02, 16000, 0.2, 32000, 0.0001, 0, 1, 0<br>		ain <a href="../../Reference/Manual4.0/siggen/oscil.htm">oscil</a> kamp,400,1</font></p>		<center>			<p><font size="1"><i><img height="565" width="835" src="fig13.gif"></i></font></p>		</center>		<div align="justify">			<p><b><a name="_Ref385001474"></a>Figure 13:</b> Envelope generation based on RMS metering. The above Csound code creates the tested input signal.</p>		</div>		<h3>A Better Envelope Follower</h3>		<div align="justify">			<p>In this section, a new envelope detection method is presented. This method gives much more consistent results than the method presented in tenth, and doesn&#146;t suffer from the limitations of the RMS envelope follower previously discussed. To combine this method with our Csound compressor, replace parts 3 and 4 of the code (tenth) with the one presented in fourteenth.</p>		</div>		<p>================ ADD THIS STATEMENT TO THE SCORE FILE ================<br>		f2 0 4097 6 1 4097 0 to<br>		======================================================================<br>		;-------------------------------3. ENVELOPE FOLLOWER------------------<br>		;----------------------------------3.1 INITIALIZATION-----------------<br>		irelcrvi = 2 ;id of ftable for release_curve.<br>		irelcrvs = 4096 ;size of ftable for release_curve.<br>		kptime <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 0 ;reset time of first peak.<br>		kpeak <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 0 ;reset value of first peak.<br>		ktime <a href="../../Reference/Manual4.0/siggen/line.htm">line</a> 0,p3,p3 ;establish a clock.<br>		;----------------------------------3.2 MAIN ENV. FOLLOW CODE----------<br>		kin <a href="../../Reference/Manual4.0/sigmod/samphold.htm">downsamp</a> ain ;transform to K-type signals.<br>		kin = <a href="../../Reference/Manual4.0/valcnv/int.htm">abs</a>(kin) ;use absolute value of input signal.<br>		;----------------------------------3.3 CALCULATE RELEASE WEIGHT-------<br>		kindex = irelcrvs*(ktime-kptime)/irelease<br>		kindex = (kindex &gt;= (irelcrvs-1) ? (irelcrvs-1) : kindex)<br>		kweight <a href="../../Reference/Manual4.0/siggen/table.htm">tablei</a> kindex, irelcrvi, 0, 0, 0<br>		krval = kweight*kpeak<br>		<a href="../../Reference/Manual4.0/pgmctl/igoto.htm">if</a> krval&gt;kin kgoto releasestage<br>		;----------------------------------3.4 DEAL WITH ATTACK STAGE---------<br>		kptime = ktime ;set new peak time.<br>		kpeak = kin ;set new peak value.<br>		kenv = kin ;set envelope to new peak value.<br>		kgoto cont ;end of envelope follower.<br>		;----------------------------------3.5 DEAL WITH RELEASE STAGE--------<br>		releasestage:<br>		kenv = krval ;set envelope according to the value<br>		; derived from the release-curve.<br>		cont:<br>		;---------------------------------------------------------------------<br>		;-------------------------------4. GAIN REDUCTION UNIT ---------------<br>		iatckfr = 1/iattack<br>		ihedroom = <a href="../../Reference/Manual4.0/valcnv/int.htm">dbamp</a>(32768) ;value for 16 bit sounds<br>		kenvd = <a href="../../Reference/Manual4.0/valcnv/int.htm">dbamp</a>(kenv+0.0001)-ihedroom ;translate env. to dB<br>		kreduce = (kenvd &gt;= ithresh ? (kenvd-ithresh)*(iratio-1) : 0)<br>		areduce <a href="../../Reference/Manual4.0/sigmod/samphold.htm">interp</a> kreduce<br>		areduce <a href="../../Reference/Manual4.0/sigmod/butterhp.htm">butterlp</a> areduce,iatckfr ;apply attack response<br>		aout = ain*<a href="../../Reference/Manual4.0/valcnv/int.htm">ampdb</a>(areduce)*ireamp ;perform compression<br>		;---------------------------------------------------------------------</p>		<div align="justify">			<p><b><a name="_Ref385001997"></a>Figure 14:</b> The improved envelope follower. To create a compressor based on this algorithm, replace parts 3 and 4 of the code shown in tenth with the above code, and change the score file as instructed.</p>		</div>		<div align="justify">			<p>Principally, the envelope detection algorithm follows the input signal&#146;s absolute value whenever the input value is higher than the envelope value of the previous sample. This is called an <i>attack stage</i>. When the previous envelope value is higher than the current input signal (absolute) value, the algorithm enters a <i>release stage</i>, in which the envelope &quot;glides&quot; above the input signal, and gently drops, according to shape of the release-curve defined in ftable 2. The access to ftable 2 is performed in part 3.3 of the code. The release stage terminates when a new attack stage is triggered - this decision is performed by the statement <i>if krval&gt;kin kgoto releasestage</i>. The envelope follower algorithm takes care of the release response time. However, the attack response time is not handled. Actually, this treatment is postponed to the gain-reduction stage. To apply the attack response time, the code for the gain-reduction unit was slightly changed, by adding the statements: 1) <i>iatckfr = 1/iattack </i>2) <i>areduce butterlp areduce,iactkfr</i>. These statements apply a low-pass filter on the <u>control</u>-signal <i>areduce</i>. Please note that applying a LPF on a control signal introduces a response-time &quot;laziness&quot; in the signal.</p>		</div>		<div align="justify">			<p>A similar experiment to the one presented in twelfth was also performed on this algorithm. The results are shown in fifteenth. Please compare the results with and twelfth. Although this envelope follower is not always ripple-free, this compressor usually provides very clean results when <i>attack &gt; 1 msec </i>and <i>release &gt; 40 msec</i>.</p>		</div>		<center>			<p><font size="1"><i><img height="545" width="347" src="fig15.gif"></i></font></p>		</center>		<div align="justify">			<p><b><a name="_Ref385002282"></a>Figure 15:</b> The envelopes generated by the improved envelope follower (under various attack time values.) Compare the results with twelfth.</p>		</div>		<h3>Using Look-Ahead Information To Achieve Better Envelope Detection</h3>		<div align="justify">			<p>The envelope follower discussed above is a pretty good performer. However, the usage of an attack time faster than 1 msec or a release time faster than 40 msec tends to generate ripples which translate to audible distortion in the compressed signal. This envelope follower can be improved in various ways. The Csound code found in sixteenth is an implementation of a compressor, based on such an improvement. As can be seen, the algorithm is quite complicated. Detailed discussion of this envelope-detection method is beyond the scope of this chapter. To make a long story short, this is basically the same algorithm discussed above, with an additional network of ten &quot;future peak-detectors&quot;. Each such a detector constantly &quot;looks at the future&quot;, trying to locate new peaks which are about to arrive in the next <i>la</i> seconds (<i>la </i>is a predetermined parameter controlled by the user.) If the envelope is in a release stage and a &quot;future&quot; peak which is higher than the current envelope value is detected, the gliding envelope freezes until the expected peak arrives. This mechanism efficiently eliminates various types of distortion which otherwise would have been applied on the compressed sound. This implementation uses the &quot;parallel&quot; programming style previously discussed: Instrument 1 is the global sound-file reader. Each instance of instrument 2 is an independent future peak detector - so the ten instances establish the detection network. Instrument 3 contains the main envelope follower and the gain-reduction unit. It uses the future peak information collected by instrument 2 instances by accessing the global variables <i>gklap0..gklap9</i>. Owing to the look-ahead concept, the output signal is delayed in <i>la</i> seconds. It also means that the algorithm is not a pure &quot;real-time&quot; one. However, this envelope detector generally provides very smooth, reliable and fast-responding results.</p>		</div>		<div align="justify">			<p>The predetermined parameters of this compressor are <i>threshold</i> (dB), <i>ratio</i> ( &gt; 1), <i>attack</i> (sec.), <i>release</i> (sec.), <i>compensation</i> (dB) and <i>la (lookahead)</i> (sec.). These parameters should be specified in the score file&#146;s <i>i3</i> line. The <i>lookahead</i> parameter should also be specified in the <i>i2</i> line. <i>Attack</i> can have any value greater than 0.000045 seconds. <i>Release</i>&#146;s safe values can be 0.03 seconds or higher, while smaller values are usually fine, but might alter slight distortion to <u>some</u> input signals. A good starting-point for <i>lookahead</i> setting is the value of <i>Release</i>. However, feel free to increase this value, especially when <i>release</i> is very fast.</p>		</div>		<p>;=====================================================================<br>		; A HARD-KNEE COMPRESSOR BASED ON AN ENVELOPE-DETECTOR<br>		; WITH A LOOK-AHEAD PEAK ANTICIPATION NETWORK<br>		; Written by Erez Webman 1997 (C).<br>		;=====================================================================<br>		;============================= ORC FILE ==============================<br>		;=== General settings ================================================<br>		sr = 44100<br>		kr = 44100<br>		ksmps = 1 ;A setting of ksmps=1 is crucial!<br>		nchnls = 1<br>		;=====================================================================<br>		;=== INSTRUMENT 1: READING SOUND FILE ===============================<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">instr</a> 1<br>		gasig <a href="../../Reference/Manual4.0/sigio/in.htm">soundin</a> &quot;f:\kaza\violin.wav&quot; ;Sound file is read globally.<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">endin</a><br>		;=====================================================================<br>		<br>		;=== INSTRUMENT 2: LOOK-AHEAD PEAK DETECTION NET ====================<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">instr</a> 2<br>		;--- Initialization --------------------------------------------------<br>		ilookahd = p4 ;Look-ahead window size (in seconds).<br>		idetid = p5 ;Look-ahead detector ID (0,1,...).<br>		idetnum = p6 ;Total number of detectors (up to 10).<br>		ioverlap = 4/sr ;<br>		idelta = 2/sr ;<br>		;Current detector win size (in sec.):<br>		iwinsize = (idetid=idetnum-1 ? ilookahd/idetnum - idelta : ilookahd/idetnum + ioverlap)<br>		idelay = ilookahd*1000*idetid/idetnum<br>		kptime <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 0 ;Time of current look-ahead peak.<br>		kpval <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 0 ;Value of current look-ahead peak.<br>		ktime <a href="../../Reference/Manual4.0/siggen/line.htm">line</a> 0, p3, p3 ;Time passed.<br>		gklap0 <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 0 ;Look-ahead peak of detector #0.<br>		gklap1 <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 1 ;Look-ahead peak of detector #1.<br>		gklap2 <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 2 ;Look-ahead peak of detector #2.<br>		gklap3 <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 3 ;Look-ahead peak of detector #3.<br>		gklap4 <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 4 ;Look-ahead peak of detector #4.<br>		gklap5 <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 5 ;Look-ahead peak of detector #5.<br>		gklap6 <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 6 ;Look-ahead peak of detector #6.<br>		gklap7 <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 7 ;Look-ahead peak of detector #7.<br>		gklap8 <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 8 ;Look-ahead peak of detector #8.<br>		gklap9 <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 9 ;Look-ahead peak of detector #9.<br>		;---------------------------------------------------------------------<br>		;--- Create appropriate look-ahead signal ----------------------------<br>		aintmp = gasig<br>		ain <a href="../../Reference/Manual4.0/sigmod/vdelay.htm">vdelay</a> aintmp, idelay, idelay+1<br>		kin <a href="../../Reference/Manual4.0/sigmod/samphold.htm">downsamp</a> ain<br>		kin = <a href="../../Reference/Manual4.0/valcnv/int.htm">abs</a>(kin)<br>		;---------------------------------------------------------------------<br>		;--- Look-ahead signal treatment -------------------------------------<br>		;--- if current la peak has expired,<br>		; replace it with current sample level. ---<br>		kpval = (kptime &lt; ktime-iwinsize ? kin : kpval )<br>		kptime = (kptime &lt; ktime-iwinsize ? ktime : kptime )<br>		;--- if current sample is higher than current la peak,<br>		; replace la peak with current sample. ---<br>		kptime = (kin &gt;= kpval ? ktime : kptime )<br>		kpval = (kin &gt;= kpval ? kin : kpval )<br>		;---------------------------------------------------------------------<br>		;--- Update look-ahead peak list -------------------------------------<br>		gklap0 = (idetid=0 ? kpval : gklap0)<br>		gklap1 = (idetid=1 ? kpval : gklap1)<br>		gklap2 = (idetid=2 ? kpval : gklap2)<br>		gklap3 = (idetid=3 ? kpval : gklap3)<br>		gklap4 = (idetid=4 ? kpval : gklap4)<br>		gklap5 = (idetid=5 ? kpval : gklap5)<br>		gklap6 = (idetid=6 ? kpval : gklap6)<br>		gklap7 = (idetid=7 ? kpval : gklap7)<br>		gklap8 = (idetid=8 ? kpval : gklap8)<br>		gklap9 = (idetid=9 ? kpval : gklap9)<br>		;---------------------------------------------------------------------<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">endin</a><br>		<br>		;=====================================================================<br>		;=== INSTRUMENT 3: THE MAIN ENVELOPE FOLLOWER AND THE COMPRESSOR ====<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">instr</a> 3<br>		;--- Initialization --------------------------------------------------<br>		ithresh = p4 ;Threshold - in dB (max 0).<br>		iratio = 1/p5 ;Ratio - a number &gt;= 1.<br>		iattack = 1/p6 ;Attack - in seconds.<br>		irelease = p7 ;Release - in seconds.<br>		ireamp = <a href="../../Reference/Manual4.0/valcnv/int.htm">ampdb</a>(p8) ;Compensation - in dB (0=no change).<br>		ilookahd = p9 ;Look-Ahead - in seconds.<br>		ihedroom = <a href="../../Reference/Manual4.0/valcnv/int.htm">dbamp</a>(32768) ;Specific for 16 bit sound files.<br>		irelcrvi = 2 ;ID of ftable for release_curve.<br>		irelcrvs = 4096 ;Size of ftable for release_curve.<br>		idelay = ilookahd*1000<br>		krtime <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 0 ;Start-time of current release stage.<br>		kpval <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 0 ;Value of current peak.<br>		ktime <a href="../../Reference/Manual4.0/siggen/line.htm">line</a> 0, p3, p3 ;Establish a clock.<br>		klapval <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 0 ;Current highest look-ahead peak.<br>		klaptime <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 0<br>		kenv <a href="../../Reference/Manual4.0/syntax/assign.htm">init</a> 0<br>		;---------------------------------------------------------------------<br>		;--- Delay Signal ----------------------------------------------------<br>		aintmp = gasig<br>		ain <a href="../../Reference/Manual4.0/sigmod/vdelay.htm">vdelay</a> aintmp, idelay, idelay+1<br>		kin <a href="../../Reference/Manual4.0/sigmod/samphold.htm">downsamp</a> ain<br>		kin = <a href="../../Reference/Manual4.0/valcnv/int.htm">abs</a>(kin)<br>		;---------------------------------------------------------------------<br>		;--- Get the highest look-ahead peak ---------------------------------<br>		klapval = gklap1<br>		klapval = (gklap2 &gt; klapval ? gklap2 : klapval)<br>		klapval = (gklap3 &gt; klapval ? gklap3 : klapval)<br>		klapval = (gklap4 &gt; klapval ? gklap4 : klapval)<br>		klapval = (gklap5 &gt; klapval ? gklap5 : klapval)<br>		klapval = (gklap6 &gt; klapval ? gklap6 : klapval)<br>		klapval = (gklap7 &gt; klapval ? gklap7 : klapval)<br>		klapval = (gklap8 &gt; klapval ? gklap8 : klapval)<br>		klapval = (gklap9 &gt; klapval ? gklap9 : klapval)<br>		;---------------------------------------------------------------------<br>		;--- Calculate release value - will not necessarily be used ----------<br>		kindex = irelcrvs*(ktime-krtime)/irelease<br>		kindex = (kindex &gt;= (irelcrvs-1) ? (irelcrvs-1) : kindex)<br>		kweight <a href="../../Reference/Manual4.0/siggen/table.htm">tablei</a> kindex, irelcrvi, 0, 0, 0<br>		krval = kweight*kpval<br>		;---------------------------------------------------------------------<br>		;--- If highest look-ahead peak is higher than current envelope,<br>		; &quot;freeze&quot; the envelope drop ---<br>		krval = (klapval&gt;=kenv ? kenv : krval) ;&quot;freeze&quot; env.<br>		krtime = (klapval&gt;=kenv ? ktime : krtime) ;restart release.<br>		kpval = (klapval&gt;=kenv ? kenv : kpval) ;reinit peak value.<br>		;---------------------------------------------------------------------<br>		;--- Update envelope value and handle the attack case ----------------<br>		kenv = krval<br>		<a href="../../Reference/Manual4.0/pgmctl/igoto.htm">if</a> krval &gt; kin kgoto noattack<br>		; - if new peak was detected (attack stage) -<br>		kpval = kin ;Update current peak value.<br>		kenv = kin ;Envelope gets current peak value.<br>		krtime = ktime ;Set release stage start-time.<br>		noattack:<br>		;---------------------------------------------------------------------<br>		;--- Hard-Knee Gain Reduction Unit -----------------------------------<br>		kenvd = <a href="../../Reference/Manual4.0/valcnv/int.htm">dbamp</a>(kenv+0.0001)-ihedroom<br>		kreduce = (kenvd &gt;= ithresh ? (kenvd-ithresh)*(iratio-1) : 0)<br>		areduce <a href="../../Reference/Manual4.0/sigmod/samphold.htm">interp</a> kreduce<br>		areduce <a href="../../Reference/Manual4.0/sigmod/butterhp.htm">butterlp</a> areduce,iattack ;Apply attack parameter.<br>		aout = ain*<a href="../../Reference/Manual4.0/valcnv/int.htm">ampdb</a>(areduce)*ireamp ;Apply compression.<br>		aenv = kenv ;aenv can be used for<br>		; envelope monitoring.<br>		;---------------------------------------------------------------------<br>		;--- Output the sound and its envelope -------------------------------<br>		<a href="../../Reference/Manual4.0/sigio/in.htm">out</a> aout<br>		; <a href="../../Reference/Manual4.0/sigio/in.htm">outs</a> aout, 32768+areduce*1000 ;Monitor gain-reduction.<br>		; <a href="../../Reference/Manual4.0/sigio/in.htm">outs</a> ain, aenv ;Monitor envelope.<br>		;---------------------------------------------------------------------<br>		<a href="../../Reference/Manual4.0/syntax/iblock.htm">endin</a><br>		<br>		;=========================== SCORE FILE ==============================<br>		f2 0 4097 6 1 4097 0 ; release curve<br>		; === Establish Look-ahead Detector Net ===<br>		;<br>		;----Time-LookAhead-Det_ID--Det_total_num--<br>		i2 0 4 0.05 0 10<br>		i2 . . . 1 .<br>		i2 . . . 2 .<br>		i2 . . . 3 .<br>		i2 . . . 4 .<br>		i2 . . . 5 .<br>		i2 . . . 6 .<br>		i2 . . . 7 .<br>		i2 . . . 8 .<br>		i2 . . . 9 .<br>		;<br>		; === Main Envelope-Follower/Compressor ===<br>		;<br>		;----Time-Thrsh-Rtio-Attack-Release-Compnst-LookAhd<br>		i3 0 4 -20 4 0.001 0.1 6 0.05<br>		;<br>		; === Sound-File Global Reader ===<br>		i1 0 4<br>		;<br>		e<br>		;=====================================================================</p>		<div align="justify">			<p><b><a name="_Ref385004472"></a>Figure 16:</b> A Csound compressor code based on the suggested look-ahead envelope follower.</p>		</div>		<p>&nbsp;</p>		<h3>Soft-Knee Compressors and Transfer-Function Driven Processing</h3>		<div align="justify">			<p>A useful way to describe the effect of a compressor is to draw a <i>transfer-function</i> which describes output amplitude vs. input amplitude. seventeentha demonstrates typical transfer-functions of a compressor. The compressor discussed in the previous sections is called a <i>Hard-Knee Compressor</i>. A <i>Soft-Knee Compressor</i> is a compressor which has a <i>variable ratio</i>:<b> </b>the louder the signal is, the higher the ratio will be. A typical transfer-function for a soft-knee compressor is drawn in seventeenthb. To implement a soft-knee compressor, one should replace the hard-knee gain-reduction unit with a <i>transfer-function driven gain-reduction unit</i>. Such a Csound implementation is not complicated - the desired transfer-function should be generated by the score-file as a ftable, and the gain-reduction unit should just emulate this function.</p>		</div>		<center>			<p><font size="1"><i><img height="336" width="545" src="fig17.gif"></i></font></p>		</center>		<div align="justify">			<p><font size="1"><b><a name="_Ref385505854"></a></b></font><b>Figure 17:</b> Transfer-functions of a hard-knee and a soft-knee compressors.</p>		</div>		<h3>Expanders, Noise Gates, Inverse Expanders and Limiters</h3>		<div align="justify">			<p>An <i>Expander</i> is a dynamics processor which <u>attenuates soft-parts</u> of the input signal. It is actually a transfer-function driven compressor with a transfer-function such as the one shown in eighteentha. Usually, expanders are used to reduce the perceived noise floor of the recording. A <i>Noise-Gate</i> is a more brutal type of an expander (eighteenthb.) The look-ahead feature previously described can be very useful in expansion/noise-gating situations. Expanders and noise gates should be used with a very fast attack setting. Once a transfer-function driven compressor is in use, it is trivial to combine an expander with a compressor (eighteenthc.) Furthermore, more special processing can be obtained, such as the <i>Inverse Expander</i> described in eighteenthd. The inverse expander is great for adding dynamic stability for an audio track - and it sounds quite different than a traditional compressor.</p>		</div>		<div align="justify">			<p>A <i>Limiter</i> is actually a compressor with a high threshold, a very high ratio (typically 20:1 and even more), a very-fast attack and a fast release. Such a processor is aimed at limiting the amplitude of the input signal by attenuating short and loud peaks found in the audio track.</p>		</div>		<center>			<p><font size="1"><i><img height="445" width="416" src="fig18.gif"></i></font></p>		</center>		<div align="justify">			<h3><b><a name="_Ref385505932"></a>Figure 18:</b> Transfer-functions of various dynamics processors.</h3>		</div>		<h3><b>Using a Side-Chain</b></h3>		<div align="justify">			<p>A dynamics processor that features a <i>side-chain</i> gets two audio inputs: <i>main </i>and <i>side-chain</i>. The envelope detector generates an envelope based on the side-chain signal, while the gain-reduction/amplification is performed on the main signal, which is then sent to the output. Such a configuration is useful for various applications. For example, a vocal recording often suffer from excessive <i>sibilant</i> sounds (the excessive &quot;ssss&quot;). The sibilant can be effectively reduced by connecting an EQed version of the original sound to the side-chain. The EQ should emphasize the sibilant frequencies. The compressor should be set in such a way that only when a loud signal comes from the side-chain (an &quot;sss&quot; sound), the compressor will apply a gain-reduction. Typical settings for the EQ may be: drastic HPF at 1.5KHz plus 12dB amplification of the 5-9KHz frequency range. Typical setting for the compressor may be: Attack=3 msec , Release= 9 msec , Ratio=1:10 and a threshold which is exceeded only when sibilant occur. This sibilant elimination process is called <i>De-essing</i>.</p>		</div>		<h3><b>Summary</b></h3>		<div align="justify">			<p>In this chapter, the design of graphic equalizers and dynamics processors in Csound was reviewed. To ensure high-quality results, careful testing and measurements should be performed during the development stage. The frequency response curve extraction program which was discussed in this chapter, is an important tool for such testing. A graphic equalizer is mainly based on a filter-bank. There are various filter-bank configurations, each of them may suit the needs of a different equalization application. As demonstrated, a tradeoff between the frequency-band isolation and the overall filter-bank integrity is usually found. Doubtlessly, compressors are one of the most critical units in a recording studio. The heart of the compressor is its envelope detector. Throughout this chapter, various envelope detection methods were presented and compared, and a complete compressor implementation was given.</p>			<p>The ultimate evaluation criterion of a signal processor is the way it <u>sounds</u>. This is especially true for dynamics processors and equalizers. Let your ears be the final judge and not your oscilloscope. However, use your oscilloscope (or any other measurement method) in order to achieve a better understanding of the processing results&#146; nature.</div>	</body></html>